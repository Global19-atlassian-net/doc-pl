<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: 1.66 Maintainer: leszek Status: ready -->
<!-- $Revision: 1.17 $ -->
 <chapter xml:id="language.oop" xmlns="http://docbook.org/ns/docbook">
  <title>Klasy i obiekty (PHP 4)</title>

  <sect1 xml:id="keyword.class">
   <title><literal>klasa</literal></title>
   <para>
    Klasa jest to zbiór zmiennych i funkcji operuj±cych na tych zmiennych.
    Do definicji klasy u¿ywana jest nastêpuj±ca sk³adnia:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Koszyk {
    var $zakupy;  // Zakupy w naszym koszyku
   
    // Dodaj $num artyku³ów typu $artnr do wózka
 
    function dodaj_produkt ($artnr, $num) {
        $this->zakupy[$artnr] += $num;
    }
   
    // Usuñ $num artyku³ów typu $artnr z wózka
 
    function usun_produkt ($artnr, $num) {
        if ($this->zakupy[$artnr] > $num) {
            $this->zakupy[$artnr] -= $num;
            return true;
        } elseif ($this->zakupy[$artnr] == $num) {
            unset($this->zakupy[$artnr]);
            return true;
        } else {
            return false;
        }   
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <para>
    Definiuje to klasê o nazwie Koszyk, która zawiera tablicê asocjacyjn±
    artyku³ów znajduj±cych siê w wózku i dwie funkcje do dodawania i usuwania
    produktów z koszyka.
   </para>

   <warning>
    <simpara>
     <emphasis>NIE</emphasis> jest mo¿liwe rozbicie definicji klasy na wiele
     plików. Tak¿e <emphasis>NIE</emphasis> jest mo¿liwe rozbicie definicji
     klasy na wiele bloków PHP, chyba ¿e rozbicie to znajduje siê wewn±trz
     definicji metody. Poni¿szy kod nie bêdzie dzia³aæ.
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class test {
?>
<?php
    function test() {
        print 'OK';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Jednak¿e poni¿szy kod jest dozwolony:
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class test {
    function test() {
        ?>
        <?php
        print 'OK';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </warning>
   <simpara>
    Poni¿sze uwagi dotycz± PHP 4.
   </simpara>
    
   <caution>
    <simpara>
     Nazwa <literal>stdClass</literal> jest u¿ywana wewnêtrznie przez Zend i
     jest zarezerwowana. W PHP nie mo¿esz zdefiniowaæ klasy o nazwie
     <literal>stdClass</literal>.
    </simpara>
   </caution>
   <caution>
    <simpara>
      Nazwy funkcji <literal>__sleep</literal> i <literal>__wakeup</literal>
      maj± magiczne znaczenie dla klas w PHP. Klasy nie mog± zawieraæ funkcji
      o tych nazwach, chyba ¿e zgadzasz siê na przypisanie do nich magicznej
      funkcjonalno¶ci. Poni¿ej mo¿esz znale¼æ wiêcej informacji.
    </simpara>
   </caution>
   <caution>
    <simpara>
      PHP rezerwuje wszystkie nazwy funkcji zaczynaj±ce siê od __ na funkcje
      magiczne. Zalecane jest nieu¿ywanie funkcji z nazwami zaczynaj±cymi siê
      od __ chyba ¿e chcesz jakiej¶ magicznej funkcjonalno¶ci.
    </simpara>
   </caution>

   <simpara>
    W PHP 4 dozwolone s± tylko sta³e inicjalizatory zmiennych
    <literal>var</literal>. Aby zainicjalizowaæ zmienne z nie-sta³ymi
    warto¶ciami, potrzebujesz funkcjê inicjalizacyjn±, która jest wywo³ywana
    automatycznie zaraz po utworzeniu obiektu z danej klasy. Taka funkcja
    zwana jest konstruktorem (zobacz poni¿ej).
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Koszyk {
/* Nic z tego nie bêdzie dzia³aæ w PHP 4. */
    var $dzisiejsza_data = date("Y-m-d");
    var $nazwa = $imie;
    var $wlasciciel = 'Fred ' . 'Jones';
/* Jednak¿e tablice zawieraj±ce sta³e - bêd± */
    var $artykuly = array("VCR", "TV");
}

/* Teraz wszystko zadziala. */
class Koszyk {
    var $dzisiejsza_data;
    var $nazwa;
    var $wlasciciel;
    var $artykuly = array("VCR", "TV");

    function Koszyk() {
        $this->dzisiejsza_data = date("Y-m-d");
        $this->nazwa = $GLOBALS['imie'];
        /* itp. . . */
    }
?>
]]>
    </programlisting>
   </informalexample>
   <para>
    Klasy s± typami, które s± w zasadzie tylko schematami dla w³a¶ciwych
    zmiennych. Zmienne po¿±danego typu musisz stworzyæ korzystaj±c z operatora
    <literal>new</literal>.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$koszyk = new Koszyk;
$koszyk->dodaj_produkt("10", 1);

$inny_koszyk = new Koszyk;
$inny_koszyk->dodaj_produkt("0815", 3);
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Kod ten tworzy obiekty <varname>$koszyk</varname> i
    <varname>$inny_koszyk</varname>, oba klasy Koszyk. Funkcja dodaj_produkt()
    obiektu <varname>$koszyk</varname> zostaje wywo³ana w celu dodania 1
    artyku³u typu "10" do koszyka <varname>$koszyk</varname>. 3 przedmioty
    typu "0815" dodawane s± do koszyka <varname>$inny_koszyk</varname>.
   </para>
   
   <para>
    I <varname>$koszyk</varname> i <varname>$inny_koszyk</varname> maj±
    funkcje dodaj_produkt(), usun_produkt() i zmienne. S± to osobne funkcje i
    zmienne. Obiekty mog± byæ postrzegane jako katalogi w systemie plików. W
    systemie plików mo¿esz mieæ dwa ró¿ne pliki
    <filename>README.TXT</filename>, ale tylko je¶li istniej± w osobnych
    katalogach. Aby odczytaæ plik, bêd±c w g³ównym katalogu, musisz podaæ
    pe³n± ¶cie¿kê do tego pliku.  Tak samo jest przy obiektach: musisz podaæ
    pe³n± nazwê funkcji, z której chcesz skorzystaæ. W terminologii PHP
    katalogiem g³ównym bêdzie globalna przestrzeñ nazw a separatorem ¶cie¿ki
    bêdzie -&gt;. W zwi±zku z tym nazwy $koszyk i $inny_koszyk zawieraj±
    zupe³nie inne zmienne. Zauwa¿, ¿e zmienna nazywa siê
    <varname>$koszyk-&gt;artykuly</varname>, a nie
    <varname>$koszyk-&gt;$artykuly</varname>, poniewa¿ nazwa zmiennej mo¿e
    zawieraæ tylko jeden znak dolara.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// poprawnie, jeden $
$koszyk->artykuly = array("10" => 1); 

// niepoprawnie, poniwa¿ $koszyk->$artykuly zamienia siê na $koszyk->""
$koszyk->$artykuly = array("10" => 1);

// poprawnie, ale mo¿e (ale nie musi) nie byæ tym, co zamierzali¶my:
// $koszyk->$zmienna staje siê $koszyk->artykuly
$zmienna = 'artykuly';
$koszyk->$zmienna = array("10" => 1);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Wewn±trz definicji klasy, nie wiesz pod jak± nazw± obiekt bêdzie dostêpny
    dla twojego programu: w momencie pisania klasy Koszyk, nie by³o wiadomo,
    czy obiekty bêd± siê nazywaæ <varname>$koszyk</varname>,
    <varname>$inny_koszyk</varname>, lub inaczej. W zwi±zku z tym nie mo¿esz napisaæ
    <varname>$koszyk-&gt;artykuly</varname> wewn±trz klasy Koszyk. Zamiast
    tego, aby uzyskaæ dostêp do funkcji i zmiennych zawartych w klasie, mo¿na
    u¿yæ pseudo-zmiennej $this, która mo¿e byæ odczytana jako 'moje w³asne'
    lub 'bie¿±cy obiekt'. A wiêc
    '<varname>$this-&gt;artykuly[$nrart]</varname> +=
    <varname>$liczba</varname>' mo¿e byæ odczytane jako 'dodaj
    <varname>$liczba</varname> do licznika <varname>$nrart</varname> z mojej
    w³asnej tablicy artykuly' lub 'dodaj <varname>$liczba</varname> do
    licznika <varname>$nrartz</varname> tablicy artykuly zawartej w bie¿±cym
    obiekcie'.
   </para>
   <!-- TODO -->
   <note>
    <para>
     The <varname>$this</varname> pseudo-variable is not usually defined if
     the method in which it is hosted is called statically. This is not,
     however, a strict rule: <varname>$this</varname> is defined if a method is
     called statically from within another object. In this case, the value of
     <varname>$this</varname> is that of the calling object. This is
     illustrated in the following example:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this is defined (';
            echo get_class($this);
            echo ")\n";
        } else {
            echo "\$this is not defined.\n";
        }
    }
}

class B
{
    function bar()
    {
        A::foo();
    }
}

$a = new A();
$a->foo();
A::foo();
$b = new B();
$b->bar();
B::bar();
?>
]]>     
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
$this is defined (a)
$this is not defined.
$this is defined (b)
$this is not defined.
]]>
      </screen>
     </informalexample>
    </para>
   </note>

   <note>
    <para>
     Istnieje kilka przyjemnych funkcji do obs³ugi klas i obiektów. Mo¿esz je
     zobaczyæ w rozdziale <link linkend="ref.classobj">Funkcje obs³ugi klas i
      obiektów</link>.
    </para>
   </note>
  </sect1>
  
  <sect1 xml:id="keyword.extends">
   <title><literal>extends</literal></title>

   <para>
    Bardzo czêsto zachodzi potrzeba stworzenia klasy o funkcjach i zmiennych
    podobnych do ju¿ istniej±cej klasy. Zasadniczo dobrze jest stworzyæ
    szablonow± klasê, która mo¿e byæ u¿yta we wszystkich twoich projektach i
    przystosowywaæ j± do specyficznych potrzeb twojego projektu. Aby u³atwiæ
    ten proces, klasy mog± byæ rozszerzeniami innych klas. Rozszerzone, lub
    mówi±c inaczej 'dziedziczone', klasy maj± wszystkie zmienne i funkcje
    klasy podstawowej (nazywa siê to dziedziczeniem, mimo ¿e nikt nie
    umar³) oraz to co do niej doda³e¶ w definicji rozszerzenia. Nie mo¿na
    odj±æ pewnych rzeczy z klasy podstawowej, czyli oddefiniowaæ istniej±cych
    w klasie podstawowej funkcji i zmiennych. Rozszerzona klasa jest zawsze
    zale¿na od jednej klasy bazowej - dziedziczenie wielokrotne nie jest
    obs³ugiwane. Klasy mo¿na rozszerzyæ u¿ywaj±c s³owa kluczowego 'extends'.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Nazwany_Koszyk extends Koszyk {
    var $wlasciciel;
  
    function ustaw_wlasciciela ($nazwa) {
        $this->wlasciciel = $nazwa;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Definiuje to klasê Nazwany_Koszyk, który ma wszystkie zmienne i funkcje
    klasy Koszyk plus dodatkowa zmienna <varname>$wlasciciel</varname> i
    dodatkowa funkcja ustaw_wlasciciela(). Nazwany koszyk tworzy siê normalnym
    sposobem.  Mo¿esz teraz ustawiaæ i pobieraæ nazwê w³a¶ciciela koszyka.
    Ca³y czas mo¿esz u¿ywaæ zwyk³ych funkcji koszyka dla nazwanego koszyka:
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$nkoszyk = new Nazwany_Koszyk;        // Stwórz nazwany koszyk
$nkoszyk->ustaw_wlasciciela("kris");  // Nazwij koszyk
print $nkoszyk->wlasciciel;           // Wy¶wietl w³a¶ciciela koszyka
$nkoszyk->dodaj_przedmiot("10", 1);   // (funkcjonalno¶æ odziedziczona z
                                      // koszyka)
?>
]]>
    </programlisting>
   </informalexample>
   <para>
    Taka relacja nazywana jest czêsto relacj± "rodzic-potomek". Tworzysz
    klasê - rodzica - i u¿ywasz <literal>extends</literal> aby stworzyæ klasê
    <emphasis>opart±</emphasis> o klasê rodzica: klasê potomn±. Mo¿esz tak¿e
    tworzyæ nowe klasy potomne oparte o t± klasê potomn±.
   </para>
   <note>
    <para>
     Klasy musza byæ zdefiniowane zanim zostan± u¿yte! Je¶li chcesz, aby klasa
     <literal>Nazwany_Koszyk</literal> rozszerza³a klasê
     <literal>Koszyk</literal>, musisz zdefiniowaæ klasê
     <literal>Koszyk</literal> jako pierwsz±. Je¶li chcesz stworzyæ kolejn±
     klasê nazwan± <literal>Niebieski_Nazwany_Koszyk</literal> opart± o
     klasê <literal>Nazwany_Koszyk</literal>, musisz najpierw zdefiniowaæ
     klasê <literal>Nazwany_Koszyk</literal>. W skrócie: kolejno¶æ, w jakiej
     klasy s± definiowane, jest bardzo wa¿na.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.oop.constructor">
   <title>Konstruktory</title>

   <para>
    Konstruktory s± funkcjami klasy, które s± automatycznie wywo³ywane przy
    tworzeniu nowej instancji klasy korzystaj±c z operatora
    <literal>new</literal>. Funkcja staje siê konstruktorem kiedy ma
    tak± sam± nazwê jak klasa. Je¶li klasa nie ma konstruktora, u¿yty zostanie
    konstruktor klasy nadrzêdnej, je¶li taka istnieje.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Auto_Koszyk extends Koszyk {
    function Auto_Koszyk()
    {
        $this->dodaj_artykul ("10", 1);
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Ten kod definiujê klasê Auto_Koszyk, który jest klas± Koszyk pluc
    konstruktor, który inicjalizuje wózek z jednym artyku³em "10" za ka¿dym
    razem, kiedy Auto_Koszyk jest tworzony operatorem "new". Konstruktory mog±
    pobieraæ argumenty i te argumenty mog± byæ opcjonalne, przez co s± jeszcze
    bardziej u¿yteczne. Aby w dalszym ci±gu móc u¿ywaæ klasy bez parametrów,
    wszystkie parametry konstruktora powinny staæ siê opcjonalne przez dodanie
    domy¶lnych warto¶ci.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Kontruktor_Koszyk extends Koszyk {
    function Konstruktor_Koszyk($artykul = "10", $ilosc = 1)
    {
        $this->dodaj_artykul ($artykul, $ilosc);
    }
}
 
// Kup te same nudne rzeczy...
$zwykly_koszyk = new Konstruktor_Koszyk;
 
// Czas na prawdziwe zakupy...
$inny_koszyk = new Konstruktor_Koszyk("20", 17);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Mo¿esz tak¿e u¿yæ operatora <literal>@</literal> aby
    <emphasis>wyciszyæ</emphasis> b³êdy zachodz±ce w konstruktorze, np.
    <literal>@new</literal>
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function A()
    {
        echo "Jestem konstruktorem klasy A.<br />\n";
    }

    function B()
    {
        echo "Jestem zwyk³± funkcj± o nazwie B w klasie A.<br />\n";
        echo "Nie jestem konstruktorem w klasie A.<br />\n";
    }
}

class B extends A
{
}

// Wywo³a to B() jako konstruktor.
$b = new B;
?>
]]>
    </programlisting>
   </informalexample>
   
   <para>
    Funkcja B() z klasy A niespodziewanie stanie siê konstruktorem w
    klasie B, pomimo ¿e wcale nie mia³a nim byæ.  PHP 4 nie
    obchodzi czy funkcja zosta³a zdefiniowana w klasie B czy zosta³a
    odziedziczona.
   </para>
   
   <caution>
    <simpara>
     PHP 4 nie wywo³uje automatycznie konstruktora klasy bazowej z
     kontruktora klasy pochodnej. Twoim zadaniem jest propagacja wywo³añ
     konstruktorów klas nadrzêdnych, je¶li to konieczne.
    </simpara>
   </caution>
   
   <para>
    Destruktory s± funkcjami, które s± wywo³ywanie automatycznie kiedy obiekty
    s± niszczone albo przez u¿ycie <function>unset</function> albo przez
    wyj¶cie z zasiêgu. W PHP nie ma destruktorów. Mo¿na jednak u¿yæ funkcji
    <function>register_shutdown_function</function> aby symulowaæ dzia³anie
    destruktorów.
   </para>
  </sect1>

 <sect1 xml:id="keyword.paamayim-nekudotayim"><!-- :-) -->
   <title>Operator rozró¿nienia zasiêgu (<literal>::</literal>)</title>

   <caution>
    <simpara>
     Poni¿sze dotyczy tylko PHP 4 i nowszych.
    </simpara>
   </caution>

   <para>
    Czasami dobrze jest odnosiæ siê do funkcji i zmiennych w klasie bazowej
    lub odnosiæ siê do funkcji i klas które nie maj± jeszcze instancji. S³u¿y
    do tego operator ::.
   </para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A {
    function przyklad() {
        echo "Jestem orginaln± funkcj± A::przyklad().<br />\n";
    }
}

class B extends A {
    function przyklad() {
        echo "Jestem przedefiniowan± funkcj± B::przyklad().<br />\n";
        A::przyklad();
    }
}

// nie ma obiektu klasy A.
// poni¿sze wy¶wietli
//   Jestem orginaln± funkcj± A::przyklad().<br />
A::przyklad();

// stwórz nowy obiekt klasy B.
$b = new B;

// poni¿sze wy¶wietli
//   Jestem przedefiniowan± funkcj± B::przyklad().<br />
//   Jestem orginaln± funkcj± A::przyklad().<br />
$b->przyklad();
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Powy¿szy przek³ad wywo³uje funkcjê przyklad() z klasy A, ale nie tworz±c
    obiektu tej klasy, przez co nie mo¿emy napisaæ nic w stylu $a->przyklad().
    Zamiast tego mo¿emy wywo³aæ przyklad() jako 'funkcjê klasy', czyli jako
    funkcjê tylko klasy, nie ¿adnego obiektu tej klasy.
   </para>
   
   <para>
    Istniej± funkcje klasy, ale nie ma zmiennych klasy. Faktycznie w czasie
    wykonania nie ma ¿adnego obiektu. W zwi±zku z tym funkcje klasy nie mog±
    u¿ywaæ ¿adnych zmiennych obiektu (ale mog± u¿ywaæ zmiennych lokalnych i
    globalnych), ani w ogóle <varname>$this</varname>.
   </para>

   <para>
    W powy¿szym przyk³adzie, klasa B przedefiniowuje funkcjê przyklad().
    Orginalna definicja z klasy A jest zas³oniêta i niedostêpna, chyba ¿e
    odwo³asz siê do konkretnej implementacji poprzez operator ::. Aby to
    zrobiæ, napisz A::przyklad() (powiniene¶ jednak u¿yæ parent::przyklad(),
    tak jak to pokazano w nastêpnej czê¶ci).
   </para>
   
   <para>
    W tym kontek¶cie, istnieje bie¿±cy obiekt i który ma zmienne obiektu. W
    zwi±zu z tym je¶li funkcja jest u¿yta Z WEWN¡TRZ funkcji obiektu, mo¿esz
    u¿ywaæ <varname>$this</varname> i zmiennych obiektu.
   </para>

 </sect1>

 <sect1 xml:id="keyword.parent">
   <title><literal>parent</literal></title>

  <para>
   Mo¿e siê zdarzyæ, ¿e bêdziesz pisa³ kod, który odnosi siê do funkcji i
   zmiennych klasy bazowej. Jest to mo¿liwe je¶li twoja klasa pochodna jest
   u¶ci¶leniem lub specjalizacj± klasy bazowej.
  </para>
  
  <para>
   Zamiast jawnego podawania nazwy klasy bazowej w kodzie, powiniene¶ u¿yæ
   specjalnej nazwy <literal>parent</literal>, która odnosi siê do nazwy klasy
   bazowej podanej przy <literal>extends</literal> podczas deklaracji twojej
   klasy. Robi±c to, unikasz u¿ycia nazwy klasy bazowej w wiêcej ni¿ jednym
   miejscu. Je¶li twoje drzewo dziedziczenia zmieni³oby siê podczas
   implementacji, zmiana bêdzie wymaga³a poprawki tylko w jednym miejscu -
   przy s³owie kluczowym <literal>extends</literal> w deklaracji klasy.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class A {
    function przyklad() {
        echo "Jestem A::przyklad() I dostarczam podstawow± funkcjonalno¶æ.<br />\n";
    }
}

class B extends A {
    function przyklad() {
        echo "Jestem B::przyklad() i dostarczam dodatkow± funkcjonalno¶æ.<br />\n";
        parent::przyklad();
    }
}

$b = new B;

// Wywo³a to B::przyklad(), który z kolei wywo³a A::przyklad().
$b->przyklad();
?>
]]>
   </programlisting>
  </informalexample>
 </sect1>

 <sect1 xml:id="language.oop.serialization">
  <title>Serializacja obiektów - obiekty w sesjach</title>

  <note>
   <simpara>
    W PHP 3 obiekty trac± powi±zania miêdzy klasami w czasie procesu
    serializacji i odserializacji. Wynikowa zmienna bêdzie typu obiekt, ale
    bez klasy i bez metod, a wiêc w zasadzie bezu¿yteczn± (zostanie poprostu
    zmienn± ze ¶mieszn± sk³adni±).
   </simpara>
  </note>

  <caution>
   <simpara>
    Poni¿sze informacje dotycz± tylko PHP &gt; 4.
   </simpara>
  </caution>

  <para>
   <function>serialize</function> zwraca string bêd±cy reprezentacj± dowolnej
   warto¶ci, która mo¿e byæ przechowywana przez PHP.
   <function>unserialize</function> mo¿e u¿yæ tego stringu aby odtworzyæ
   orginalne warto¶ci zmiennej. U¿ycie serializacji do zapisania obiektu
   zachowa wszystkie zmienne z obiektu. Zapisane nie bêd± funkcje z obiektu, a
   jedynie nazwa klasy.
  </para>
  
  <para>
   Aby istnia³a mo¿liwo¶æ u¿ycia funkcji <function>unserialize</function> do
   odzyskania obiektu, musi byæ zdefiniowana klasa tego obiektu. Oznacza to,
   ¿e je¶li obiekt <varname>$a</varname> klasy A istnieje na page1.php i
   zostanie on zserializowany, otrzymany zostanie ci±g znakowy, który odnosi
   siê do klasy A i zawiera warto¶ci wszystkich zmiennych zawartych w
   <varname>$a</varname>. Aby istnia³a mo¿liwo¶æ deserializacji tego obiektu
   na page2.php, na page2.php musi istnieæ definicja klasy A. Mo¿na to zrobiæ
   na przyk³ad przez przechowywanie definicji klasy A w zewnêtrznym pliku
   do³±czanym przez page1.php i page2.php.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// classa.inc:
  class A {
      var $jeden = 1;
    
      function pokaz_jeden() {
          echo $this->jeden;
      }
  }
  
// page1.php:

  include("classa.inc");
  
  $a = new A;
  $s = serialize($a);
  // przechowaj $s gdzie¶, gdzie page2.php bêdzie mog³a go znale¼æ
  $fp = fopen("store", "w");
  fwrite($fp, $s);
  fclose($fp);

// page2.php:

  // to jest niezbêdne aby funkcja unserialize dzia³a³a prawid³owo.
  include("classa.inc");

  $s = implode("", @file("store"));
  $a = unserialize($s);

  // teraz u¿yj funkcji pokaz_jeden z obiektu $a.
  $a->pokaz_jeden();
?>
]]>
   </programlisting>
  </informalexample>
  
  <para>
   Je¶li u¿ywasz sesji i <function>session_register</function> do rejestracji
   obiektów, te obiekty s± serializowane automatycznie na koñcu ka¿dej strony
   PHP i odserializowane automatycznie na ka¿dej z nastêpnych stron.
   Zasadniczo znaczy to, ¿e te obiekty mog± pokazaæ siê na dowolnej z twoich
   stron je¶li tylko stan± siê czê¶ci± twojej sesji.
  </para>
  
  <para>
   Mocno zalecane jest includowanie definicji klas wszystkich zarejestrowanych
   obiektów na wszystkich twoich stronach, nawet je¶li nie u¿ywasz tych
   zmiennych na twoich stronach. Je¶li tego nie zrobisz a obiekty zostan±
   odserializowane bez definicji klasy, powi±zania klasowe zostan± utracone a
   obiek stanie siê obiektem klasy <literal>stdClass</literal> bez ¿adnych
   dostêpnych funkcji, a wiêc bêdzie ca³kiem bezu¿yteczny.
  </para>
  
  <para>
   A wiêc je¶li w powy¿szym przyk³adzie <varname>$a</varname> stanie siê
   czê¶ci± sesji przez wywo³anie <literal>session_register("a")</literal>,
   powinieneæ includowaæ plik <literal>classa.inc</literal> na wszystkich
   stronach, nie tylko page1.php i page2.php.
  </para>
 </sect1>

 <sect1 xml:id="language.oop.magic-functions">
  <title>Magiczne funkcje <literal>__sleep</literal> i <literal>__wakeup</literal></title>

  <para>
   <function>serialize</function> sprawdza, czy twoja klasa zawiera funkcjê o
   magicznej nazwie <literal>__sleep</literal>. Je¶li tak, ta funkcja jest
   wywo³ywana przed ka¿d± serializacj±. Mo¿e ona czy¶ciæ obiekt i powinna
   zwracaæ tablicê z nazwami wszystkich zmiennych obiektu, które powinny byæ
   serializowane.
  </para>
  
  <para>
   Za³o¿onym u¿yciem <literal>__sleep</literal> jest zamkniêcie wszystkich
   po³±czeñ do baz danych, które obiekt mo¿e utrzymywaæ, zatwierdzenie
   wszystkich oczekuj±cych danych lub wykonanie innych podobnych czynno¶ci
   czyszcz±cych. Funkcja ta jest tak¿e przydatna je¶li masz bardzo du¿e
   obiekty, które nie musz± byæ zachowane w ca³o¶ci.
  </para>
  
  <para>
   Analogicznie, <function>unserialize</function> sprawdza czy istnieje
   funkcja o magicznej nazwie <literal>__wakeup</literal>. Je¶li tak, funkcja
   mo¿e rekonstruowaæ dowolne zasoby które obiekt mo¿e posiadaæ.
  </para>
  
  <para>
    Za³o¿onym u¿yciem <literal>__wakeup</literal> jest odnowienie po³±czeñ z
    bazami danych, które mog³y zostac utracone w procesie serializacji, oraz
    wykonanie innych czynno¶ci odbudowuj±cych obiekt.
  </para>
 </sect1>
  
 <sect1 xml:id="language.oop.newref">
   <title>Referencje wewn±trz konstruktora</title>
   <para>
    Tworzenie referencji wewn±trz konstruktora mo¿e prowadziæ do dziwnych
    efektów. Ten rozdzia³ ma pomóc w unikaniu takich problemów.
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Foo {
    function Foo($nazwa) {
        // stworz referencje wewnatrz globalnej tablicy $globalref
        global $globalref;
        $globalref[] = &$this;
        // ustaw nazwê na przekazan± warto¶æ
        $this->ustawNazwe($nazwa);
        // i wy¶wietl j±
        $this->wyswietlNazwe();
    }

    function wyswietlNazwe() {
        echo "<br />",$this->nazwa;
    }
	
    function ustawNazwe($nazwa) {
        $this->nazwa = $nazwa;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
    
   <para>
    Sprawd¼my, czy jest jaka¶ ró¿nica pomiêdzy
    <varname>$bar1</varname>, który jest tworzony przy pomocy operatora
    przypisania <literal>=</literal>, a <varname>$bar2</varname>, który zosta³
    stworzony u¿ywaj±c operatora referencji <literal>=&amp;</literal>...

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bar1 = new Foo('ustawione w konstruktorze');
$bar1->wyswietlNazwe();
$globalref[0]->wyswietlNazwe();

/* wyj¶cie:
ustawione w konstruktorze
ustawione w konstruktorze
ustawione w konstruktorze */

$bar2 =& new Foo('ustawione w konstruktorze');
$bar2->wyswietlNazwe();
$globalref[1]->wyswietlNazwe();

/* wyj¶cie:
ustawione w konstruktorze
ustawione w konstruktorze
ustawione w konstruktorze */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Wydaje siê, ¿e nie ma ¿adnej ró¿nicy, ale na prawdê jest jedna, i to
    bardzo istotna: <varname>$bar1</varname> i
    <varname>$globalref[0]</varname> <emphasis>NIE</emphasis> s± referencjami,
    <emphasis>NIE</emphasis> s± t± sam± zmienna. Dzieje siê tak, poniewa¿
    "new" nie zwraca domy¶lnie referencji, ale kopiê.
    <note>
     <simpara>
      Zwracanie kopii zamiast referencji nie powoduje utraty wydajno¶ci (od
      PHP 4 u¿ywane jest zliczanie referencji). Jednak¿e zazwyczaj lepiej jest
      pracowaæ poprostu z kopiami zamiast referencji, poniewaæ tworzenie
      referencji zabiera trochê czasu, podczas gdy tworzenie kopii obiektów
      teoretycznie w ogóle nie zabiera czasu (chyba ¿e która¶ z tych zmiennych
      jest du¿± tablic± lub obiektem i jedno z nich ulega zmianie, po czym tej
      samej zmianie ulegaj± pozosta³e zmienne; wtedy lepiej jest u¿yæ
      referencji do zmieniania ich równolegle).
     </simpara>
    </note>
    Aby udowodniæ to, co zosta³o zapisane powy¿ej, przyjrzyjmy siê poni¿szemu
    programowi.

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// teraz zmienimy nazwê. czego siê spodziewasz?
// mo¿esz siê spodziewaæ, ¿e i $bar1 i $globalref[0] zmieni± swoje nazwy...
$bar1->ustawNazwe('ustawiona z zewn±trz');

// jak napisano powy¿ej, nic takiego siê nie stanie
$bar1->wyswietlNazwe();
$globalref[0]->wyswietlNazwe();

/* wyj¶cie:
ustawiona z zewn±trz
ustawiona w konstruktorze */

// zobaczmy co siê dzieje z $bar2 i $globalref[1]
$bar2->ustawNazwe('ustawiona z zewn±trz');

// na szczê¶cie ta zmienna nie zachowuje siê jak ta z poprzedniego przypadku
// s± to te same zmienne, z wiêc $bar2->nazwa i $globalref[1]->nazwa s± tak¿e
// tymi samymi zmiennymi
$bar2->wyswietlNazwe();
$globalref[1]->wyswietlNazwe();

/* wyj¶cie:
ustawiona z zewn±trz
ustawiona z zewn±trz */
?>
]]>
     </programlisting>
    </informalexample>   
   </para>   
   <para>
   Ustatni przyk³ad. Postaraj siê go zrozumieæ/
   
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class A {
    function A($i) {
        $this->wartosc = $i;
        // domy¶l siê dlaczego nie potrzebujemy tutaj referencji
        $this->b = new B($this);
    }

    function stworzRef() {
        $this->c = new B($this);
    }

    function wyswietlWartosc() {
        echo "<br />","klasa ",get_class($this),': ',$this->value;
    }
}


class B {
    function B(&$a) {
        $this->a = &$a;
    }

    function wyswietlWartosc() {
        echo "<br />","klasa ",get_class($this),': ',$this->a->value;
    }
}
// spróbuj zrozumieæ dlaczego u¿ycie tu prostego kopiowania mo¿e powodowaæ
// nieporz±dany efekt w linii uznaczonej znaczkiem '*'
$a =& new A(10);
$a->stworzRef();

$a->wyswietlWartosc();
$a->b->wyswietlWartosc();
$a->c->wyswietlWartosc();

$a->value = 11;

$a->wyswietlWartosc();
$a->b->wyswietlWartosc(); // *
$a->c->wyswietlWartosc();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
klasa A: 10
klasa B: 10
klasa B: 10
klasa A: 11
klasa B: 11
klasa B: 11
]]>
     </screen>
    </informalexample>
   </para>
  </sect1>
  <sect1 xml:id="language.oop.object-comparison">
   <title>Porównywanie obiektów</title>
   <para>
    W PHP 4 obiekty s± porównywane w bardzo prosty sposób, to znaczy dwie
    instancje obiektów s± uwa¿ane za równe, je¶li posiadaj± te same atrybuty i
    ich warto¶ci, a tak¿e s± instancjami tej samej klasy. Podobne regu³y s±
    stosowane, je¶li dwa obiekty s± porównywane za pomoc± operatora
    identyczno¶ci (<literal>===</literal>).
  </para>
  <para>
   <example>
    <title>Przyk³ad porównania obiektów w PHP 4</title>
    <programlisting role='php'>
<![CDATA[
<?php
function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function porownajObiekty(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flaga {
    var $flag;

    function Flaga($flag=true) {
            $this->flag = $flag;
    }
}

class przelaczalanaFlaga extends Flaga {

    function turnOn() {
        $this->flag = true;
    }

    function turnOff() {
        $this->flag = false;
    }
}

$o = new Flaga();
$p = new Flaga(false);
$q = new Flaga();

$r = new przelaczalnaFlaga();

echo "Porównaj instancje stworzone z tymi samymi argumentami\n";
porownajObiekty($o, $q);

echo "\nPorównaj instancje stworzone z ró¿nymi argumentami\n";
porownajObiekty($o, $p);

echo "\nPorównaj instancjê klasy nadrzêdnej z instancj± klasy podrzêdnej\n";
porownajObiekty($o, $r);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[    
Porównaj instancje stworzone z tymi samymi argumentami
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Porównaj instancje stworzone z ró¿nymi argumentami
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Porównaj instancjê klasy nadrzêdnej z instancj± klasy podrzêdnej
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
    </screen>
   </example>   
  </para>
  <para>
   Wynik dzia³ania powy¿szego skryptu jest ca³kowicie przewidywalny na
   podstawie przedstawionych wy¿ej regu³. Tylko instancje o tych samych
   warto¶ciach tych samych atrybutów, pochodz±ce z tej samej klasy, s±
   uznawane za równe i identyczne.
  </para>
  <para>
   Nawet w przypadku kompozycji obiektów stosowane s± te same regu³y
   porównywania. W poni¿szym przyk³adzie stworzona zosta³a klasa-pojemnik,
   która zawiera tablicê asocjacyjn± obiektów klasy
   <classname>Flaga</classname>.
   <example>
    <title>Porównywanie obiektów z³o¿onych w PHP 4</title>
    <programlisting role='php'>
<![CDATA[
<?php
class ZbiorFlag {
    var $set;

    function ZbiorFlag($flagArr = array()) {
        $this->set = $flagArr;
    }

    function addFlag($name, $flag) {
        $this->set[$name] = $flag;
    }

    function removeFlag($name) {
        if (array_key_exists($name, $this->set)) {
            unset($this->set[$name]);
        }
    }
}


$u = new ZbiorFlag();
$u->addFlag('flag1', $o);
$u->addFlag('flag2', $p);
$v = new ZbiorFlag(array('flag1'=>$q, 'flag2'=>$p));
$w = new ZbiorFlag(array('flag1'=>$q));

echo "\nObiekty z³o¿one u(o,p) i v(q,p)\n";
porownajObiekty($u, $v);

echo "\nu(o,p) i w(q)\n";
porownajObiekty($u, $w);
?>     
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Obiekty z³o¿one u(o,p) i v(q,p)
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

u(o,p) i w(q)
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
    </screen>
   </example>
  </para>
 </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
