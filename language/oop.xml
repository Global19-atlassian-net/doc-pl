<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: n/a Maintainer: leszek Status: ready -->
<!-- $Revision$ -->
 <chapter xml:id="language.oop" xmlns="http://docbook.org/ns/docbook">
  <title>Klasy i obiekty (PHP 4)</title>

  <sect1 xml:id="keyword.class">
   <title><literal>klasa</literal></title>
   <para>
    Klasa jest to zbiór zmiennych i funkcji operujących na tych zmiennych.
    Zmienne są definiowane słowem kluczowym <literal>var</literal>, a funkcje
    - <literal>function</literal>.  Do definicji klasy używana jest
    następująca składnia:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Koszyk {
    var $zakupy;  // Zakupy w naszym koszyku
   
    // Dodaj $num artykułów typu $artnr do wózka
 
    function dodaj_produkt ($artnr, $num) {
        $this->zakupy[$artnr] += $num;
    }
   
    // Usuń $num artykułów typu $artnr z wózka
 
    function usun_produkt ($artnr, $num) {
        if ($this->zakupy[$artnr] > $num) {
            $this->zakupy[$artnr] -= $num;
            return true;
        } elseif ($this->zakupy[$artnr] == $num) {
            unset($this->zakupy[$artnr]);
            return true;
        } else {
            return false;
        }   
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <para>
    Definiuje to klasę o nazwie Koszyk, która zawiera tablicę asocjacyjną
    artykułów znajdujących się w wózku i dwie funkcje do dodawania i usuwania
    produktów z koszyka.
   </para>

   <warning>
    <simpara>
     <emphasis>NIE</emphasis> jest możliwe rozbicie definicji klasy na wiele
     plików. Także <emphasis>NIE</emphasis> jest możliwe rozbicie definicji
     klasy na wiele bloków PHP, chyba że rozbicie to znajduje się wewnątrz
     definicji metody. Poniższy kod nie będzie działać.
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class test {
?>
<?php
    function test() {
        print 'OK';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Jednakże poniższy kod jest dozwolony:
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class test {
    function test() {
        ?>
        <?php
        print 'OK';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </warning>
   <simpara>
    Poniższe uwagi dotyczą PHP 4.
   </simpara>
    
   <caution>
    <simpara>
     Nazwa <literal>stdClass</literal> jest używana wewnętrznie przez Zend i
     jest zarezerwowana. W PHP nie możesz zdefiniować klasy o nazwie
     <literal>stdClass</literal>.
    </simpara>
   </caution>
   <caution>
    <simpara>
      Nazwy funkcji <literal>__sleep</literal> i <literal>__wakeup</literal>
      mają magiczne znaczenie dla klas w PHP. Klasy nie mogą zawierać funkcji
      o tych nazwach, chyba że zgadzasz się na przypisanie do nich magicznej
      funkcjonalności. Poniżej możesz znaleźć więcej informacji.
    </simpara>
   </caution>
   <caution>
    <simpara>
      PHP rezerwuje wszystkie nazwy funkcji zaczynające się od __ na funkcje
      magiczne. Zalecane jest nieużywanie funkcji z nazwami zaczynającymi się
      od __ chyba że chcesz jakiejś magicznej funkcjonalności.
    </simpara>
   </caution>

   <simpara>
    W PHP 4 dozwolone są tylko stałe inicjalizatory zmiennych
    <literal>var</literal>. Aby zainicjalizować zmienne z nie-stałymi
    wartościami, potrzebujesz funkcję inicjalizacyjną, która jest wywoływana
    automatycznie zaraz po utworzeniu obiektu z danej klasy. Taka funkcja
    zwana jest konstruktorem (zobacz poniżej).
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Koszyk {
/* Nic z tego nie będzie działać w PHP 4. */
    var $dzisiejsza_data = date("Y-m-d");
    var $nazwa = $imie;
    var $wlasciciel = 'Fred ' . 'Jones';
/* Jednakże tablice zawierające stałe - będą */
    var $artykuly = array("VCR", "TV");
}

/* Teraz wszystko zadziala. */
class Koszyk {
    var $dzisiejsza_data;
    var $nazwa;
    var $wlasciciel;
    var $artykuly = array("VCR", "TV");

    function Koszyk() {
        $this->dzisiejsza_data = date("Y-m-d");
        $this->nazwa = $GLOBALS['imie'];
        /* itp. . . */
    }
?>
]]>
    </programlisting>
   </informalexample>
   <para>
    Klasy są typami, które są w zasadzie tylko schematami dla właściwych
    zmiennych. Zmienne pożądanego typu musisz stworzyć korzystając z operatora
    <literal>new</literal>.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$koszyk = new Koszyk;
$koszyk->dodaj_produkt("10", 1);

$inny_koszyk = new Koszyk;
$inny_koszyk->dodaj_produkt("0815", 3);
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Kod ten tworzy obiekty <varname>$koszyk</varname> i
    <varname>$inny_koszyk</varname>, oba klasy Koszyk. Funkcja dodaj_produkt()
    obiektu <varname>$koszyk</varname> zostaje wywołana w celu dodania 1
    artykułu typu "10" do koszyka <varname>$koszyk</varname>. 3 przedmioty
    typu "0815" dodawane są do koszyka <varname>$inny_koszyk</varname>.
   </para>
   
   <para>
    I <varname>$koszyk</varname> i <varname>$inny_koszyk</varname> mają
    funkcje dodaj_produkt(), usun_produkt() i zmienne. Są to osobne funkcje i
    zmienne. Obiekty mogą być postrzegane jako katalogi w systemie plików. W
    systemie plików możesz mieć dwa różne pliki
    <filename>README.TXT</filename>, ale tylko jeśli istnieją w osobnych
    katalogach. Aby odczytać plik, będąc w głównym katalogu, musisz podać
    pełną ścieżkę do tego pliku.  Tak samo jest przy obiektach: musisz podać
    pełną nazwę funkcji, z której chcesz skorzystać. W terminologii PHP
    katalogiem głównym będzie globalna przestrzeń nazw a separatorem ścieżki
    będzie -&gt;. W związku z tym nazwy $koszyk i $inny_koszyk zawierają
    zupełnie inne zmienne. Zauważ, że zmienna nazywa się
    <varname>$koszyk-&gt;artykuly</varname>, a nie
    <varname>$koszyk-&gt;$artykuly</varname>, ponieważ nazwa zmiennej może
    zawierać tylko jeden znak dolara.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// poprawnie, jeden $
$koszyk->artykuly = array("10" => 1); 

// niepoprawnie, poniważ $koszyk->$artykuly zamienia się na $koszyk->""
$koszyk->$artykuly = array("10" => 1);

// poprawnie, ale może (ale nie musi) nie być tym, co zamierzaliśmy:
// $koszyk->$zmienna staje się $koszyk->artykuly
$zmienna = 'artykuly';
$koszyk->$zmienna = array("10" => 1);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Wewnątrz definicji klasy, nie wiesz pod jaką nazwą obiekt będzie dostępny
    dla twojego programu: w momencie pisania klasy Koszyk, nie było wiadomo,
    czy obiekty będą się nazywać <varname>$koszyk</varname>,
    <varname>$inny_koszyk</varname>, lub inaczej. W związku z tym nie możesz napisać
    <varname>$koszyk-&gt;artykuly</varname> wewnątrz klasy Koszyk. Zamiast
    tego, aby uzyskać dostęp do funkcji i zmiennych zawartych w klasie, można
    użyć pseudo-zmiennej $this, która może być odczytana jako 'moje własne'
    lub 'bieżący obiekt'. A więc
    '<varname>$this-&gt;artykuly[$nrart]</varname> +=
    <varname>$liczba</varname>' może być odczytane jako 'dodaj
    <varname>$liczba</varname> do licznika <varname>$nrart</varname> z mojej
    własnej tablicy artykuly' lub 'dodaj <varname>$liczba</varname> do
    licznika <varname>$nrartz</varname> tablicy artykuly zawartej w bieżącym
    obiekcie'.
   </para>
   <!-- TODO -->
   <note>
    <para>
     The <varname>$this</varname> pseudo-variable is not usually defined if
     the method in which it is hosted is called statically. This is not,
     however, a strict rule: <varname>$this</varname> is defined if a method is
     called statically from within another object. In this case, the value of
     <varname>$this</varname> is that of the calling object. This is
     illustrated in the following example:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this is defined (';
            echo get_class($this);
            echo ")\n";
        } else {
            echo "\$this is not defined.\n";
        }
    }
}

class B
{
    function bar()
    {
        A::foo();
    }
}

$a = new A();
$a->foo();
A::foo();
$b = new B();
$b->bar();
B::bar();
?>
]]>     
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
$this is defined (a)
$this is not defined.
$this is defined (b)
$this is not defined.
]]>
      </screen>
     </informalexample>
    </para>
   </note>

   <note>
    <para>
     Istnieje kilka przyjemnych funkcji do obsługi klas i obiektów. Możesz je
     zobaczyć w rozdziale <link linkend="ref.classobj">Funkcje obsługi klas i
      obiektów</link>.
    </para>
   </note>
  </sect1>
  
  <sect1 xml:id="keyword.extends">
   <title><literal>extends</literal></title>

   <para>
    Bardzo często zachodzi potrzeba stworzenia klasy o funkcjach i zmiennych
    podobnych do już istniejącej klasy. Zasadniczo dobrze jest stworzyć
    szablonową klasę, która może być użyta we wszystkich twoich projektach i
    przystosowywać ją do specyficznych potrzeb twojego projektu. Aby ułatwić
    ten proces, klasy mogą być rozszerzeniami innych klas. Rozszerzone, lub
    mówiąc inaczej 'dziedziczone', klasy mają wszystkie zmienne i funkcje
    klasy podstawowej (nazywa się to dziedziczeniem, mimo że nikt nie
    umarł) oraz to co do niej dodałeś w definicji rozszerzenia. Nie można
    odjąć pewnych rzeczy z klasy podstawowej, czyli oddefiniować istniejących
    w klasie podstawowej funkcji i zmiennych. Rozszerzona klasa jest zawsze
    zależna od jednej klasy bazowej - dziedziczenie wielokrotne nie jest
    obsługiwane. Klasy można rozszerzyć używając słowa kluczowego 'extends'.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Nazwany_Koszyk extends Koszyk {
    var $wlasciciel;
  
    function ustaw_wlasciciela ($nazwa) {
        $this->wlasciciel = $nazwa;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Definiuje to klasę Nazwany_Koszyk, który ma wszystkie zmienne i funkcje
    klasy Koszyk plus dodatkowa zmienna <varname>$wlasciciel</varname> i
    dodatkowa funkcja ustaw_wlasciciela(). Nazwany koszyk tworzy się normalnym
    sposobem.  Możesz teraz ustawiać i pobierać nazwę właściciela koszyka.
    Cały czas możesz używać zwykłych funkcji koszyka dla nazwanego koszyka:
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$nkoszyk = new Nazwany_Koszyk;        // Stwórz nazwany koszyk
$nkoszyk->ustaw_wlasciciela("kris");  // Nazwij koszyk
print $nkoszyk->wlasciciel;           // Wyświetl właściciela koszyka
$nkoszyk->dodaj_przedmiot("10", 1);   // (funkcjonalność odziedziczona z
                                      // koszyka)
?>
]]>
    </programlisting>
   </informalexample>
   <para>
    Taka relacja nazywana jest często relacją "rodzic-potomek". Tworzysz
    klasę - rodzica - i używasz <literal>extends</literal> aby stworzyć klasę
    <emphasis>opartą</emphasis> o klasę rodzica: klasę potomną. Możesz także
    tworzyć nowe klasy potomne oparte o tą klasę potomną.
   </para>
   <note>
    <para>
     Klasy musza być zdefiniowane zanim zostaną użyte! Jeśli chcesz, aby klasa
     <literal>Nazwany_Koszyk</literal> rozszerzała klasę
     <literal>Koszyk</literal>, musisz zdefiniować klasę
     <literal>Koszyk</literal> jako pierwszą. Jeśli chcesz stworzyć kolejną
     klasę nazwaną <literal>Niebieski_Nazwany_Koszyk</literal> opartą o
     klasę <literal>Nazwany_Koszyk</literal>, musisz najpierw zdefiniować
     klasę <literal>Nazwany_Koszyk</literal>. W skrócie: kolejność, w jakiej
     klasy są definiowane, jest bardzo ważna.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="language.oop.constructor">
   <title>Konstruktory</title>

   <para>
    Konstruktory są funkcjami klasy, które są automatycznie wywoływane przy
    tworzeniu nowej instancji klasy korzystając z operatora
    <literal>new</literal>. Funkcja staje się konstruktorem kiedy ma
    taką samą nazwę jak klasa. Jeśli klasa nie ma konstruktora, użyty zostanie
    konstruktor klasy nadrzędnej, jeśli taka istnieje.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Auto_Koszyk extends Koszyk {
    function Auto_Koszyk()
    {
        $this->dodaj_artykul ("10", 1);
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Ten kod definiuję klasę Auto_Koszyk, który jest klasą Koszyk pluc
    konstruktor, który inicjalizuje wózek z jednym artykułem "10" za każdym
    razem, kiedy Auto_Koszyk jest tworzony operatorem "new". Konstruktory mogą
    pobierać argumenty i te argumenty mogą być opcjonalne, przez co są jeszcze
    bardziej użyteczne. Aby w dalszym ciągu móc używać klasy bez parametrów,
    wszystkie parametry konstruktora powinny stać się opcjonalne przez dodanie
    domyślnych wartości.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Kontruktor_Koszyk extends Koszyk {
    function Konstruktor_Koszyk($artykul = "10", $ilosc = 1)
    {
        $this->dodaj_artykul ($artykul, $ilosc);
    }
}
 
// Kup te same nudne rzeczy...
$zwykly_koszyk = new Konstruktor_Koszyk;
 
// Czas na prawdziwe zakupy...
$inny_koszyk = new Konstruktor_Koszyk("20", 17);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Możesz także użyć operatora <literal>@</literal> aby
    <emphasis>wyciszyć</emphasis> błędy zachodzące w konstruktorze, np.
    <literal>@new</literal>
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function A()
    {
        echo "Jestem konstruktorem klasy A.<br />\n";
    }

    function B()
    {
        echo "Jestem zwykłą funkcją o nazwie B w klasie A.<br />\n";
        echo "Nie jestem konstruktorem w klasie A.<br />\n";
    }
}

class B extends A
{
}

// Wywoła to B() jako konstruktor.
$b = new B;
?>
]]>
    </programlisting>
   </informalexample>
   
   <para>
    Funkcja B() z klasy A niespodziewanie stanie się konstruktorem w
    klasie B, pomimo że wcale nie miała nim być.  PHP 4 nie
    obchodzi czy funkcja została zdefiniowana w klasie B czy została
    odziedziczona.
   </para>
   
   <caution>
    <simpara>
     PHP 4 nie wywołuje automatycznie konstruktora klasy bazowej z
     kontruktora klasy pochodnej. Twoim zadaniem jest propagacja wywołań
     konstruktorów klas nadrzędnych, jeśli to konieczne.
    </simpara>
   </caution>
   
   <para>
    Destruktory są funkcjami, które są wywoływanie automatycznie kiedy obiekty
    są niszczone albo przez użycie <function>unset</function> albo przez
    wyjście z zasięgu. W PHP nie ma destruktorów. Można jednak użyć funkcji
    <function>register_shutdown_function</function> aby symulować działanie
    destruktorów.
   </para>
  </sect1>

 <sect1 xml:id="keyword.paamayim-nekudotayim"><!-- :-) -->
   <title>Operator rozróżnienia zasięgu (<literal>::</literal>)</title>

   <caution>
    <simpara>
     Poniższe dotyczy tylko PHP 4 i nowszych.
    </simpara>
   </caution>

   <para>
    Czasami dobrze jest odnosić się do funkcji i zmiennych w klasie bazowej
    lub odnosić się do funkcji i klas które nie mają jeszcze instancji. Służy
    do tego operator ::.
   </para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A {
    function przyklad() {
        echo "Jestem orginalną funkcją A::przyklad().<br />\n";
    }
}

class B extends A {
    function przyklad() {
        echo "Jestem przedefiniowaną funkcją B::przyklad().<br />\n";
        A::przyklad();
    }
}

// nie ma obiektu klasy A.
// poniższe wyświetli
//   Jestem orginalną funkcją A::przyklad().<br />
A::przyklad();

// stwórz nowy obiekt klasy B.
$b = new B;

// poniższe wyświetli
//   Jestem przedefiniowaną funkcją B::przyklad().<br />
//   Jestem orginalną funkcją A::przyklad().<br />
$b->przyklad();
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Powyższy przekład wywołuje funkcję przyklad() z klasy A, ale nie tworząc
    obiektu tej klasy, przez co nie możemy napisać nic w stylu $a->przyklad().
    Zamiast tego możemy wywołać przyklad() jako 'funkcję klasy', czyli jako
    funkcję tylko klasy, nie żadnego obiektu tej klasy.
   </para>
   
   <para>
    Istnieją funkcje klasy, ale nie ma zmiennych klasy. Faktycznie w czasie
    wykonania nie ma żadnego obiektu. W związku z tym funkcje klasy nie mogą
    używać żadnych zmiennych obiektu (ale mogą używać zmiennych lokalnych i
    globalnych), ani w ogóle <varname>$this</varname>.
   </para>

   <para>
    W powyższym przykładzie, klasa B przedefiniowuje funkcję przyklad().
    Orginalna definicja z klasy A jest zasłonięta i niedostępna, chyba że
    odwołasz się do konkretnej implementacji poprzez operator ::. Aby to
    zrobić, napisz A::przyklad() (powinieneś jednak użyć parent::przyklad(),
    tak jak to pokazano w następnej części).
   </para>
   
   <para>
    W tym kontekście, istnieje bieżący obiekt i który ma zmienne obiektu. W
    związu z tym jeśli funkcja jest użyta Z WEWNĄTRZ funkcji obiektu, możesz
    używać <varname>$this</varname> i zmiennych obiektu.
   </para>

 </sect1>

 <sect1 xml:id="keyword.parent">
   <title><literal>parent</literal></title>

  <para>
   Może się zdarzyć, że będziesz pisał kod, który odnosi się do funkcji i
   zmiennych klasy bazowej. Jest to możliwe jeśli twoja klasa pochodna jest
   uściśleniem lub specjalizacją klasy bazowej.
  </para>
  
  <para>
   Zamiast jawnego podawania nazwy klasy bazowej w kodzie, powinieneś użyć
   specjalnej nazwy <literal>parent</literal>, która odnosi się do nazwy klasy
   bazowej podanej przy <literal>extends</literal> podczas deklaracji twojej
   klasy. Robiąc to, unikasz użycia nazwy klasy bazowej w więcej niż jednym
   miejscu. Jeśli twoje drzewo dziedziczenia zmieniłoby się podczas
   implementacji, zmiana będzie wymagała poprawki tylko w jednym miejscu -
   przy słowie kluczowym <literal>extends</literal> w deklaracji klasy.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class A {
    function przyklad() {
        echo "Jestem A::przyklad() I dostarczam podstawową funkcjonalność.<br />\n";
    }
}

class B extends A {
    function przyklad() {
        echo "Jestem B::przyklad() i dostarczam dodatkową funkcjonalność.<br />\n";
        parent::przyklad();
    }
}

$b = new B;

// Wywoła to B::przyklad(), który z kolei wywoła A::przyklad().
$b->przyklad();
?>
]]>
   </programlisting>
  </informalexample>
 </sect1>

 <sect1 xml:id="language.oop.serialization">
  <title>Serializacja obiektów - obiekty w sesjach</title>

  <para>
   <function>serialize</function> zwraca string będący reprezentacją dowolnej
   wartości, która może być przechowywana przez PHP.
   <function>unserialize</function> może użyć tego stringu aby odtworzyć
   orginalne wartości zmiennej. Użycie serializacji do zapisania obiektu
   zachowa wszystkie zmienne z obiektu. Zapisane nie będą funkcje z obiektu, a
   jedynie nazwa klasy.
  </para>
  
  <para>
   Aby istniała możliwość użycia funkcji <function>unserialize</function> do
   odzyskania obiektu, musi być zdefiniowana klasa tego obiektu. Oznacza to,
   że jeśli obiekt <varname>$a</varname> klasy A istnieje na page1.php i
   zostanie on zserializowany, otrzymany zostanie ciąg znakowy, który odnosi
   się do klasy A i zawiera wartości wszystkich zmiennych zawartych w
   <varname>$a</varname>. Aby istniała możliwość deserializacji tego obiektu
   na page2.php, na page2.php musi istnieć definicja klasy A. Można to zrobić
   na przykład przez przechowywanie definicji klasy A w zewnętrznym pliku
   dołączanym przez page1.php i page2.php.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// classa.inc:
  class A {
      var $jeden = 1;
    
      function pokaz_jeden() {
          echo $this->jeden;
      }
  }
  
// page1.php:

  include("classa.inc");
  
  $a = new A;
  $s = serialize($a);
  // przechowaj $s gdzieś, gdzie page2.php będzie mogła go znaleźć
  $fp = fopen("store", "w");
  fwrite($fp, $s);
  fclose($fp);

// page2.php:

  // to jest niezbędne aby funkcja unserialize działała prawidłowo.
  include("classa.inc");

  $s = implode("", @file("store"));
  $a = unserialize($s);

  // teraz użyj funkcji pokaz_jeden z obiektu $a.
  $a->pokaz_jeden();
?>
]]>
   </programlisting>
  </informalexample>
  
  <para>
   Jeśli używasz sesji i <function>session_register</function> do rejestracji
   obiektów, te obiekty są serializowane automatycznie na końcu każdej strony
   PHP i odserializowane automatycznie na każdej z następnych stron.
   Zasadniczo znaczy to, że te obiekty mogą pokazać się na dowolnej z twoich
   stron jeśli tylko staną się częścią twojej sesji.
  </para>
  
  <para>
   Mocno zalecane jest includowanie definicji klas wszystkich zarejestrowanych
   obiektów na wszystkich twoich stronach, nawet jeśli nie używasz tych
   zmiennych na twoich stronach. Jeśli tego nie zrobisz a obiekty zostaną
   odserializowane bez definicji klasy, powiązania klasowe zostaną utracone a
   obiek stanie się obiektem klasy <literal>stdClass</literal> bez żadnych
   dostępnych funkcji, a więc będzie całkiem bezużyteczny.
  </para>
  
  <para>
   A więc jeśli w powyższym przykładzie <varname>$a</varname> stanie się
   częścią sesji przez wywołanie <literal>session_register("a")</literal>,
   powinieneć includować plik <literal>classa.inc</literal> na wszystkich
   stronach, nie tylko page1.php i page2.php.
  </para>
 </sect1>

 <sect1 xml:id="language.oop.magic-functions">
  <title>Magiczne funkcje <literal>__sleep</literal> i <literal>__wakeup</literal></title>

  <para>
   <function>serialize</function> sprawdza, czy twoja klasa zawiera funkcję o
   magicznej nazwie <literal>__sleep</literal>. Jeśli tak, ta funkcja jest
   wywoływana przed każdą serializacją. Może ona czyścić obiekt i powinna
   zwracać tablicę z nazwami wszystkich zmiennych obiektu, które powinny być
   serializowane. Jeśli metoda nie zwraca żadnej wartości, serializowana jest
   wartość &null; i wystosowywane jest ostrzeżenie klasy E_NOTICE.
  </para>
  
  <para>
   Założonym użyciem <literal>__sleep</literal> jest zatwierdzenie
   wszystkich oczekujących danych lub wykonanie innych podobnych czynności
   czyszczących. Funkcja ta jest także przydatna jeśli masz bardzo duże
   obiekty, które nie muszą być zachowane w całości.
  </para>
  
  <para>
   Analogicznie, <function>unserialize</function> sprawdza czy istnieje
   funkcja o magicznej nazwie <literal>__wakeup</literal>. Jeśli tak, funkcja
   może rekonstruować dowolne zasoby które obiekt może posiadać.
  </para>
  
  <para>
    Założonym użyciem <literal>__wakeup</literal> jest odnowienie połączeń z
    bazami danych, które mogły zostac utracone w procesie serializacji, oraz
    wykonanie innych czynności odbudowujących obiekt.
  </para>
 </sect1>
  
 <sect1 xml:id="language.oop.newref">
   <title>Referencje wewnątrz konstruktora</title>
   <para>
    Tworzenie referencji wewnątrz konstruktora może prowadzić do dziwnych
    efektów. Ten rozdział ma pomóc w unikaniu takich problemów.
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Foo {
    function Foo($nazwa) {
        // stworz referencje wewnatrz globalnej tablicy $globalref
        global $globalref;
        $globalref[] = &$this;
        // ustaw nazwę na przekazaną wartość
        $this->ustawNazwe($nazwa);
        // i wyświetl ją
        $this->wyswietlNazwe();
    }

    function wyswietlNazwe() {
        echo "<br />",$this->nazwa;
    }
	
    function ustawNazwe($nazwa) {
        $this->nazwa = $nazwa;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
    
   <para>
    Sprawdźmy, czy jest jakaś różnica pomiędzy
    <varname>$bar1</varname>, który jest tworzony przy pomocy operatora
    przypisania <literal>=</literal>, a <varname>$bar2</varname>, który został
    stworzony używając operatora referencji <literal>=&amp;</literal>...

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bar1 = new Foo('ustawione w konstruktorze');
$bar1->wyswietlNazwe();
$globalref[0]->wyswietlNazwe();

/* wyjście:
ustawione w konstruktorze
ustawione w konstruktorze
ustawione w konstruktorze */

$bar2 =& new Foo('ustawione w konstruktorze');
$bar2->wyswietlNazwe();
$globalref[1]->wyswietlNazwe();

/* wyjście:
ustawione w konstruktorze
ustawione w konstruktorze
ustawione w konstruktorze */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Wydaje się, że nie ma żadnej różnicy, ale na prawdę jest jedna, i to
    bardzo istotna: <varname>$bar1</varname> i
    <varname>$globalref[0]</varname> <emphasis>NIE</emphasis> są referencjami,
    <emphasis>NIE</emphasis> są tą samą zmienna. Dzieje się tak, ponieważ
    "new" nie zwraca domyślnie referencji, ale kopię.
    <note>
     <simpara>
      Zwracanie kopii zamiast referencji nie powoduje utraty wydajności (od
      PHP 4 używane jest zliczanie referencji). Jednakże zazwyczaj lepiej jest
      pracować poprostu z kopiami zamiast referencji, poniewać tworzenie
      referencji zabiera trochę czasu, podczas gdy tworzenie kopii obiektów
      teoretycznie w ogóle nie zabiera czasu (chyba że któraś z tych zmiennych
      jest dużą tablicą lub obiektem i jedno z nich ulega zmianie, po czym tej
      samej zmianie ulegają pozostałe zmienne; wtedy lepiej jest użyć
      referencji do zmieniania ich równolegle).
     </simpara>
    </note>
    Aby udowodnić to, co zostało zapisane powyżej, przyjrzyjmy się poniższemu
    programowi.

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// teraz zmienimy nazwę. czego się spodziewasz?
// możesz się spodziewać, że i $bar1 i $globalref[0] zmienią swoje nazwy...
$bar1->ustawNazwe('ustawiona z zewnątrz');

// jak napisano powyżej, nic takiego się nie stanie
$bar1->wyswietlNazwe();
$globalref[0]->wyswietlNazwe();

/* wyjście:
ustawiona z zewnątrz
ustawiona w konstruktorze */

// zobaczmy co się dzieje z $bar2 i $globalref[1]
$bar2->ustawNazwe('ustawiona z zewnątrz');

// na szczęście ta zmienna nie zachowuje się jak ta z poprzedniego przypadku
// są to te same zmienne, z więc $bar2->nazwa i $globalref[1]->nazwa są także
// tymi samymi zmiennymi
$bar2->wyswietlNazwe();
$globalref[1]->wyswietlNazwe();

/* wyjście:
ustawiona z zewnątrz
ustawiona z zewnątrz */
?>
]]>
     </programlisting>
    </informalexample>   
   </para>   
   <para>
   Ustatni przykład. Postaraj się go zrozumieć/
   
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class A {
    function A($i) {
        $this->wartosc = $i;
        // domyśl się dlaczego nie potrzebujemy tutaj referencji
        $this->b = new B($this);
    }

    function stworzRef() {
        $this->c = new B($this);
    }

    function wyswietlWartosc() {
        echo "<br />","klasa ",get_class($this),': ',$this->value;
    }
}


class B {
    function B(&$a) {
        $this->a = &$a;
    }

    function wyswietlWartosc() {
        echo "<br />","klasa ",get_class($this),': ',$this->a->value;
    }
}
// spróbuj zrozumieć dlaczego użycie tu prostego kopiowania może powodować
// nieporządany efekt w linii uznaczonej znaczkiem '*'
$a =& new A(10);
$a->stworzRef();

$a->wyswietlWartosc();
$a->b->wyswietlWartosc();
$a->c->wyswietlWartosc();

$a->value = 11;

$a->wyswietlWartosc();
$a->b->wyswietlWartosc(); // *
$a->c->wyswietlWartosc();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
klasa A: 10
klasa B: 10
klasa B: 10
klasa A: 11
klasa B: 11
klasa B: 11
]]>
     </screen>
    </informalexample>
   </para>
  </sect1>
  <sect1 xml:id="language.oop.object-comparison">
   <title>Porównywanie obiektów</title>
   <para>
    W PHP 4 obiekty są porównywane w bardzo prosty sposób, to znaczy dwie
    instancje obiektów są uważane za równe, jeśli posiadają te same atrybuty i
    ich wartości, a także są instancjami tej samej klasy. Podobne reguły są
    stosowane, jeśli dwa obiekty są porównywane za pomocą operatora
    identyczności (<literal>===</literal>).
  </para>
  <para>
   <example>
    <title>Przykład porównania obiektów w PHP 4</title>
    <programlisting role="php">
<![CDATA[
<?php
function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function porownajObiekty(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flaga {
    var $flag;

    function Flaga($flag=true) {
            $this->flag = $flag;
    }
}

class przelaczalanaFlaga extends Flaga {

    function turnOn() {
        $this->flag = true;
    }

    function turnOff() {
        $this->flag = false;
    }
}

$o = new Flaga();
$p = new Flaga(false);
$q = new Flaga();

$r = new przelaczalnaFlaga();

echo "Porównaj instancje stworzone z tymi samymi argumentami\n";
porownajObiekty($o, $q);

echo "\nPorównaj instancje stworzone z różnymi argumentami\n";
porownajObiekty($o, $p);

echo "\nPorównaj instancję klasy nadrzędnej z instancją klasy podrzędnej\n";
porownajObiekty($o, $r);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[    
Porównaj instancje stworzone z tymi samymi argumentami
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Porównaj instancje stworzone z różnymi argumentami
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Porównaj instancję klasy nadrzędnej z instancją klasy podrzędnej
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
    </screen>
   </example>   
  </para>
  <para>
   Wynik działania powyższego skryptu jest całkowicie przewidywalny na
   podstawie przedstawionych wyżej reguł. Tylko instancje o tych samych
   wartościach tych samych atrybutów, pochodzące z tej samej klasy, są
   uznawane za równe i identyczne.
  </para>
  <para>
   Nawet w przypadku kompozycji obiektów stosowane są te same reguły
   porównywania. W poniższym przykładzie stworzona została klasa-pojemnik,
   która zawiera tablicę asocjacyjną obiektów klasy
   <classname>Flaga</classname>.
   <example>
    <title>Porównywanie obiektów złożonych w PHP 4</title>
    <programlisting role="php">
<![CDATA[
<?php
class ZbiorFlag {
    var $set;

    function ZbiorFlag($flagArr = array()) {
        $this->set = $flagArr;
    }

    function addFlag($name, $flag) {
        $this->set[$name] = $flag;
    }

    function removeFlag($name) {
        if (array_key_exists($name, $this->set)) {
            unset($this->set[$name]);
        }
    }
}


$u = new ZbiorFlag();
$u->addFlag('flag1', $o);
$u->addFlag('flag2', $p);
$v = new ZbiorFlag(array('flag1'=>$q, 'flag2'=>$p));
$w = new ZbiorFlag(array('flag1'=>$q));

echo "\nObiekty złożone u(o,p) i v(q,p)\n";
porownajObiekty($u, $v);

echo "\nu(o,p) i w(q)\n";
porownajObiekty($u, $w);
?>     
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Obiekty złożone u(o,p) i v(q,p)
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

u(o,p) i w(q)
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
    </screen>
   </example>
  </para>
 </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
