<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: 1.33 Maintainer: Qrak Status: ready -->
<!-- $Revision: 1.12 $ -->
 <chapter id="language.operators">
  <title>Operatory</title>
  <simpara>
  </simpara>
  
  <sect1 id="language.operators.precedence">
   <title>Priorytety operatorów</title>
   <para>
    Priorytet operatora okre¶la, jak "silnie" operator wi±¿e ze sob± dwa stoj±ce
    obok niego wyra¿enia. Na przyk³ad, w wyra¿eniu <literal>1 +
    5 * 3</literal>, wynik wynosi <literal>16</literal>, nie
    <literal>18</literal> poniewa¿ operator mno¿enia ("*") ma wy¿szy priorytet 
    ni¿ operator dodawania ("+"). Za pomoc± nawiasów mo¿na zmieniaæ priorytet 
    dzia³añ wed³ug regu³ arytmetyki. Na przyk³ad: <literal>(1 + 5) * 3</literal>
    jest równe <literal>18</literal>.
   </para>
   <para>
    Poni¿sza tabela zawiera priorytet operatorów, od najni¿szego priorytetu na 
    górze.
    <table>
     <title>Priorytety operatorów</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Powi±zanie</entry>
        <entry>Operator</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>lewe</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>lewe</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>lewe</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>lewe</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>prawe</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>lewe</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= ~= &lt;&lt;= &gt;&gt;=
        </entry>
       </row>
       <row>
        <entry>lewe</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>lewe</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>lewe</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>lewe</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>lewe</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>lewe</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>bez powi±zania</entry>
        <entry>== != === !==</entry>
       </row>
       <row>
        <entry>bez powi±zania</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>lewe</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>lewe</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>lewe</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>prawe</entry>
        <entry>! ~ ++ -- (int) (double) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>prawe</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>bez powi±zania</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
  </sect1>

  
  <sect1 id="language.operators.arithmetic">
   <title>Operatory Arytmetyczne</title>
   <simpara>
    Czy pamiêtasz podstawy arytmetyki ze szko³y? Operatory w PHP dzia³aj±
    niemal¿e tak samo.
   </simpara>
   <table>
    <title>Operatory Arytmetyczne</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Przyk³ad</entry>
       <entry>Nazwa</entry>
       <entry>Opis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>Dodawanie</entry>
       <entry>Suma $a i $b.</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>Odejmowanie</entry>
       <entry>Ró¿nica $a od $b.</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>Mno¿enie</entry>
       <entry>Iloczyn $a i $b.</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>Dzielenie</entry>
       <entry>Iloraz $a przez $b.</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>Dzielenie Modulo</entry>
       <entry>Reszta z dzielenia $a przez $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
   <simpara>
    Operator dzielenia ("/") zwraca warto¶æ ca³kowit± (wynikiem dzielenia jest
    liczba ca³kowita) je¶li obydwa operandy s± ca³kowite (lub s± ³añcuchami 
    znaków skonwertowanymi do liczb ca³kowitych) oraz wynik ich dzielenia jest 
    ca³kowity. Je¶li jednak który¶ z operandów jest zmiennoprzecinkowy lub 
    wynikiem dzielenia jest liczba nieca³kowita, operator dzielenia zwraca 
    warto¶æ zmiennoprzecinkow±.
   </simpara>
  </sect1>
  
  <sect1 id="language.operators.assignment">
   <title>Operatory Przypisania</title>
   <simpara>
    Podstawowym operatorem przypisania jest "=". Twoim pierwszym skojarzeniem 
    mo¿e byæ "jest równy". Nie! Tak naprawdê oznacza to, ¿e operand z lewej
    strony operatora "=" otrzymuje warto¶æ wyra¿enia stoj±cego po prawej stronie
    (tak w³a¶nie siê t³umaczy: "otrzymuje warto¶æ wyra¿enia po prawej").
   </simpara>
   <para>
    Warto¶ci± ca³ego wyra¿enia przypisania jest warto¶æ przypisywana do 
    zmiennej stojacej po lewej. Na przyk³ad warto¶ci± "$a = 3" jest 3. To 
    pozwala na wykonywanie bardziej skomplikowanych przypisañ: 
    <informalexample>
     <programlisting role="php">
<![CDATA[      
$a = ($b = 4) + 5; // teraz $a jest równe 9, a $b jest równe 4.
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Poza podstawowym operatorem przypisania, istniej± jeszcze z³o¿one operatory 
    odnosz±ce siê do wszystkich arytmetycznych i ³añcuchowych operatorów. 
    Pozwalaj± one u¿yæ jednej zmiennej jako jednego z operandów, a nastêpnie 
    zapisanaæ wynik dzia³ania w tej w³a¶nie zmiennej. Na przyk³ad:
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = 3;
$a += 5; // ustawia warto¶æ $a na 8, tak jakby napisaæ: $a = $a + 5;
$b = "Witaj ";
$b .= "¦wiecie!"; // ustawia warto¶æ $b na "Witaj ¦wiecie!", dok³adnie tak jak 
$b = $b . "¦wiecie!";
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Zwróæ uwagê, ¿e przypisanie kopiuje warto¶æ oryginalnej zmiennej do nowej
    zmiennej (tzw. przypisanie przez warto¶æ). Skutki tego mog± byæ widoczne
    przy kopiowaniu np. du¿ej tablicy wewn±trz zwartej (ciasnej) pêtli (ang.
    tight loop). PHP 4 pozwala na przypisanie przez
    referencjê (odniesienie), za pomoc± sk³adni <computeroutput>$zmienna =
    &amp;$innaZmienna;</computeroutput>. Taka mo¿liwo¶æ pojawi³a siê dopiero 
    w PHP 4 i nie by³a dostêpna w PHP 3. "Przypisanie przez referencjê" oznacza,
    ¿e obydwie zmienne wskazuj± te same warto¶ci, natomiast nic siê nie
    kopiuje. Aby dowiedzieæ siê wiêcej na temat referencji, przeczytaj rodzia³
    <link linkend="language.references">wyja¶nienie referencji</link>.
   </para>
  </sect1>

  <sect1 id="language.operators.bitwise">
   <title>Operatory Bitowe</title>
   <simpara>
    Operatory bitowe s³u¿± do operowania na warto¶ciach konkretnych bitów w 
    liczbie. Je¶li zarówno lewo jak i prawostronne operandy s± typu string,
    operatory bitowe bêd± wykonywaæ operacje na poszczególnych znakach tych
    ³añcuchów.
   </simpara>
   <para> 
      <informalexample> 
       <programlisting> 
  <![CDATA[ 
  <?php 
      echo 12 ^ 9; // Zwraca '5' 
    
      echo "12" ^ "9"; // Zwraca znak Backspace (ascii 8)
                       // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8 
    
      echo "hallo" ^ "hello"; // Zwraca warto¶ci ascii #0 #4 #0 #0 #0 
                              // 'a' ^ 'e' = #4 
  ?> 
  ]]> 
       </programlisting> 
      </informalexample> 
   </para> 

   <table>
    <title>Operatory Bitowe</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Przyk³ad</entry>
       <entry>Nazwa</entry>
       <entry>Opis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a &amp; $b</entry>
       <entry>Mno¿enie bitowe</entry>
       <entry>Dany bit wynikowy jest równy 1 tylko je¶li obydwa bity sk³adowe 
       s± równe 1.</entry>
      </row>
      <row>
       <entry>$a | $b</entry>
       <entry>Sumowanie bitowe</entry>
       <entry>Dany bit wynikowy jest równy 1 je¶li conajmniej jeden bit 
       sk³adowy jest równy 1.</entry>
      </row>
      <row>
       <entry>$a ^ $b</entry>
       <entry>Sumowanie bitowe modulo 2</entry>
       <entry>Dany bit wynikowy jest równy 1 tylko je¶li jeden z bitów 
       sk³adowych jest równy 1 a drugi jest równy 0.</entry>
      </row>
      <row>
       <entry>~ $a</entry>
       <entry>Negacja bitowa</entry>
       <entry>Bity w zmiennej $a maj±ce warto¶æ 1 otrzymuj± warto¶æ 0 i na 
       odwrót.</entry>
      </row>
      <row>
       <entry>$a &lt;&lt; $b</entry>
       <entry>Przesuniêcie w lewo</entry>
       <entry>
	Przesuwa bity w zmiennej $a o $b kroków w lewo (ka¿dy krok znaczy "pomno¿one
    razy dwa").
       </entry>
      </row>
      <row>
       <entry>$a &gt;&gt; $b</entry>
       <entry>Przesuniêcie w prawo</entry>
       <entry>
	Przesuwa bity w zmiennej $a o $b kroków w prawo (ka¿dy krok znaczy 
    "podzielone przez dwa").
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect1>

  <sect1 id="language.operators.comparison">
   <title>Operatory Porównania</title>
   <simpara>
    Jak wskazuje ich nazwa, operatory te s³u¿± do porównywania dwóch warto¶ci.
   </simpara>
   <table>
    <title>Operaatory Porównania</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Przyk³ad</entry>
       <entry>Nazwa</entry>
       <entry>Opis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>Równy</entry>
       <entry>&true; jesli $a jest równe $b</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>Identyczny</entry>
       <entry>
	&true; je¶li $a jest równe $b, i obydwa operandy s± tego samego typu.
    (tylko w PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>Ró¿ny</entry>
       <entry>&true; je¶li $a nie jest równy $b.</entry>
      </row>
      <row>
       <entry>$a &lt;> $b</entry>
       <entry>Ró¿ny</entry>
       <entry>&true; je¶li $a nie jest równy $b.</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>Nie identyczny</entry>
       <entry>
	&true; je¶li $a nie jest równy $b, lub nie s± tego samego typu. 
    (tylko w PHP 4)
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>Mniejszy ni¿</entry>
       <entry>&true; je¶li $a jest mniejszy od $b.</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>Wiêkszy ni¿</entry>
       <entry>&true; je¶li $a jest wiêkszy od $b.</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>Mniejszy lub równy</entry>
       <entry>&true; je¶li $a jest mniejszy lub równy $b.</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>Wiêkszy lub równy</entry>
       <entry>&true; je¶li $a jest wiêkszy lub równy $b.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Jeszcze jednym operatorem warunkowym jest operator "?:" (tzw. ternariusz),
    dzia³aj±cy tak jak w C i wielu innych jêzykach.
    <informalexample>
     <programlisting>
<![CDATA[
(expr1) ? (expr2) : (expr3);
]]>
     </programlisting>
    </informalexample> 
    Warto¶ci± wyra¿enia jest <replaceable>expr2</replaceable>, je¶li
    <replaceable>expr1</replaceable> jest równe &true;, lub
    <replaceable>expr3</replaceable>, je¶li
    <replaceable>expr1</replaceable> jest równe &false;.
   </para>
  </sect1>

  <sect1 id="language.operators.errorcontrol">
   <title>Operatory Kontroli B³êdów</title>
   <simpara>
    PHP obs³uguje obecnie jeden operator kontroli b³êdów: znak ma³py (@). Je¶li
    znak ten zostanie postawiony przed dowolnym wyra¿eniem w PHP, jakiekolwiek 
    powiadomienia o b³êdach wygenerowane przez to wyra¿enie zostan± pominiête 
    (nie bêd± wy¶wietlone). 
   </simpara>
   <simpara>
    Je¶li mechanizm <link linkend="ini.track-errors">track_errors</link>
    zosta³ w³±czony, jakiekolwiek powiadomienie o b³êdzie zostanie zapisane do 
    zmiennej globalnej $php_errormsg. Nale¿y jednak pamiêtaæ, ¿e zawarto¶æ tej 
    zmiennej jest nadpisywana przy ka¿dym b³êdzie, wiêc po wyst±pieniu kolejnego
    b³êdu w skrypcie, informacja o poprzednim b³êdzie jest tracona.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Zamierzony b³±d obs³ugi pliku */
$my_file = @file ('non_existent_file') or
    die ("Failed opening file: error was '$php_errormsg'");

// mechanizm ten dzia³a dla wszystkich wyra¿eñ, nie tylko dla funkcji:
$value = @$cache[$key]; 
// spowoduje niewy¶wietlenie powiadomienia, je¶li nie istnieje wpis do tablicy o
indeksie $key.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     Operator @ dzia³a tylko na wyra¿eniach. T³umacz±c to ³opatologicznie: je¶li
     da siê pobraæ warto¶æ czego¶, mo¿na postawiæ operator @ przed tym czym¶. 
     Zgodnie z powy¿sz± regu³±, mo¿na postawiæ @ przed zmiennymi, wywo³aniami 
     funkcji, instrukcjami <function>include</function>, sta³ymi, itp. Nie mo¿na
     stawiaæ @ przed definicjami funkcji b±d¼ klasy, lub strukturami
     warunkowymi, takimi jak <literal>if</literal> lub
     <literal>foreach</literal>, itd.
    </simpara>
   </note>
   <simpara>
    Zobacz tak¿e <function>error_reporting</function>.
   </simpara>
   <warning>
    <para>
     Obecnie operator kontroli b³êdów "@" wy³±czy wy¶wietlanie powiadomienia 
     o b³êdzie nawet dla b³êdów krytycznych, które przerw± wykonywanie skryptu.
     Oznacza to, ¿e je¶li u¿yjesz tego operatora przed wywo³aniem funkcji, która
     jest nieosi±galna lub ma literówkê w nazwie, skrypt przerwie pracê 
     nie powiadamiaj±c dlaczego.
    </para>
   </warning>
  </sect1>
  
  <sect1 id="language.operators.execution">
   <title>Operatory Wykonania Polecenia Systemowego</title>
   <para>
    PHP posiada jeden operator wykoania polecenia systemowego: apostrof wsteczny
    (``). Zauwa¿ ¿e jest to co¶ innego ni¿ apostrof zwyk³y! Zawarto¶æ apostrofu
    wstecznego zostanie wykonana jako polecenie systemowe. Wynik polecenia 
    zostanie zwrócony (tzn. nie bêdzie wys³any do przegl±darki tylko bêdzie 
    dostêpny do przypisania do zmiennej).
    <informalexample>
     <programlisting role="php">
<![CDATA[
$output = `ls -al`;
echo "<pre>$output</pre>";
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     Operator ten nie dzia³a kiedy <link
     linkend="ini.safe-mode">safe mode</link> jest w³±czony, lub 
     <function>shell_exec</function> jest zablokowana.
    </para>
   </note>
   <para>
    Zobacz te¿ <function>escapeshellcmd</function>, <function>exec</function>,
    <function>passthru</function>, <function>popen</function>,
    <function>shell_exec</function> i <function>system</function>.
   </para>
  </sect1>

  <sect1 id="language.operators.increment">
   <title>Operatory Inkrementacji i Dekrementacji</title>
   <para>
    PHP obs³uguje te operatory w stylu jêzyka C.
   </para>
   <table>
    <title>Operatory Inkrementacji i Dekrementacji</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Przyk³ad</entry>
       <entry>Nazwa</entry>
       <entry>Opis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>Pre-inkrementacja</entry>
       <entry>Najpierw zwiêksza warto¶æ $a o jeden, potem zwraca $a.</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>Post-inkrementacja</entry>
       <entry>Najpierw zwraca $a, potem zwiêksza $a o jeden.</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>Pre-dekrementacja</entry>
       <entry>Najpierw zmniejsza warto¶æ $a o jeden, potem zwraca $a.</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>Post-dekrementacja</entry>
       <entry>Najpierw zwraca $a, potem zmniejsza $a o jeden.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Prosty skrypt przyk³adowy:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3&gt;Post-inkrementacja</h3&gt;";
$a = 5;
echo "Powinno byæ 5: " . $a++ . "<br>\n";
echo "Powinno byæ 6: " . $a . "<br>\n";

echo "<h3>Pre-inkrementacja</h3>";
$a = 5;
echo "Powinno byæ 6: " . ++$a . "<br>\n";
echo "Powinno byæ 6: " . $a . "<br>\n";

echo "<h3>Post-dekrementacja</h3>";
$a = 5;
echo "Powinno byæ 5: " . $a-- . "<br>\n";
echo "Powinno byæ 4: " . $a . "<br>\n";

echo "<h3>Pre-dekrementacja</h3>";
$a = 5;
echo "Powinno byæ 4: " . --$a . "<br>\n";
echo "Powinno byæ 4: " . $a . "<br>\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.operators.logical">
   <title>Operatory Logiczne</title>

   <table>
    <title>Opearotory Logiczne</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Przyk³ad</entry>
       <entry>Nazwa</entry>
       <entry>Opis</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>I</entry>
       <entry>&true; je¶li zarówno $a jak i $b s± &true;.</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Lub</entry>
       <entry>&true; je¶li $a lub $b jest &true;.</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Wy³acznie-Lub</entry>
       <entry>&true; je¶li $a lub $b jest &true;, ale nie jednocze¶nie.</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Nie</entry>
       <entry>&true; je¶li $a nie jest &true;.</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>I</entry>
       <entry>&true; je¶li zarówno $a jak i $b s± &true;.</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Lub</entry>
       <entry>&true; je¶li $a lub $b jest &true;.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Operatory "or" i "and" maj± inny priorytet ni¿ "||" i "&amp;&amp;" i w³a¶nie
    z tego powodu w PHP s± dwa ró¿ne operatory dla "lub" i "i". (Zobacz
    <link linkend="language.operators.precedence">Priorytety Operatorów</link>.)
   </simpara>
  </sect1>

  
  <sect1 id="language.operators.string">
   <title>Operatory £añcuchowe</title>
   <simpara>
    W PHP s± dwa operatory operuj±ce na ³añcuchach znaków (stringach). Pierwszym
    z nich jest operator konkatenacji (po³±czenia) ('.'), który zwraca ³añcuch 
    bêd±cy po³±czeniem zawarto¶ci lewego i prawego operandu. Drugim z nich jest
    operator przypisania konkatenacyjnego ('.='), który do³±cza zawarto¶æ 
    wyra¿enia stojacego z prawej strony do zmiennej stojacej z lewej strony. 
    Zobacz tak¿e <link
    linkend="language.operators.assignment">Operatory Przypisania</link>.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = "Witaj ";
$b = $a . "¦wiecie!"; // teraz $b zawiera ci±g "Witaj ¦wiecie!"

$a = "Witaj ";
$a .= "¦wiecie!";     // teraz $a zawiera ci±g "Witaj ¦wiecie!"
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
