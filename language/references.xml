<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: 1.27 Maintainer: dombal Status: ready -->
<!-- $Revision: 1.3 $ -->
 <chapter xml:id="language.references" xmlns="http://docbook.org/ns/docbook">
  <title>Referencje</title>

  <sect1 xml:id="language.references.whatare">
   <title>Czym s± referencje</title>
   <simpara>  
    W PHP referencje s± ¶rodkiem dostêpu do tej samej warto¶ci zmiennej
    poprzez ró¿ne nazwy. Nie dzia³aj± na takiej zasadzie jak wska¼niki w C,
    lecz s± aliasami w tablicy symboli. Zwróc uwagê na to, ¿e w PHP nazwa
    zmiennej oraz warto¶æ zmiennej s± dwiema ró¿nymi rzeczami, wobec tego ta
    sama warto¶æ mo¿e byæ dostêpna poprzez ró¿ne nazwy. Najbli¿sz± analogi±
    jest Uniksowy system plików i ich nazw - nazwy zmiennych to wpisy
    katalogowe, a warto¶ci to same pliki. Mo¿na my¶leæ o referencjach jak o
    twardych dowi±zaniach w Uniksowym systemie plików.
   </simpara>
  </sect1>

  <sect1 xml:id="language.references.whatdo">
   <title>Co robi± referencje</title>
   <para>
    W PHP referencje pozwalaj± na stworzenie dwu zmiennych zawieraj±cych t±
    sam± zawarto¶æ. Wiêc poni¿szy skrypt:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a =& $b 
?>
]]>
     </programlisting>
    </informalexample>
    znaczy tyle, ¿e <varname>$a</varname> oraz <varname>$b</varname>
    wskazuj± na t± sam± zmienn±.
    <note>
     <para>
      <varname>$a</varname> oraz <varname>$b</varname> s± ca³kowicie równe,
      czyli nie <varname>$a</varname> wskazuje na <varname>$b</varname> lub
      odwrotnie, lecz <varname>$a</varname> oraz <varname>$b</varname>
      wskazuj± na to samo miejsce.
     </para>
    </note>
   </para>
   <para>
    Ta sama sk³adnia mo¿e byæ u¿ywana z funkcjami zwracaj±cymi referencje, i z
    operatorem <literal>new</literal> (w PHP 4.0.4 i pó¼niejszych):
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bar =& new foo_klasa();
$foo =& znajdx_zmienna($bar);
?>
]]>
    </programlisting>
    </informalexample>
    </para>
    <note>
     <para>
      Brak operatora <literal>&amp;</literal> powoduje powstanie kopii
      obiektu. Je¿eli u¿yjesz <literal>$this</literal> wewn±trz klasy, zmienna
      ta bêdzie pracowaæ na bie¿±cym egzemplarzu danej klasy. Dowi±zanie bez
      u¿ycia <literal>&amp;</literal> spowoduje powstanie kopii egzemplarza
      danej klasy (czyli naszego obiektu) i <literal>$this</literal> bêdzie
      pracowaæ na kopii, co nie jest zwykle tym czego by¶my chcieli. Zwykle
      po¿±dane jest posiadanie tylko jednego egzemplarza z którym chcemy
      pracowaæ, z powodów wydajno¶ci i zajêto¶ci pamiêci.
     </para>
     <para>
      Pomimo tego, ¿e mo¿liwe jest u¿ycie operatora <literal>@</literal> do
      <emphasis>wyciszenia</emphasis> ewentualnych b³êdów w konstruktorze
      podczas u¿ycia go w konstrukcji <literal>@new</literal>, to zapis ten
      nie dzia³a kiedy u¿ywana jest konstrukcja <literal>&amp;new</literal>.
      Jest to ograniczenie silnika Zend (Zend Engine) i u¿ycie takiego zapisu
      spowoduje b³±d parsowania.
     </para>
   </note>
   <para>
    Drug± rzecz± na któr± pozwalaj± referencje jest przekazywanie zmiennych
    przez-referencje. Mo¿liwe jest to przez uczynienie zmiennej lokalnej w
    funkcji i zmiennej w zakresie wywo³ywania tej funkcji odwo³ujacych siê do
    tej samej warto¶ci. Na przyk³ad:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo (&$zmienna)
{
    $zmienna++;
}

$a=5;
foo ($a);
?>
]]>
     </programlisting>
    </informalexample>
    spowoduje, ¿e <varname>$a</varname> bêdzie równe 6. Dzieje siê tak,
    poniewa¿ w funkcji <varname>foo</varname> zmienna
    <varname>$zmienna</varname> odwo³uje siê do tej samaj zawarto¶ci jak
    zmienna <varname>$a</varname>. Zobacz równie¿ bardiej dok³adne wyja¶niena
    na temat <link
    linkend="language.references.pass">przekazywania przez referencjê</link>.
   </para>
   <simpara>
    Trzeci± rzecz± któr± umo¿liwiaj± referencje jest <link
    linkend="language.references.return">zwracanie przez referencje</link>.
   </simpara>
  </sect1>

  <sect1 xml:id="language.references.arent">
   <title>Czym nie s± referencje</title>
   <para>
    Jak powiedizano wcze¶niej, referencje nie s± wska¼nikami. To znaczy, ¿e
    poni¿szy zapis nie zadzia³a tak jak siê wydaje:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo (&$zmienna)
{
    $zmienna =& $GLOBALS["baz"];
}
foo($bar);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    To, co siê faktycznie dzieje, to zmienna <varname>$zmienna</varname> w
    funkcji <varname>foo</varname> bêdzie zwi±zana ze zmienn±
    <varname>$bar</varname> podczas wywo³ania, lecz zaraz potem bêdzie
    zwi±zana po raz wtóry, tym razem z <varname>$GLOBALS["baz"]</varname>. Nie
    ma sposobu by zwi±zaæ <varname>$bar</varname> w zakresie wywo³ywuj±cym
    funkcjê z czym¶ innym, u¿ywaj±c mechanizmu referencji, poniewa¿ zmienna
    <varname>$bar</varname> nie jest dostêpna w funkcji <varname>foo</varname>
    (jest tylko reprezentowana przez zmienn± <varname>$zmienna</varname>,
    lecz <varname>$zmienna</varname> zawiera tylko warto¶æ zmiennej, a nie
    jest wi±zaniem nazwa-warto¶æ w tablicy symboli).
   </simpara>
  </sect1>

  <sect1 xml:id="language.references.pass">
   <title>Przekazywanie przez referencje</title>
   <para>
    Mo¿esz przekazaæ zmienn± do funkcji poprzez referencjê, by funkcja mog³a
    modyfikowaæ swoje parametry. Sk³ania jest jak nastêpuje:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo (&$zmienna)
{
    $zmienna++;
}

$a=5;
foo ($a);
// $a jest równe 6 w tym momencie
?>
]]>
     </programlisting>
    </informalexample>
    We¼ pod uwagê to, ¿e nie ma znaku odwo³ywania siê przez referencjê przy
    wywo³ywaniu funkcji - istnieje tylko w definicji funkcji. Sama definicja
    funkcji jest wystarczaj±cym miejscem do zaznaczenia przekazywania
    argumentów przez referencjê.
  </para>
  <para>
   Przez referencjê mog± byæ przekazywane nastêpuj±ce rzeczy:
   <itemizedlist>
    <listitem>
     <simpara>
      Zmienne, np. <literal>foo($a)</literal>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Instrukcja new, np. <literal>foo(new foobar())</literal>
     </simpara>
    </listitem>
    <listitem>
     <para>
      Referencjê, zwracane z funkcji, np.:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function &bar()
{
    $a = 5;
    return $a;
}
foo(bar());
?>
]]>
     </programlisting>
    </informalexample>
    Zobacz równie¿ wyja¶nienia na temat <link
    linkend="language.references.return">zwracania przez referencjê</link>. 
     </para>
    </listitem>
  </itemizedlist>
  </para>
  <para>
   Ka¿de inne wyra¿enie nie powinno byæ przekazywane przez referencjê,
   poniewa¿ wynik takiego przekazania jest nieprzewidywalny. Dla przyk³adu,
   poni¿sze przyk³ady przekazywania przez referencjê s± niepoprawne:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function bar() // Zwróæ uwagê na brak &
{
    $a = 5;
    return $a;
}
foo(bar());

foo($a = 5); // Wyra¿enie, nie zmienna
foo(5); // Sta³a, nie zmienna
?>
]]>
     </programlisting>
    </informalexample>
    Te wymagania s± dla PHP 4.0.4 i wy¿szych wersji.
  </para>
  </sect1>

  <sect1 xml:id="language.references.return">
   <title>Zwracanie referencji</title>
   <para>
    Zwracanie przez-referencjê jest u¿yteczne gdy chcesz u¿yæ funkcji do
    znalezienia zmiennej do której referencj± powinna byæ dowi±zana. Zwracaj±c
    referencje u¿ywaj tej sk³adni:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function &znajdz_zmienna ($param)
{
    /* ...kod... */
    return $znaleziona_zmienna;
}

$foo =& znajdz_zmienna ($bar);
$foo->x = 2;
?>
]]>
     </programlisting>
    </informalexample>
    W tym przyk³adzie, bêdzie zmieniona w³asno¶æ obiektu zwróconego przez
    funkcjê <varname>znajdz_zmienna</varname>, a nie w³asno¶æ kopii obiektu,
    jak to by by³o bez u¿ycia sk³adni referencji.
   </para>
   <note>
    <simpara>
     Inaczej ni¿ przy przekazywaniu parametrów, tutaj musisz u¿ywaæ
     <literal>&amp;</literal> w obu miejscach - by wskazaæ, ¿e zwracasz
     przez-referencjê, a nie kopiê jak normalnie, i by zwróciæ uwagê, ¿e
     dla zmiennej <varname>$foo</varname> powinno byæ u¿yte powi±zanie przez
     referencjê, a nie zwyk³e przypisanie.
    </simpara>
   </note>
  </sect1>

  <sect1 xml:id="language.references.unset">
   <title>Niszczenie referencji</title>
   <para>
    Kiedy niszczysz referencje, zrywasz wi±zanie miêdzy nazw± zmiennej a jej
    zawarto¶ci±. Nie znaczy to, ¿e ta zawarto¶æ bêdzie zniszczona. Na
    przyk³ad:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b =& $a;
unset ($a); 
?>
]]>
     </programlisting>
    </informalexample>
    nie zniszczy <varname>$b</varname>, tylko <varname>$a</varname>. 
   </para>
   <simpara>
    Znów, pomocne bêdzie pomy¶lenie o tym jak o analogii do Uniksowego
    wywo³ania <command>unlink</command>.
   </simpara>
  </sect1>

  <sect1 xml:id="language.references.spot">
   <title>Znajdywanie referencji</title>
   <simpara>
    Wiele konstrukcji sk³adniowych w PHP jest zaimplementowanych przy u¿yciu
    referencji, tak wiêc wszystko co zosta³o powiedziane wcze¶niej o
    referencjach dotyczyæ bêdzie równie¿ tych konstrukcji. Pewne konstrukcje,
    jak przekazywanie i zwracanie przez referencje, s± wspomniane wy¿ej.
    Innymi konstrukcjami u¿ywaj±cymi mechanizmu referencji s±:
   </simpara>

   <sect2 xml:id="references.global">
    <title>Referencje konstrukcji <literal>global</literal></title>
    <para>
     Kiedy deklarujesz zmienn± jako <command>global $var</command> to tak
     naprawdê tworzysz referencjê do zmiennej globalnej. To znaczy, ¿e dzia³a
     to tak samo jak:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$zmienna =& $GLOBALS["zmienna"];
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     To znaczy, na przyk³ad, ¿e usuniêcie <varname>$zmienna</varname>
     nie usunie zmiennej globalnej.
    </simpara>
   </sect2>

   <sect2 xml:id="references.this">
    <title><literal>$this</literal></title>
    <simpara>
     W metodach obiektowych, <varname>$this</varname> jest zawsze referencj±
     do obiektu wyw³uj±cego dan± metodê.
    </simpara>
   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
