<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: 1.99 Maintainer: garbus Status: ready -->
<!-- $Revision: 1.15 $ -->
<!-- CREDITS: qrak -->
 <chapter xml:id="language.variables" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Zmienne</title>
  
  <sect1 xml:id="language.variables.basics">
   <title>Podstawy</title>

   <simpara>
    Ka¿d± zmienn± w PHP zapisuje siê, poprzedzaj±c jej nazwê znakiem dolara "$".
    Wielko¶æ liter w nazwie zmiennej jest rozró¿niana.
   </simpara>

   <para>
    Nazw zmiennych dotycz± te same regu³y, co innych rodzajów nazw w PHP.
    Poprawna nazwa zmiennej zaczyna siê od litery lub znaku podkre¶lenia "_",
    po których mo¿e wyst±piæ dowolna ilo¶æ liter, cyfr lub znaków podkre¶lenia.
    Jako wyra¿enie regularne, mo¿na to zapisaæ tak:
    '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'
   </para>
   
   <note>
    <simpara>
     W naszym rozumieniu, litery to znaki a-z, A-Z i symbole ASCII od 127 do
     255 (0x7f-0xff).
    </simpara>
   </note>

   <note>
    <simpara>
     <literal>$this</literal> to specjalna zmienna, której nie mo¿na
     definiowaæ.
    </simpara>
   </note>

   &tip.userlandnaming;

   <para>
    Aby uzyskaæ wiêcej informacji na temat funkcji powi±zanych ze zmiennymi, zobacz
    <link linkend="ref.var">Funkcje Obs³ugi Zmiennych</link>.
   </para>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$var = "Pan";
$Var = "Jan";
echo "$var, $Var";      // wy¶wietla "Pan, Jan"

$4site = 'not yet';     // niepoprawna nazwa - zaczyna siê od cyfry
$_4site = 'not yet';    // poprawna nazwa - zaczyna siê znakiem podkre¶lenia
$ja¼ñ = 'mansikka';      // poprawna nazwa - "ñ" i "¼" nale¿± do ASCII 127-255
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Domy¶lnie, zmienne zawsze s± zawsze przypisywane przez warto¶æ. Innymi
    s³owy, je¶li przypiszesz do zmiennej jakie¶ wyra¿enie, warto¶æ tego
    wyra¿enia zostanie skopiowana do zmiennej. Oznacza to, ¿e po przypisaniu
    warto¶ci jednej zmiennej do drugiej, pó¼niejsza 
    zmiana warto¶ci jednej z nich nie spowoduje zmiany warto¶ci drugiej.
    Wiêcej informacji na ten temat w
    rozdziale <link 
    linkend="language.expressions">Wyra¿enia</link>.
   </para>
   <para>
    PHP oferuje jeszcze jeden sposób przypisywania warto¶ci do zmiennych:
    <link linkend="language.references">przypisanie przez referencjê</link>.
    Oznacza to, ¿e nowa zmienna tylko odnosi siê (innymi s³owy, 
    "staje siê aliasem" lub "wskazuje na") do pierwotnej zmiennej. 
    Zmiany wykonane na nowej zmiennej oddzia³uj± tak¿e na pierwotn± zmienn± i vice versa. 
   </para>
   <para>
    Aby przypisaæ przez referencjê, postaw znak ampersand (&amp;)
    przed nazw± zmiennej przypisywanej (zmiennej od której pobierasz
    warto¶æ). Na przyk³ad poni¿szy kod wy¶wietla "To jest 
    PHP" dwa razy:
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = "PHP";               // Przypisz warto¶æ "PHP" do $foo.
$bar = &$foo;               // Przypisz referencyjnie $foo do $bar.
$bar = "To jest $bar";      // Zmieñ $bar...
echo $bar;
echo $foo;                  // $foo te¿ siê zmieni³o.
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Nale¿y pamiêtaæ, ¿e tylko wyra¿enia posiadaj±ce nazwê mog± byæ przypisane
    przez referencjê.
    <informalexample>
     <programlisting role="php">
<![CDATA[ 
<?php
$foo = 25;
$bar = &$foo;      // Przypisanie poprawne.
$bar = &(24 * 7);  // Przypisanie niepoprawne - do nienazwanego wyra¿enia.

function test()
{
   return 25;
}

$bar = &test();    // Niepoprawne.
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <para>
    W PHP nie jest konieczne inicjowanie zmiennych, jednak jest to bardzo
    dobry nawyk. Niezainicjowane zmienne maj± domy¶lne warto¶ci zale¿ne od ich typu
    - &false;, zero, pusty ³añcuch lub niewype³nion± tablicê.
   </para>
   <para>
    <example>
     <title>Domy¶lne warto¶ci niezainicjowanych zmiennych</title>
     <programlisting role="php">
<![CDATA[
<?php
echo ($nieinicjowana_zmiena_bool ? "true" : "false"); // false
$nieinicjowana_zmienna_int += 25; // 0 + 25 => 25
echo $nieinicjowany_lancuch . "abc"; // "" . "abc" => "abc"
$nieinicjowana_tablica[3] = "def"; // array() + array(3 => "def") => array(3 => "def")
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Poleganie na domy¶lnej warto¶ci niezainicjowanej zmiennej jest problematyczne,
    w razie zawarcia jednego pliku wewn±trz innego, posiadaj±cego tak samo
    nazwane zmienne. Jest to równie¿ powa¿ne <link
    linkend="security.globals">zagro¿enie dla bezpieczeñstwa</link> przy w³±czonej opcji<link
    linkend="ini.register-globals">register_globals</link>. Ostrze¿enie klasy <link
    linkend="errorfunc.constants.errorlevels.e-notice">E_NOTICE</link> pojawi siê podczas
    pracy z niezainicjowanymi zmiennymi, jednak w przypadku przypisywania
    elentów do niezainicjowanych tablic - ju¿ nie. Funkcja <function>isset</function> 
    mo¿e zostaæ u¿yta w celu wykrycia, czy zmienna zosta³a ju¿ zainicjowana.
   </para>
  </sect1>
	 
  <sect1 xml:id="language.variables.predefined">
   <title>Zmienne predefiniowane</title>

   <simpara>
    PHP udostêpnia dla ka¿dego pracuj±cego skryptu du¿± ilo¶æ predefiniowanych
    zmiennych. Jednak¿e wiele spo¶ród tych zmiennych nie mo¿e byæ w pe³ni
    obja¶nionych, gdy¿ s± zale¿ne od rodzaju serwera, jego wersji, ustawieñ
    i innych czynników. Niektóre z tych zmiennych nie bêd± dostêpne dla
    skryptów PHP uruchomionych z 
    <link linkend="features.commandline">Linii Poleceñ</link>. 
    Lista tych zmiennych znajduje siê w rozdziale 
    <link linkend="reserved.variables">Predefiniowane Zmienne</link>. 
   </simpara>

   <warning>
    <simpara>
     W PHP 4.2.0 i pó¼niejszych, domy¶lne ustawienie dla instrukcji PHP <link
     linkend="ini.register-globals">register_globals</link> jest 
     <emphasis>wy³±czone</emphasis>. Jest to bardzo istotna zmiana w PHP. Maj±c opcjê
     register_globals <emphasis>wy³±czon±</emphasis> wp³ywamy na ustawienie zmiennych
     predefiniowanych, dostêpnych globalnie. Na przyk³ad, aby poznaæ warto¶æ
     <varname>DOCUMENT_ROOT</varname> u¿yjesz
     <varname>$_SERVER['DOCUMENT_ROOT']</varname> zamiast
     <varname>$DOCUMENT_ROOT</varname>, lub <varname>$_GET['id']</varname>
     z adresu URL <literal>http://www.example.com/test.php?id=3</literal> zamiast
     <varname>$id</varname>, albo <varname>$_ENV['HOME']</varname> a nie
     <varname>$HOME</varname>.
    </simpara>
    <simpara> 
     Aby uzyskaæ informacje powi±zane z t± zmian±, przeczytaj czê¶æ o konfiguracji
     <link linkend="ini.register-globals">register_globals</link>, rozdzia³u
     o bezpieczeñstwie <link linkend="security.globals">U¿ywanie Register Globals
     </link>, oraz w informacjach o wydaniu (ang. Release Announcements) PHP <link xlink:href="&url.php.release4.1.0;">4.1.0
     </link> jak i <link xlink:href="&url.php.release4.2.0;">4.2.0</link>
    </simpara>
    <simpara>
     U¿ywanie dostêpnych zmiennych predefiniowanych, jak 
     <link linkend="language.variables.superglobals">tablice superglobalne</link>, 
     jest zalecane.
    </simpara>
   </warning>
   
   <simpara>
    Pocz±wszy od wersji 4.1.0, PHP udostêpnia dodatkowo zestaw predefiniowanych tablic,
    które zawieraj± zmienne serwera, zmienne ¶rodowiskowe oraz zmienne
    u¿ytkownika. Tablice te s± do¶æ specyficzne, gdy¿
    s± one automatycznie globalne, tzn. automatycznie
    dostêpne w ka¿dym miejscu. Dlatego nazywa siê
    je "superglobalami". (W PHP nie ma mechanizmu pozwalaj±cego u¿ytkownikowi na definiowanie
    w³asnych superglobali.) Superglobale PHP wymienione s± poni¿ej;
    jednak¿e wykaz ich zawarto¶ci i g³êbsze omówienie
    prefiniowanych zmiennych PHP oraz ich natury znajduje siê w rozdziale
    <link linkend="reserved.variables">predefiniowane zmienne</link>.
    Zauwa¿ tak¿e, ¿e starsze zmienne predefiniowane 
    (<varname>$HTTP_*_VARS</varname>) wci±¿ funkcjonuj±.

    &avail.register-long-arrays;
   </simpara>

   <note>
    <title>Zmienne zmienne</title>
    <para>
     Zmienne superglobale nie mog± byæ u¿yte jako
     <link linkend="language.variables.variable">zmienne zmienne</link>
     wewn±trz funkcji, ani jako metody klasy.
    </para>
   </note>
   
   <note>
    <para>
     Nawet pomimo tego, ¿e zmienne superglobalne i HTTP_*_VARS mog± istnieæ w tym samym
     czasie; nie s± one to¿same, czyli zmiana jednej nie zmieni drugiej.
    </para>
   </note>
   
   <para>
    Je¶li pewne zmienne w <link
    linkend="ini.variables-order">variables_order</link> nie s± ustawione, to ich
    odpowiedniki zmiennych predefiniowanych PHP równie¿ s± puste.
   </para>
					
   <variablelist xml:id="language.variables.superglobals">
    <title>Superglobale PHP</title>
    <varlistentry>
     <term><link linkend="reserved.variables.globals">$GLOBALS</link></term>
     <listitem>
      <simpara>
       Zawiera referencje do ka¿dej ze zmiennych aktualnie
       dostêpnych w zasiêgu globalnym skryptu. Kluczami
       tablicy s± nazwy zmiennych globalnych.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.server">$_SERVER</link></term>
     <listitem>
      <simpara>
       Zmienne tworzone przez serwer lub bezpo¶rednio powi±zane ze ¶rodowiskiem
       uruchomieniowym danego skryptu. Analogiczna do dawnej tablicy
       <varname>$HTTP_SERVER_VARS</varname> (która jest nadal dostêpna, ale
       uznana za przestarza³±).
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.get">$_GET</link></term>
     <listitem>
      <simpara>
       Zmienne dostarczone do skryptu za pomoc± ³añcucha w URL.
       Analogiczna do dawnej tablicy <varname>$HTTP_GET_VARS</varname> (która
       jest nadal dostêpna, ale uznana za przestarza³±).
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.post">$_POST</link></term>
     <listitem>
      <simpara>
       Zmienne dostarczone do skryptu metod± POST protoko³u HTTP. Analogiczna
       do dawnej tablicy <varname>$HTTP_POST_VARS</varname> (która jest nadal
       dostêpna, ale uznana za przestarza³±).
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.cookies">$_COOKIE</link></term>
     <listitem>
      <simpara>
       Zmienne dostarczone do skryptu przez ciasteczka HTTP. Analogiczna do
       dawnej tablicy <varname>$HTTP_COOKIE_VARS</varname> (która jest nadal
       dostêpna, ale uznana za przestarza³±).
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.files">$_FILES</link></term>
     <listitem>
      <simpara>
       Zmienne dostarczone do skryptu przez przes³anie plików do serwera metod±
       POST protoko³u HTTP. Analogiczna do dawnej tablicy
       <varname>$HTTP_POST_FILES</varname> (która jest nadal dostêpna, ale
       uznana za przestarza³±). Wiêcej na ten temat w rozdziale <link
       linkend="features.file-upload.post-method">przesy³anie plików metod±
       POST</link>.
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.environment">$_ENV</link></term>
     <listitem>
      <simpara>
       Zmienne dostarczone do skryptu przez ¶rodowisko operacyjne. Analogiczna
       do dawnej tablicy <varname>$HTTP_ENV_VARS</varname> (która jest nadal
       dostêpna, ale uznana za przestarza³±).
      </simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.request">$_REQUEST</link></term>
     <listitem>
      <simpara>
       Zmienne dostarczone do skryptu metodami GET, POST i mechanizmem COOKIE,
       przez co NIE s± one godne zaufania. Obecno¶æ
       i kolejno¶æ do³±czania zmiennych do tej tabicy odbywa siê zgodnie
       z dyrektyw± PHP <link linkend="ini.variables-order">variables_order</link>.
       Tabica ta nie ma swojego odpowiednika w wersjach
       PHP starszych, ni¿ 4.1.0. ZObacz tak¿e
       <function>import_request_variables</function>.
      </simpara>
      <caution>
       <simpara>
        Od wersji PHP 4.3.0, informacje z tablicy <varname>$_FILES</varname>
	nie istniej± w <varname>$_REQUEST</varname>.
       </simpara>
      </caution>
      <note>
       <simpara>
        W trybie <link linkend="features.commandline">linii poleceñ
        </link>, tablica ta <emphasis>nie</emphasis> zawiera
        zmiennych <varname>argv</varname> i <varname>argc</varname>; s± one
	dostêpne w tablicy <varname>$_SERVER</varname>.
       </simpara>
      </note>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><link linkend="reserved.variables.session">$_SESSION</link></term>
     <listitem>
      <simpara>
       Zmienne aktualnie zarejestrowane jako 
       sesyjne. Analogiczne do dawnej
       tablicy <varname>$HTTP_SESSION_VARS</varname> (która jest wci±¿
       dostêpna, ale uznana za przestarza³±). Zajrzyj te¿ do rozdzia³u <link
       tlinkend="ref.session">funkcje obs³ugi sesji</link>, aby uzyskaæ
       wiêcej informacji.
      </simpara>
     </listitem>
    </varlistentry>
   </variablelist> 

  </sect1>


  <sect1 xml:id="language.variables.scope">
   <title>Zasiêg zmiennych</title>

   <simpara>
    Zasiêg zmiennej zale¿y od miejsca, w jakim j± zdewiniowano.
    Najczê¶ciej zmienne PHP widoczne s± tylko w jednym zasiêgu.
    Taki zasiêg obejmuje równie¿ pliki do³±czone funkcjami include i require.  Na
    przyk³ad:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
include 'b.inc';
?>
]]>
    </programlisting>
   </informalexample>
   <simpara>
    Tutaj zmienna <varname>$a</varname> bêdzie dostêpna tak¿e wewn±trz do³±czonego
    funkcj± include pliku <filename>b.inc</filename> w skrypcie. Jednak¿e wewn±trz
    funkcji zdefiniowanych samodzielnie zmienne maj± zasiêg lokalny. Ka¿da
    zmienna u¿yta wewn±trz funkcji jest domy¶lnie ograniczona do zasiêgu lokalnego
    funkcji.  Na przyk³ad:
   </simpara>
    
   <informalexample>
    <programlisting role="php"> 
<![CDATA[
<?php
$a = 1; /* zasiêg globalny */ 

function Test()
{ 
    echo $a; /* odwo³anie do zmiennej o zasiêgu lokalnym */ 
} 

Test();
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Ten skrypt nie wy¶wietli niczego, poniewa¿ instrukcja echo
    odwo³uje siê do zmiennej lokalnej <varname>$a</varname>,
    której jak dot±d nie zosta³a przypisana ¿adna warto¶æ. Mo¿na
    tu zauwa¿yæ ró¿nicê w stosunku do jêzyka C, gdzie
    zmienne globalne s± zawsze dostêpne wewn±trz
    definicji funkcji, o ile nie zosta³y nadpisane przez lokaln± definicjê
    zmiennej. Mo¿e to spowodowaæ taki problem, ¿e kto¶ mo¿e nieodwracalnie
    zmieniæ warto¶æ zmiennej globalnej. W PHP zmienne globalne musz±
    byæ jawnie okre¶lone jako globalne wewn±trz funkcji, w której maj± byæ u¿yte, 
    do czego u¿ywamy s³owa kluczowego global.
   </simpara>

   <sect2 xml:id="language.variables.scope.global">
    <title>polecenie global</title>
    <simpara>
     Najpierw, przyk³ad u¿ycia <literal>global</literal>:
    </simpara>
    <para>
     <example>
      <title>U¿ywanie polecenia global</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;

function Suma()
{
    global $a, $b;

    $b = $a + $b;
}

Suma();
echo $b;
?>
]]>			     
      </programlisting>
     </example>
    </para>

   <simpara>
    Powy¿szy skrypt wy¶wietli wynik &quot;3&quot;.  Przez zadeklarowanie
    wewn±trz funkcji globalno¶ci zmiennych <varname>$a</varname> i
    <varname>$b</varname>, wszystkie odwo³ania do tych zmiennych 
    bêd± odnosi³y siê do ich globalnych wersji. Nie ma ¿adnych ograniczeñ
    w ilo¶ci zmiennych globalnych, na których chcemy operowaæ wewn±trz funkcji.
   </simpara>

   <simpara>
    Drugim sposobem uzyskania dostêpu do zmiennych globalnych wewn±trz funkcji
    jest u¿ycie specjalnej, zdefiniowanej przez PHP tablicy 
    <varname>$GLOBALS</varname>. Powy¿szy przyk³ad mo¿na zatem przepisaæ tak:
   </simpara>
   <para>
    <example>
     <title>U¿ywanie <varname>$GLOBALS</varname> zamiast polecenia global</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;

function Suma()
{
    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
}

Suma();
echo $b;
?>
]]>
     </programlisting>
    </example>
   </para>
	        		 
   <simpara>
    Tablica <varname>$GLOBALS</varname> jest asocjacyjn± tablic±,
    w której nazwa zmiennej jest kluczem, a zawarto¶æ zmiennej
    warto¶ci± komórki tablicy.
    Zauwa¿, ¿e <varname>$GLOBALS</varname> jest dostêpna z ka¿dego miejsca,
    poniewa¿ $GLOBALS jest <link
    linkend="language.variables.superglobals">tablic± superglobaln±</link>.
    Poni¿ej przyk³ad demonstruj±cy moc superglobali:
   </simpara>
   <para>
    <example>
     <title>Przyk³ad demonstruj±cy superglobale i zasiêg zmiennych</title>
     <programlisting role="php">
<![CDATA[
<?php
function test_global()
{
    // Wiêkszo¶æ predefiniowanych zmiennych nie jest "super i wymaga
    // 'global', by byæ dostêpnymi w zasiêgu lokalnym funkcji.
    global $HTTP_POST_VARS;
    
    echo $HTTP_POST_VARS['name'];
    
    // Superglobale s± dostêpne z ka¿dego miejsca 
    // i nie wymagaj± 'global'. Superglobale udostêpniono
    // wraz z PHP 4.1.0, a HTTP_POST_VARS jest 
    // uwa¿ane za przestarza³e.
    echo $_POST['name'];
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
 
  <sect2 xml:id="language.variables.scope.static">
   <title>U¿ywanie zmiennych statycznych</title>
   <simpara>
    Jeszcze jedn± wa¿n± rzecz±, zwi±zan± z zasiêgiem zmiennych jest zmienna
    statyczna (ang. <emphasis>static</emphasis> variable). Zmienna statyczna
    mo¿e mieæ wy³±cznie zasiêg lokalny, ale nie traci swojej warto¶ci, kiedy
    program opu¶ci ten zasiêg lokalny, w którym dana zmienna statyczna siê
    znajduje. Rozwa¿my poni¿szy przyk³ad:
   </simpara>
   <para>
    <example>
     <title>Przyk³ad ukazuj±cy przydatno¶æ zmiennych statycznych</title>
     <programlisting role="php">
<![CDATA[
<?php
function Test()
{
    $a = 0;
    echo $a;
    $a++;
}
?>
]]>
     </programlisting>	  
    </example>
   </para>
   <simpara> 
    Ta funkcja jest bezu¿yteczna, gdy¿ przy ka¿dym jej wywo³aniu zmienna
    <varname>$a</varname> otrzymuje warto¶æ <literal>0</literal>, w zwi±zku
    z czym funkcja stale wy¶wietla &quot;0&quot;. Wystêpuj±ca potem
    inkrementacja <varname>$a</varname>++ nie ma ¿adnego znaczenia, gdy¿
    funkcja siê koñczy i zmienna <varname>$a</varname> znika. Aby powy¿sza
    funkcja mia³a jaki¶ sens, nale¿y zapobiec gubieniu warto¶ci
    <varname>$a</varname>, do czego u¿ywamy s³owa kluczowego static:
   </simpara>
   <para>
    <example>
     <title>Przyk³ad u¿ycia zmiennych statycznych</title>
     <programlisting role="php">
<![CDATA[
<?php
function Test()
{
    static $a = 0;
    echo $a;
    $a++;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Teraz, za ka¿dym wywo³aniem funkcji test, zostanie wy¶wietlona warto¶æ
    zmiennej <varname>$a</varname>, po czym ta zmienna zostanie inkrementowana.
   </simpara>

   <simpara>
    Zmienne statyczne pozwalaj± te¿ na wykorzystanie funkcji rekurencyjnych,
    czyli takich, które wywo³uj± same siebie. Funkcje rekurencyjne
    nale¿y pisaæ ostro¿nie, gdy¿ ³atwo jest wywo³aæ nieskoñczon±
    rekurencjê. Musisz byæ pewny, ¿e masz odpowiednie mechanizmy
    do zatrzymania rekurencji w jakim¶ momencie. Poni¿sza, prosta
    funkcja rekurencyjnie liczy do 10, u¿ywaj±c zmiennej
    statycznej <varname>$licznik</varname>, aby wiedzieæ, kiedy siê zatrzymaæ:
   </simpara>
   <para>
    <example>
     <title>Zmienne statyczne w funkcjach rekurencyjnych</title>
     <programlisting role="php">
<![CDATA[
<?php
function Test()
{
    static $licznik = 0;

    $licznik++;
    echo $licznik;
    if ($licznik < 10) {
        Test();
    }
    $licznik--;
}
?>
]]>
     </programlisting>
    </example>
   </para>

    <note>
     <para>
      Zmienne statyczne mog± byæ deklarowane, tak jak w powy¿szym przyk³adzie.
      Próba przypisania warto¶ci do tego typu zmiennych, poprzez wynik
      jakiego¶ wyra¿enia, spowoduje b³±d sk³adni (ang. Parse error).
     </para>
     <para>
      <example>
       <title>Deklaracja zmiennych statycznych</title>
       <programlisting role="php">
<![CDATA[
<?php
function foo(){
    static $int = 0;          // prawid³owo
    static $int = 1+2;        // b³±d  (w rzeczywisto¶ci to jest wyra¿enie)
    static $int = sqrt(121);  // b³±d  (to równie¿ jest wyra¿enie)

    $int++;
    echo $int;
}
?>
]]>
      </programlisting>
     </example>
    </para>
   </note>
  </sect2>
		    
  <sect2 xml:id="language.variables.scope.references">
   <title>Referencje do zmiennych statycznych i globalnych</title>
   <simpara>
    Silnik Zend 1 (ang. Zend Engine 1) napêdzaj±cy PHP4, implementuje modyfikatory
    <link linkend="language.variables.scope.static">statyczny</link> oraz
    <link linkend="language.variables.scope.global">globalny</link>
    dla zmiennych, pod wzglêdem <link linkend="language.references">
    referencji</link>. Na przyk³ad, w rzeczywisto¶ci globalna zmienna
    wprowadzona wewn±trz zasiêgu funkcji z wyra¿eniem <literal>global</literal>
    na dzi¶ dzieñ tworzy referencjê do zmiennej globalnej. Takie zachowanie mo¿e
    prowadziæ do nieoczekiwanych sytuacji, czego dowodzi poni¿szy przyk³ad:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test_global_ref() {
    global $obj;
    $obj = &new stdclass;
}

function test_global_noref() {
    global $obj;
    $obj = new stdclass;
}

test_global_ref();
var_dump($obj);
test_global_noref();
var_dump($obj);
?>
]]>
    </programlisting>
   </informalexample>	

   <simpara>
    Wykonanie tego przyk³adu da nastêpuj±ce wyniki:
   </simpara>

   <screen>
NULL
object(stdClass)(0) {
}
   </screen>

   <simpara>
    Podobna sytuacja dotyczy deklaracji <literal>static</literal>.
    Referencje nie s± magazynowane statycznie:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function &get_instance_ref() {
    static $obj;

    echo 'Obiekt statyczny: ';
    var_dump($obj);
    if (!isset($obj)) {
        // Przypisanie referencji do zmiennej statycznej.
	$obj = &new stdclass;
    }
    $obj->property++;
    return $obj;
}

function &get_instance_noref() {
    static $obj;

    echo 'Obiekt statyczny: ';
    var_dump($obj);
    if (!isset($obj)) {
        // Przypisanie do obiektu zmiennej statycznej
        $obj = new stdclass;
    }
    $obj->property++;
    return $obj;
}

$obj1 = get_instance_ref();
$still_obj1 = get_instance_ref();
echo "\n";
$obj2 = get_instance_noref();
$still_obj2 = get_instance_noref();
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Wykonanie tego przyk³adu da nastêpuj±ce wyniki:
   </simpara>

   <screen>
Obiekt statyczny: NULL
Obiekt statyczny: NULL

Obiekt statyczny: NULL
Obiekt statyczny: object(stdClass)(1) {
  ["property"]=>
  int(1)
}
   </screen>
          
   <simpara>
    Ten przyk³ad pokazuje, ¿e podczas przypisywania referencji do zmiennej
    statycznej, nie nastêpuje <emphasis>zapamiêtanie</emphasis>, gdy wywo³asz
    funkcjê <literal>&amp;get_instance_ref()</literal> po raz drugi.
   </simpara>
   </sect2>
  </sect1>
		       
  <sect1 xml:id="language.variables.variable">
   <title>Zmienne zmienne</title>

   <simpara>
    W niektórych przypadkach jest wygodne, by móc u¿yæ zmiennej o zmiennej
    nazwie. To znaczy zmiennej, której nazwa mo¿e byæ zmieniana dynamicznie.
    Zwyk³a zmienna jest ustawiana wyra¿eniem jak poni¿ej:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = "witaj";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Zmienna zmienna pobiera warto¶æ jednej zmiennej i traktuje j±
    jako nazwê innej.  W powy¿szym przyk³adzie,
    <emphasis>witaj</emphasis>, mo¿e staæ siê nazw± zmiennej,
    dziêki u¿yciu dwóch znaków dolara, tzn.
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$$a = "¶wiecie";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    W tym momencie dwie zmienne zosta³y zdefiniowane i umieszczone w drzewie
    symbolicznym PHP: <varname>$a</varname> zawieraj±ca "witaj" i 
    <varname>$witaj</varname> zawieraj±ca "¶wiecie". Zatem poni¿szy
    zapis:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo "$a ${$a}";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    znaczy to samo, co:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo "$a $witaj";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    tzn. obydwa wy¶wietl±: <computeroutput>witaj ¶wiecie</computeroutput>.
   </simpara>

   <simpara>
    Aby u¿ywaæ zmiennych zmiennych jako tablic, trzeba
    wyja¶niæ pewn± niejasno¶æ. Mianowicie, je¶li napiszesz
    <varname>$$a[1]</varname>, parser musi wiedzieæ, czy
    chesz u¿yæ <varname>$a[1]</varname> jako nazwy zmiennej, czy
    <varname>$$a</varname> jako nazwy tablicy, której rekord [1] ciê
    interesuje. W tym przypadku nale¿y zastosowaæ odrêbn±
    sk³adniê: <varname>${$a[1]}</varname> dla pierwszego przypadku a
    <varname>${$a}[1]</varname> dla drugiego.
   </simpara>
   
   <warning>   
    <simpara>
     Zauwa¿, ¿e zmienne zmienne nie mog± byæ u¿ywane z
     <link linkend="language.variables.superglobals">Tablicami superglobalnymi</link>
     PHP, wewn±trz funkcji, czy metod klas. Zmienna <literal>$this</literal>
     jest tak¿e specjaln± zmienn±, dla której referencje dynamiczne nie s± dozwolone.
    </simpara>
   </warning>

  </sect1>

  <sect1 xml:id="language.variables.external">
   <title>Zmienne spoza PHP</title>

   <sect2 xml:id="language.variables.external.form">
    <title>Formularze HTML (GET i POST)</title>

    <simpara>
     Kiedy do skryptu PHP zostanie wys³any formularz, informacja
     z niego jest automatycznie dostêpna w skrypcie. Istnieje
     wiele sposobów na uzyskanie tych informacji, dla przyk³adu:
    </simpara>

    <para>
     <example>
      <title>Prosty formularz PHP</title>
      <programlisting role="html">
<![CDATA[
<form action="foo.php" method="post">
    Imie:  <input type="text" name="imie" /><br />
    Email: <input type="text" name="email" /><br />
    <input type="submit" name="submit" value="Wyslij!" />
</form>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     W zale¿no¶ci od twoich szczególnych ustawieñ i osobistych upodobañ, istnieje
     wiele sposobów dostêpu do danych z twoich formularzy HTML. Oto kilka przyk³adów:
    </para>

    <para>
     <example>
      <title>Dostêp do informacji z prostego formularza HTML (wys³anego metod± POST)</title>
      <programlisting role="html">
<![CDATA[
<?php
// Mo¿liwe od PHP 4.1.0
      
   echo $_POST['imie'];
   echo $_REQUEST['imie'];

   import_request_variables('p', 'p_');
   echo $p_imie;

// Niedostêpne od PHP 6. Od PHP 5.0.0, te d³ugie predefiniowane
// zmienne mog± byæ niedostêpne z w³±czon± opcj± register_long_arrays.

   echo $HTTP_POST_VARS['imie'];

// Dostêpne, je¶li opcja register_globals jest w³±czona - "on". Pocz±wszy od
// PHP 4.2.0 domy¶lna warto¶æ opcji register_globals to off.
// Nie jest zalecane poleganie na tej metodzie.

   echo $imie;
?>
]]>
      </programlisting>
     </example>	      
    </para>
    <para>
     Przesy³anie danych z formularza metod± GET jest podobne, z takim wyj±tkiem, ¿e u¿yjesz
     zmienn± predefiniowan± odpowiedni± dla tej metody, zamiast poprzedniej. GET tak¿e
     odnosi siê do tzw. QUERY_STRING (informacje w adresie URL, po znaku '?'). Tak wiêc,
     dla przyk³adu, <literal>http://www.example.com/test.php?id=3</literal>
     zawiera dane dla metody GET, dostêpne poprzez <varname>$_GET['id']</varname>.
     Zobacz tak¿e <link linkend="reserved.variables.request">$_REQUEST</link> oraz
     <function>import_request_variables</function>.
    </para>

    <note>
     <para>
      <link linkend="language.variables.superglobals">Tablice superglobalne</link>,
      takie jak <varname>$_POST</varname> i <varname>$_GET</varname>, zosta³y
      udostêpnione w PHP 4.1.0
     </para>
    </note>

    <para>
     Jak widaæ, przed PHP 4.2.0 domy¶ln± warto¶ci± opcji<link
     linkend="ini.register-globals">register_globals</link>
     by³o <emphasis>on</emphasis>. Spo³eczno¶æ PHP
     jest ca³kowiie przekonana, by nie polegaæ na tej opcji;
     w rzeczywisto¶ci najlepiej jest nadaæ jej warto¶æ <emphasis>off</emphasis>, oraz
     przystosowaæ do tego kod.
    </para>

    <note>
     <para>
      Dyrektywa konfiguracyjna <link linkend="ini.magic-quotes-gpc">magic_quotes_gpc</link>
      oddzia³uje na zmienne z Get, Post i Cookie. Je¶li jest w³±czona,
      tekst (It's "PHP!") automagicznie zmieni siê w (It\'s \"PHP!\").
      Jest to potrzebne przy wpisywaniu danych do baz danych. Zobacz tak¿e
      <function>addslashes</function>, <function>stripslashes</function> i
      <link linkend="ini.magic-quotes-sybase">magic_quotes_sybase</link>.
     </para>
    </note>
    
    <simpara>
     PHP obs³uguje tak¿e tablice w kontek¶cie zmiennych z formularzy 
     (zajrzyj do <link linkend="faq.html">FAQ</link>). Mo¿na 
     na przyk³ad pogrupowaæ razem powi±zane zmienne lub u¿yæ tej 
     mo¿liwo¶ci do pobrania warto¶ci z pola wyboru (select). Na 
     przyk³ad, wy¶lijmy formularz z pliku metod± POST do samego siebie
     i wy¶wietlmy te dane:
    </simpara>

    <para>
     <example>
      <title>Bardziej z³o¿one zmienne w formularzach</title>
      <programlisting role="php">
<![CDATA[
<?php
if ($_POST) {
    echo '<pre>';
    echo htmlspecialchars(print_r($_POST, true));
    echo '</pre>';
}
?>
<form action="" method="post">
    Nazwisko: <input type="text" name="personal[nazwisko]"><br />
    Email: <input type="text" name="personal[email]"><br />
    Piwo: <br />
    <select multiple name="piwo[]">
        <option value="zywiec">¯ywiec</option>
        <option value="tyskie">Tyskie</option>
        <option value="lech">Lech</option>
    </select><br />
    <input type="submit" value="Wy¶lij mnie!" />
</form>
]]>
      </programlisting>
     </example>
    </para>

    <sect3 xml:id="language.variables.external.form.submit">
     <title>Nazwy zmiennych dla SUBMIT w postaci obrazka</title>

     <simpara>
      Przy tworzeniu formularza, mo¿na u¿yæ obrazka, zamiast standardowego
      przycisku Wy¶lij, za pomoc± takiego znacznika:
     </simpara>

     <informalexample>
      <programlisting role="html">
<![CDATA[
<input type="image" src="obrazek.gif" name="sub" />
]]>
      </programlisting>
     </informalexample>

     <simpara>
      Kiedy u¿ytkownik kliknie gdzie¶ na obrazku, formularz, którego
      to dotyczy, zostanie wys³any do serwera z dwiema dodatkowymi
      zmiennymi, sub_x i sub_y. Zawieraj± one wspó³rzêdne miejsca
      klikniêcia na obrazek. Mo¿na przy tym zauwa¿yæ, ¿e
      na razie w nazwach zmiennych znajduje siê kropka
      zamiast podkre¶lnika, ale PHP konwertuje kropkê na
      podkre¶lnik automatycznie.
     </simpara>
    </sect3>

   </sect2>

   <sect2 xml:id="language.variables.external.cookies">
    <title>Ciasteczka HTTP</title>

    <simpara>
     PHP bez problemu obs³uguje ciasteczka HTTP, takie jak zdefiniowano w <link
     xlink:href="&spec.cookies;">Specyfikacji Netscape'a</link>. Ciasteczka s±
     mechanizmem przechowywania informacji w przegl±darce klienta w celu
     ¶ledzenia lub identyfikowania sta³ych bywalców strony. Ciasteczka ustawia
     siê za pomoc± funkcji <function>setcookie</function>. Ciasteczka s± czê¶ci±
     nag³ówka HTTP, wiêc funkcja SetCookie musi byæ wywo³ana zanim jakakolwiek
     inna informacja zostanie wys³ana do przegl±darki. Takie samo ograniczenie
     dotyczy funkcji <function>header</function>. Dane z ciasteczek 
     s± wówczas dostêpne w odpowiednich tablicach danych cookies, takich 
     jak <varname>$_COOKIE</varname>, <varname>$HTTP_COOKIE_VARS</varname> 
     jak równie¿ <varname>$_REQUEST</varname>. Zobacz tak¿e 
     stronê dotycz±c± funkcji <function>setcookie</function> aby poznaæ wiêcej 
     informacji i przyk³adów.
    </simpara>

    <simpara>
     Je¶li chcesz przypisaæ wiele warto¶ci do jednego ciasteczka, mo¿esz
     po prostu z³±czyæ je w tablicê. Na przyk³ad:
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
  setcookie("MojeCiasteczko[foo]", 'Test 1', time()+3600);
  setcookie("MojeCiasteczko[bar]", 'Test 2', time()+3600);
?>
]]>
     </programlisting>
    </informalexample>

    <simpara>
     Spowoduje to stworzenie dwóch oddzielnych ciasteczek, mimo, i¿ MojeCiasteczko bêdzie teraz
     pojedyncz± tablic± w twoim skrypcie. Je¶li chcesz ustawiæ tylko jedno ciasteczko
     z wieloma warto¶ciami, rozwa¿ mo¿liwo¶æ u¿ycia przedtem funkcji <function>serialize</function>
     lub <function>explode</function> na warto¶ci.
    </simpara>

    <simpara>
     Pamiêtaj, ¿e wys³ane ciasteczko zast±pi wcze¶niejsze ciasteczko o tej
     nazwie, o ile ¶cie¿ka lub domena nie s± ró¿ne. Na przyk³ad dla koszyka
     do zakupów mo¿esz potrzebowaæ licznika a jego warto¶æ stale przekazywaæ
     dalej, tzn.
    </simpara>

    <example>
     <title>Przyk³ad u¿ycia funkcji <function>setcookie</function></title>
     <programlisting role="php">
<![CDATA[
<?php
if (isset($_COOKIE['ile'])) {
    $ile = $_COOKIE['ile'] + 1;
} else {
    $ile = 1;
}
setcookie('ile', $ile, time()+3600);
setcookie("Cart[$ile]", $pozycja, time()+3600);
?>
]]>
     </programlisting>
    </example>

   </sect2>

   <sect2 xml:id="language.variables.external.dot-in-names">
    <title>Kropki w nazwach nadchodz±cych zmiennych</title>

    <para>
     PHP normalnie nie zmienia nazw zmiennych podczas
     przekazywania ich do skryptu. Jednak¿e nale¿y pamiêtaæ, ¿e
     kropka "." nie jest poprawnym znakiem w
     nazwie zmiennej PHP. Dlaczego? Proszê spojrzeæ na to:
     <programlisting role="php">
<![CDATA[
<?php
$varname.ext;  /* niepoprawna nazwa zmiennej */
?>
]]>
     </programlisting>
     To co widzi parser, to zmienna o nazwie
     <varname>$varname</varname>, po której pojawia siê operator konkatenacji,
     a nastêpnie pusty ³añcuch (czyli taki, który
     nie jest ¿adnym s³owem kluczowym, ani zarezerwowanym) "ext". Oczywi¶cie,
     nie daje to ¿adnego sensownego wyniku.
    </para>

    <para>
     Warto zatem wiedzieæ, ¿e PHP automatycznie
     zast±pi podkre¶lnikiem "_" ka¿d± kropkê w nazwie ka¿dej
     odebranej zmiennej.
    </para>

   </sect2>

   <sect2 xml:id="language.variables.determining-type-of">
    <title>Okre¶lanie typów zmiennych</title>

    <para>
     Poniewa¿ PHP samodzielnie okre¶la typy zmiennych i konwertuje je
     (zasadniczo) jak potrzeba, nie zawsze jest jasne, jakiego typu jest dana
     zmienna w danym momencie. PHP zawiera kilka funkcji do okre¶lania typów
     zmiennych, takich jak:
     <function>gettype</function>, <function>is_array</function>,
     <function>is_float</function>, <function>is_int</function>,
     <function>is_object</function> i
     <function>is_string</function>. Zobacz tak¿e rozdzia³
     o <link linkend="language.types">Typach</link>.
    </para>
   </sect2>

  </sect1>
     
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
