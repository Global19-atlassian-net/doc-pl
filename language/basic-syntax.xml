<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 6b24e8069b857871c4ec3968b2c79c7be8244160 Maintainer: adi Status: ready -->
<!-- $Revision$ -->
<!-- CREDITS: sobak -->
 <chapter xml:id="language.basic-syntax" xmlns="http://docbook.org/ns/docbook">
  <title>Podstawowa składnia</title>
  <sect1 xml:id="language.basic-syntax.phptags">
   <title>Znaczniki PHP</title>
   <para>
    Kiedy PHP przetwarza plik, szuka otwierających i zamykających znaczników (tagów)
	(są nimi <literal>&lt;?php</literal> i <literal>?&gt;</literal>),
    które mówią PHP o rozpoczęciu i zakończeniu interpretowania kodu pomiędzy
    nimi. Przetwarzanie w taki sposób pozwala zagnieżdzać PHP w dowolnym
    rodzaju dokumentów, ponieważ wszystko poza parą
    znaczników, otwierającym i zamykającym jest ignorowane przez parser PHP.
   </para>
   <para>
    PHP pozwala także na użycie krótkich tagów <literal>&lt;?</literal> i <literal>?&gt;</literal>,
    które są niezalecane, ponieważ są dostępne tylko gdy włączone przez dyrektywę
    <link linkend="ini.short-open-tag">short_open_tag</link> lub gdy PHP zostało skonfigurowane
    z opcją <option>--enable-short-tags</option>.
   </para>
   <para>
    Jeżeli plik zawiera jedynie kod PHP, zaleca się pominięcie zamykającego tagu PHP na końcu pliku.
	Zapobiega to dodaniu przypadkowych białych znaków lub nowych linii dodanych po zamknięciu bloku PHP,
	co może spowodować niechciane efekty ponieważ PHP zacznie buforowanie wyjścia, gdy nie było to intencją
	programisty na tym etapie wykonywania skryptu.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "Witaj, świecie!";

// ... więcej kodu

echo "Ostatnie wyrażenie";

// skrypt kończy się w tym miejscu, bez tagu zamykającego PHP
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  <sect1 xml:id="language.basic-syntax.phpmode">
   <title>Wyskakiwanie z HTML</title>
   <para>
    Wszystko na zewnątrz tagów PHP jest ignorowane przez parser, co pozwala plikom PHP
	mieć mieszaną zawartość. To pozwala na zagnieżdżanie PHP w plikach HTML, na przykład
	w celu stworzenia szablonu.
    <example>
     <programlisting role="php">
<![CDATA[
<?php
<p>To zostanie zignorowane przez PHP i wyświetlone w przeglądarce.</p>
<?php echo 'Podczas gdy to zostanie sparsowane.'; ?>
<p>To także zostanie zignorowane przez PHP i wyświetlone w przeglądarce.</p>
]]>
     </programlisting>
    </example>
    To działa tak, jak się spodziewano, ponieważ kiedy interpreter PHP natrafi na zamykający 
    znacznik ?&gt;, poprostu zaczyna wyświetlać cokolwiek znajdzie (z wyjątkiem
    bezpośrednio następującej nowej linii - zobacz
    <link linkend="language.basic-syntax.instruction-separation">oddzielanie instrukcji</link>)
	dopóki nie natrafi na kolejny otwierający znacznik - chyba, że znajdzie się to wewnątrz
	instrukcji warunkowej; w tym wypadku interpreter najpierw sprawdzi wynik instrukcji, aby
	zdecydować co pominąć.
	Zobacz kolejny przykład:
   </para>
   <para>
    Wykorzystanie struktur z warunkami
    <example>
     <title>Zaawansowane wyskakiwanie przy użyciu warunków</title>
     <programlisting role="php">
<![CDATA[
<?php if ($expression == true): ?>
  To pokaże się, jeżeli wyrażenie jest prawdziwe.
<?php else: ?>
  W przeciwnym wypadku pokaże się to.
<?php endif; ?>
]]>
     </programlisting>
    </example>
    W tym przykładzie PHP pominie bloki, gdzie warunek nie jest spełniony, nawet
    jeżeli są one wewnątrz tagów PHP. PHP pomija je odpowiednio do warunku,
    ponieważ interpreter przeskakuje bloki zawarte w instrukcji, która nie została
    spełniona.
   </para>
   <para>
    Dla wyświetlania większych ilości tekstu, wyjście z trybu parsowania PHP
    jest ogólnie rzecz biorąc bardziej wydajne niż wysyłanie całego tekstu przez
    funkcje <function>echo</function> lub <function>print</function>.
   </para>
   <para>
    Mamy cztery różne pary otwierających i zamykających znaczników,
    które mogą być użyte w php. Dwie z nich, &lt;?php ?&gt; i
    &lt;script language="php"&gt; &lt;/script&gt; są zawsze dostępne.
    Dwie następne to krótkie znaczniki i znaczniki w stylu
    <productname>ASP</productname>, mogą być włączane i wyłączane
    w pliku konfiguracyjnym &php.ini;. Część osób postrzega krótkie znaczniki
    i znaczniki w stylu <productname>ASP</productname> jako wygodne, jednakże
    są one mniej przenośne, i zasadniczo nie polecane.
    <note>
     <para>
      Zauważ również, że jeśli zagnieżdzasz PHP w XML lub XHTML
      musisz stosować znaczniki &lt;?php ?&gt; aby pozostać
      w zgodzie ze standardami.
     </para>
    </note> 
   </para>
   <para>
    <example>
     <title>Znaczniki otwierające i zamykające PHP</title>
     <programlisting role="php">
<![CDATA[
1.  <?php echo 'jeśli chcesz obsługiwać dokumenty XHTML lub XML, zrób to tak'; ?>

2.  <script language="php">
        echo 'niektóre edytory (jak FrontPage) nie lubią
              instrukcji przetwarzania';
    </script>

3.  <? echo 'to jest najprostsza instrukcja przetwarzania SGML'; ?>
    <?= wyrazenie ?> To jest skrót dla "<? echo wyrazenie ?>"

4.  <% echo 'Możesz opcjonalnie użyć znaczników w stylu ASP'; %>
    <%= $zmienna; # To jest skrót dla "<% echo $zmienna; %>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Z pokazanych znaczników, pierwszy i drugi przykład są zawsze
    dostępne, pierwszy przykład jest najbardziej powszechny i 
    rekomendowany. 
   </para>
   <para>
    Krótkie znaczniki (trzeci przykład) są dostepne jedynie, kiedy są
    włączone za pomocą dyrektywy konfiguracyjnej <link linkend="ini.short-open-tag">short_open_tag</link>
    w &php.ini; lub jeśli php zostało skonfigurowane 
    z opcją <option>--enable-short-tags</option>.
   </para>    
   <para>
    Znaczniki w stylu <productname>ASP</productname> (czwarty przykład) są dostępne jedynie gdy 
    zostaną włączone poprzez dyrektywę konfiguracyjną
    <link linkend="ini.asp-tags">asp_tags</link> w &php.ini;
   </para>
   <para>
    <note>
     <para>
      Powinieneś unikać używania krótkich znaczników, kiedy rozwijasz aplikacje
      lub biblioteki, które są nastawione na rozpowszechnianie lub pracujesz
      na serwerach PHP, nad którymi nie masz kontroli, ponieważ krótkie znaczniki
      mogą nie być obsługiwane na docelowym serwerze. Dla przenośnego,
      rozpowszechnialnego kodu, miej pewność, aby nie użyć krotkich znaczników.
     </para>
    </note>
    <note>
     <para>
      W PHP 5.2 i wcześniejszych, parser nie pozwalał, aby
      znacznik otwierający <literal>&lt;?php</literal> był jedynym znakiem w pliku.
      Dozwolone jest to od PHP 5.3, pod warunkiem, że po tagu otwierającym znajduje
	  się jeden lub więcej białych znaków (np. spacja).
     </para>
    </note>
    <note> 
     <para> 
       Począwszy od PHP 5.4, krótkie znaczniki <literal>&lt;?=</literal> są zawsze rozpoznawane i
       ważne, niezależnie od ustawień <link linkend="ini.short-open-tag">short_open_tag</link>.
     </para> 
    </note> 
   </para>
  </sect1>
  <sect1 xml:id="language.basic-syntax.instruction-separation">
   <title>Oddzielanie instrukcji</title>
   <para>
    Podobnie jak C i Perl, PHP wymaga aby instrukcje były zakończone
    średnikiem, na końcu każdego wyrażenia. Zamykający znacznik bloku
    kodu PHP automatycznie implikuje średnik; nie musisz mieć
    średnika zamykającego ostatnią linię z bloku PHP. Zamykający znacznik
    dla bloku będzie zawierać bezpośrednio następującą nową linie jeśli
    taka istnieje.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
    echo 'To jest test';
?>

<?php echo 'To jest test' ?>

<?php echo 'Pomineliśmy ostatni zamykający znacznik';
]]>
     </programlisting>
    </informalexample>
    <note>
     <para>
      Zamykający znacznik bloku PHP na końcu pliku jest opcjonalny,
      i w niektórych przypadkach pominięcie jego jest pomocne kiedy używamy
      <function>include</function> lub <function>require</function>, tak więc
      niechciane białe znaki nie będą znajdować się na końcu pliku, i ciągle
      będzie możliwe dodanie nagłówków do odpowiedzi. To jest także poręczne jeśli używasz
      buferowania wyjścia, i nie chciałbyś zobaczyć dodanych niechcianych białych znaków
      na końcu cześci generowanej przez includowany plik.
     </para>
    </note>
   </para> 
  </sect1>
  <sect1 xml:id="language.basic-syntax.comments">
   <title>Komentarze</title>   
   <para>
    PHP obsługuje komentarze w stylu 'C', 'C++' i powłoki Unix (styl Perl\'a). Na przykład:

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
    echo 'To jest test'; // To jest jednoliniowy komentarz w stylu c++
    /* To jest wieloliniowy komentarz
       jeszcze inna linia komentarza */
    echo 'To jest jeszcze jeden test';
    echo 'Ostatni test'; # To jest jednoliniowy komentarz w stylu powłoki
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    "Jednolinijkowy" styl komentarzy obowiązuje jedynie do konca
    linii lub bieżącego bloku kodu PHP, cokolwiek wystąpi pierwsze.
    Co oznacza, że kod HTML za <literal>// ... ?&gt;</literal>
    lub  <literal># ...  ?&gt;</literal> ZOSTANIE wyświetlony:
    ?&gt; przerywa tryb PHP i wraca do trybu HTML, i  
    <literal>//</literal> lub <literal>#</literal> nie może wpłynąć na to.
    Jeśli, dyrektywa konfiguracyjna <link linkend="ini.asp-tags">asp_tags</link>
    jest włączona, to działa tak samo z <literal>// %&gt;</literal> i
    <literal># %&gt;</literal>.
    Jednakże, znacznik <literal>&lt;/script&gt;</literal> nie przerywa trybu PHP w
    jednolinijkowym komentarzu.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<h1>To jest <?php # echo 'prosty';?> przykład</h1>
<p>Nagłowek powyżej będzie mówił 'To jest  przykład'.</p>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Komentarze w stylu 'C' kończą się na pierwszym napotkanym <literal>*/</literal>.
    Upewnij się, że nie zagnieżdzasz komentarzy w stylu 'C'. Łatwo jest popełnić
    pomyłkę jeśli próbujesz odkomentować duży blok kodu.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
 /* 
    echo 'To jest test'; /* Ten komentarz będzie przyczyną problemów */
 */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
