<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 62d27014053411b67ff2c87de7e12d6a40c99dad Maintainer: adi Status: ready -->
<!-- $Revision$ -->
 <chapter xml:id="language.basic-syntax" xmlns="http://docbook.org/ns/docbook">
  <title>Podstawowa składnia</title>
  <sect1 xml:id="language.basic-syntax.phpmode">
   <title>Wyskakiwanie z HTMLa</title>
   <para>
    Kiedy PHP przetwarza plik, szuka otwierających i zamykających znaczników (tagów),
    które mówią PHP o rozpoczęciu i zakończeniu interpretowania kodu pomiędzy
    nimi. Przetwarzanie w taki sposób pozwala zagnieżdzać php w dowolnym
    rodzaju dokumentów, ponieważ wszystko poza parą
    znaczników, otwierającym i zamykającym jest ignorowane przez parser PHP.
    Najczęściej zobaczysz php zagnieżdzone w dokumentach HTML,
    tak jak w tym przykładzie.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<p>To zostanie zignorowane.</p>
<?php echo 'Kiedy to zostanie przetworzone.'; ?>
<p>To również zostanie zignorowane.</p>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Możesz także użyć bardziej zaawansowanej struktury:
    <example>
     <title>Zaawansowane wyskakiwanie</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($wyrazenie) { 
    ?>
    <strong>To jest prawda.</strong>
    <?php 
} else { 
    ?>
    <strong>To jest fałsz.</strong>
    <?php 
}
?>
]]>
     </programlisting>
    </example>
    To działa jak się spodziewano, ponieważ kiedy PHP natrafi na zamykający 
    znacznik ?&gt;, poprostu zaczyna wyświetlać cokolwiek znajdzie (z wyjątkiem
    bezpośrednio następującej nowej linii - zobacz
    <link linkend="language.basic-syntax.instruction-separation">oddzielanie instrukcji</link>
    ) dopóki nie natrafi
    na kolejny otwierający znacznik. Podany przykład jest oczywiście przekombinowany,
    ale do wyświetlania dużych bloków tekstu, wychodzenie z trybu przetwarzania PHP
    jest zasadniczo bardziej efektywne niż wysyłanie całego tekstu przez
    funkcje <function>echo</function> lub
    <function>print</function>.  
   </para>
   <para>
    Mamy cztery różne pary otwierających i zamykających znaczników,
    które mogą być użyte w php. Dwie z nich, &lt;?php ?&gt; i
    &lt;script language="php"&gt; &lt;/script&gt; są zawsze dostępne.
    Dwie następne to krótkie znaczniki i znaczniki w stylu
    <productname>ASP</productname>, mogą być włączane i wyłączane
    w pliku konfiguracyjnym &php.ini;. Część osób postrzega krótkie znaczniki
    i znaczniki w stylu <productname>ASP</productname> jako wygodne, jednakże
    są one mniej przenośne, i zasadniczo nie polecane.
    <note>
     <para>
      Zauważ również, że jeśli zagnieżdzasz PHP w XML lub XHTML
      musisz stosować znaczniki &lt;?php ?&gt; aby pozostać
      w zgodzie ze standardami.
     </para>
    </note> 
   </para>
   <para>
    <example>
     <title>Znaczniki otwierające i zamykające PHP</title>
     <programlisting role="php">
<![CDATA[
1.  <?php echo 'jeśli chcesz obsługiwać dokumenty XHTML lub XML, zrób to tak'; ?>

2.  <script language="php">
        echo 'niektóre edytory (jak FrontPage) nie lubią
              instrukcji przetwarzania';
    </script>

3.  <? echo 'to jest najprostsza instrukcja przetwarzania SGML'; ?>
    <?= wyrazenie ?> To jest skrót dla "<? echo wyrazenie ?>"

4.  <% echo 'Możesz opcjonalnie użyć znaczników w stylu ASP'; %>
    <%= $zmienna; # To jest skrót dla "<% echo . . ." %>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Z pokazanych znaczników, pierwszy i drugi przykład są zawsze
    dostępne, pierwszy przykład jest najbardziej powszechny i 
    rekomendowany. 
   </para>
   <para>
    Krótkie znaczniki (trzeci przykład) są dostepne jedynie, kiedy są
    włączone za pomocą dyrektywy konfiguracyjnej <link linkend="ini.short-open-tag">short_open_tag</link>
    w &php.ini; lub jeśli php zostało skonfigurowane 
    z opcją <option>--enable-short-tags</option>.
   </para>    
   <para>
    Znaczniki w stylu <productname>ASP</productname> (czwarty przykład) są dostępne jedynie gdy 
    zostaną włączone poprzez dyrektywę konfiguracyjną
    <link linkend="ini.asp-tags">asp_tags</link> w &php.ini;
   </para>
   <para>
    <note>
     <para>
      Powinieneś unikać używania krótkich znaczników, kiedy rozwijasz aplikacje
      lub biblioteki, które są nastawione na rozpowszechnianie lub pracujesz
      na serwerach PHP, nad którymi nie masz kontroli, ponieważ krótkie znaczniki
      mogą nie być obsługiwane na docelowym serwerze. Dla przenośnego,
      rozpowszechnialnego kodu, miej pewność, aby nie użyć krotkich znaczników.
     </para>
    </note>
    <note>
     <para>
      W PHP 5.2 i wcześniejszych, parser nie pozwalał, aby
      znacznik otwierający <literal>&lt;?php</literal> był jedynym znakiem w pliku.
      Dozwolone jest to od PHP 5.3.
     </para>
    </note>
    <note> 
     <para> 
       Począwszy od PHP 5.4, krótkie znaczniki <literal>&lt;?=</literal> są zawsze rozpoznawane i
       ważne, niezależnie od ustawień <link linkend="ini.short-open-tag">short_open_tag</link>.
     </para> 
    </note> 
   </para>
  </sect1>
  <sect1 xml:id="language.basic-syntax.instruction-separation">
   <title>Oddzielanie instrukcji</title>
   <para>
    Podobnie jak C i Perl, PHP wymaga aby instrukcje były zakończone
    średnikiem, na końcu każdego wyrażenia. Zamykający znacznik bloku
    kodu PHP automatycznie implikuje średnik; nie musisz mieć
    średnika zamykającego ostatnią linię z bloku PHP. Zamykający znacznik
    dla bloku będzie zawierać bezpośrednio następującą nową linie jeśli
    taka istnieje.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
    echo 'To jest test';
?>

<?php echo 'To jest test' ?>

<?php echo 'Pomineliśmy ostatni zamykający znacznik';
]]>
     </programlisting>
    </informalexample>
    <note>
     <para>
      Zamykający znacznik bloku PHP na końcu pliku jest opcjonalny,
      i w niektórych przypadkach pominięcie jego jest pomocne kiedy używamy
      <function>include</function> lub <function>require</function>, tak więc
      niechciane białe znaki nie będą znajdować się na końcu pliku, i ciągle
      będzie możliwe dodanie nagłówków do odpowiedzi. To jest także poręczne jeśli używasz
      buferowania wyjścia, i nie chciałbyś zobaczyć dodanych niechcianych białych znaków
      na końcu cześci generowanej przez includowany plik.
     </para>
    </note>
   </para> 
  </sect1>
  <sect1 xml:id="language.basic-syntax.comments">
   <title>Komentarze</title>   
   <para>
    PHP obsługuje komentarze w stylu 'C', 'C++' i powłoki Unix (styl Perl\'a). Na przykład:

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
    echo 'To jest test'; // To jest jednoliniowy komentarz w stylu c++
    /* To jest wieloliniowy komentarz
       jeszcze inna linia komentarza */
    echo 'To jest jeszcze jeden test';
    echo 'Ostatni test'; # To jest jednoliniowy komentarz w stylu powłoki
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    "Jednolinijkowy" styl komentarzy obowiązuje jedynie do konca
    linii lub bieżącego bloku kodu PHP, cokolwiek wystąpi pierwsze.
    Co oznacza, że kod HTML za <literal>// ... ?&gt;</literal>
    lub  <literal># ...  ?&gt;</literal> ZOSTANIE wyświetlony:
    ?&gt; przerywa tryb PHP i wraca do trybu HTML, i  
    <literal>//</literal> lub <literal>#</literal> nie może wpłynąć na to.
    Jeśli, dyrektywa konfiguracyjna <link linkend="ini.asp-tags">asp_tags</link>
    jest włączona, to działa tak samo z <literal>// %&gt;</literal> i
    <literal># %&gt;</literal>.
    Jednakże, znacznik <literal>&lt;/script&gt;</literal> nie przerywa trybu PHP w
    jednolinijkowym komentarzu.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<h1>To jest <?php # echo 'prosty';?> przykład</h1>
<p>Nagłowek powyżej będzie mówił 'To jest  przykład'.</p>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Komentarze w stylu 'C' kończą się na pierwszym napotkanym <literal>*/</literal>.
    Upewnij się, że nie zagnieżdzasz komentarzy w stylu 'C'. Łatwo jest popełnić
    pomyłkę jeśli próbujesz odkomentować duży blok kodu.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
 /* 
    echo 'To jest test'; /* Ten komentarz będzie przyczyną problemów */
 */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
