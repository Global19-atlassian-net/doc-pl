<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: 1.76 Maintainer: qrak Status: ready -->
<!-- $Revision: 1.8 $ -->
 <chapter id="language.types">
  <title>Typy danych</title>

  <sect1 id="language.types.intro">
  <title>Wstêp</title>
  
  <simpara>
   PHP obs³uguje osiem typów prostych.
  </simpara>
  
  <para>
   Cztery skalarne:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.boolean">boolowski (boolean)</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.integer">liczba ca³kowita (integer)</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.float">liczba zmiennoprzecinkowa 
      (float)</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.string">³añcuch znaków (string)</link>
     </simpara>
    </listitem>

   </itemizedlist>

   Dwa typy z³o¿one:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.array">tablica (array)</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.object">obiekt (object)</link>
     </simpara>
    </listitem>

   </itemizedlist>

   Oraz dwa typy specjalne:

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.resource">identyfikator zasobów
      (resource)</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.null">NULL (null)</link>
     </simpara>
    </listitem>

   </itemizedlist>
  </para>
  
  <note>
   <simpara>
    W tym podrêczniku czêsto pojawia siê typ <literal>mixed</literal>. Ten
    pseudotyp wskazuje na mo¿liwo¶æ u¿ycia danych ró¿nego typu.
   </simpara>
   <!--
   
   Just an idea, maybe useful for some func-defs?
   (at least it is for the operator-defs)
   
   <simpara>
    In parameter definitions you can also encounter the 'number' pseudo-type,
    that indicates a parameter that is either <type>integer</type> or 
    <type>float</type>.
   </simpara>
   -->
  </note>


  <simpara>
   Typ danych zwykle nie jest ustalany przez programistê. Robi to PHP na
   podstawie kontekstu, w jakim zmienna jest u¿ywana.
  </simpara>
  <note>
   <simpara>
    Aby sprawdziæ typ i warto¶æ konkretnego <link
    linkend="language.expressions">wyra¿enia</link>, nale¿y u¿yæ funkcji
    <function>var_dump</function>.
   </simpara>
   <simpara>
    Aby mieæ czyteln± reprezentacjê typu dla potrzeb debugowania, nale¿y u¿yæ
    funkcji <function>gettype</function>. Aby sprawdziæ, czy zmienna jest
    jakiego¶ konkretnego typu, <emphasis>nie</emphasis> u¿ywaj funkcji
    <function>gettype</function>, tylko grupy funkcji 
    <literal>is_<replaceable>jaki¶_typ</replaceable></literal>.
   </simpara>
   <!-- TODO: example(s) would be great -->
  </note>
  <simpara>
   Aby narzuciæ konwersjê zmiennej do okre¶lonego typu, mo¿na albo <link
   linkend="language.types.typecasting">rzutowaæ</link> zmienn±, albo u¿yæ
   funkcji <function>settype</function>.
  </simpara>
  <simpara>
   Proszê pamiêtaæ, ¿e w pewnych sytuacjach zmienne mog± siê zachowywaæ ró¿nie,
   w zale¿no¶ci od tego, jakiego typu s± w danej chwili. Wiêcej informacji
   w rozdziale <link
   linkend="language.types.type-juggling">wykorzystywanie typów danych</link>.
  </simpara>
  
   
   </sect1>
   
   <sect1 id="language.types.boolean">
    <title>Zmienne Logiczne (Boolowskie - boolean)</title>
    
    <simpara>
     Ten rodzaj jest najprostszy. Typ <type>boolean</type> wyra¿a logiczn±
     prawdê lub fa³sz. Mo¿e mieæ warto¶ci &true; lub &false;.
    </simpara>

    <note>
     <simpara>
      Typ boolowski zosta³ wprowadzony w PHP 4.
     </simpara>
    </note>

    <sect2 id="language.types.boolean.syntax">
     <title>Sk³adnia</title>
     <para>
      Aby utworzyæ warto¶æ boolowsk±, nale¿y u¿yæ s³ów kluczowych &true; lub
      &false;. Wielko¶æ liter w tych s³owach nie gra roli.
      <!-- technically they are just constants -->
      <informalexample>
       <programlisting role="php">
<![CDATA[
$foo = True; // przypisanie warto¶ci logicznej prawda do $foo     
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      Ten typ najczê¶ciej u¿ywany jest przy
      <link linkend="language.operators">operatorach</link>, które zwracaj±
      warto¶æ typu <type>boolean</type>, któr± nastêpnie przekazuje siê
      do <link linkend="control-structures">struktur kontrolnych</link>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
// == jest operatorem, który zwraca warto¶æ boolowsk±
if ($akcja == "poka¿_wersjê") {
    echo "Wersja 1.23";
}

// to nie jest konieczne:
if ($poka¿_separatory == TRUE) {
    echo "<hr>\n";
}

// gdy¿ wystarczy tak:
if ($poka¿_separatory) {
    echo "<hr>\n";
}
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>Konwersja do typu boolowskiego</title>
      <simpara>
       Aby jawnie skonwertowaæ warto¶æ na typ <type>boolean</type>, nale¿y
       u¿yæ rzutowania <literal>(bool)</literal> lub
       <literal>(boolean)</literal>. Jednak¿e w wiêkszo¶ci przypadków nie ma
       potrzeby u¿ycia rzutowania, poniewa¿ warto¶æ bêdzie automatycznie
       skonwertowana na typ <type>boolean</type>, je¶li operator, funkcja lub
       struktura kontrolna wymaga argumentu tego w³a¶nie typu.
      </simpara>
      <simpara>
       Zobacz te¿
       <link linkend="language.types.type-juggling">wykorzysytwanie typów
       danych</link>.
      </simpara>
      
      <para>
       Przy konwersji na typ <type>boolean</type>, poni¿sze warto¶ci otrzymuj±
       warto¶æ logiczn± &false;:
  
       <itemizedlist>
        <listitem>
         <simpara><link linkend="language.types.boolean">boolowski</link> 
          &false;<!-- duh... --></simpara>
        </listitem>
        <listitem>
         <simpara>liczba <link linkend="language.types.integer">ca³kowita</link
         > 0 (zero) </simpara>
        </listitem>
        <listitem>
         <simpara>liczba
         <link linkend="language.types.float">zmiennoprzecinkowa</link> 
         0.0 (zero) </simpara>
        </listitem>
        <listitem>
         <simpara>pusty <link linkend="language.types.string"
           >³añcuch znaków</link>, oraz <link linkend="language.types.string"
           >³añcuch znaków</link> "0"</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.array">tablica</link> 
         z zerow± liczb± elementów</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.object">obiekt</link> 
         z zerow± liczb± elementów</simpara>
        </listitem>
        <listitem>
         <simpara>specjalny typ <link linkend="language.types.null"
           >NULL</link> (w³±czaj±c niezadeklarowane zmienne)
         </simpara>
        </listitem>
       </itemizedlist>
       
       Ka¿da inna warto¶æ otrzymuje logiczn± warto¶æ &true; (w³±czaj±c w to
       <link linkend="language.types.resource">identyfikatory zasobów</link>).
       <warning>
        <simpara>
         <literal>-1</literal> tak¿e ma warto¶æ &true;, jak ka¿da niezerowa
         (ujemna lub dodatnia) liczba!
        </simpara>
       </warning>
       <!-- TODO: add a few examples, for the people only looking at 
            the examples... -->
      </para>
     
    </sect2>

   </sect1>

   <sect1 id="language.types.integer">
    <title>Liczby ca³kowite (integer)</title>
    
    <simpara>
     Typ <type>integer</type> to liczba ca³kowita, nale¿±ca do przedzia³u
     Z = {..., -2, -1, 0, 1, 2, ...}.
    </simpara>
     
    <para>
     Zobacz te¿:
     <link linkend="ref.gmp">Liczby ca³kowite du¿ej wielko¶ci</link> oraz
     <link linkend="language.types.float">Liczby zmiennoprzecinkowe</link>
    </para>

    <sect2 id="language.types.integer.syntax">
     <title>Sk³adnia</title>
     <simpara>
      Liczby ca³kowite mog± byæ zapisane w notacji dziesiêtnej (opartej na 10),
      szesnastkowej (opartej na 16) lub ósemkowej (opartej na 8), opcjonalnie
      poprzedzone znakiem (- lub +).
     </simpara>
     <para>
      Aby zapisaæ liczbê w notacji ósemkowej, nale¿y poprzedziæ w³a¶ciw± liczbê
      symbolem <literal>0</literal> (zero). W notacji szesnastkowej liczbê
      nale¿y poprzedziæ symbolem <literal>0x</literal>.
      <example>
       <title>Notacja liczb ca³kowitych</title>
       <programlisting role="php">
<![CDATA[
$a = 1234; # liczba dziesiêtna
$a = -123; # ujemna liczba dziesiêtna
$a = 0123; # liczba ósemkowa (odpowiednik dziesiêtnej 83)
$a = 0x1A; # liczba szesnastkowa (odpowiednik dziesiêtnej 26)
]]>
       </programlisting>
      </example>
      <!--

       decimal     : [1-9][0-9]*
                   | 0
       
       hexadecimal : 0[xX][0-9a-fA-F]+
       
       octal       : 0[0-7]+
       
       integer     : [+-]?decimal
                   | [+-]?hexadecimal
                   | [+-]?octal
       
       -->
      Maksymalna wielko¶æ liczby ca³kowitej jest zale¿na od platformy
      operacyjnej, zwykle jest to oko³o dwa miliardy (jest to 32 bity ze
      znakiem). PHP nie obs³uguje liczb ca³kowitych bez znaku.
     </para>
    </sect2>
   
    <sect2 id="language.types.integer.overflow">
     <title>Wyj¶cie poza zakres liczb ca³kowitych</title>
     <para>
      W przypadku zapisania liczby ca³kowitej wykraczaj±cej poza zakres typu
      <type>integer</type>, liczba ta zostanie potraktowana jako typ
      <type>float</type>. Równie¿ je¶li rezultat operacji bêdzie wykracza³ poza
      typ <type>integer</type>, jako wynik zostanie zwrócony typ 
      <type>float</type>.
      <informalexample>
       <programlisting role="php">
<![CDATA[
$du¿a_liczba =  2147483647;
var_dump($du¿a_liczba);
// wynik: int(2147483647)

$du¿a_liczba =  2147483648;
var_dump($du¿a_liczba);
// wynik: float(2147483648)

// tak samo dzieje siê przy warto¶ciach szesnastkowych:
var_dump( 0x80000000 );
// wynik: float(2147483648)

$million = 1000000;
$du¿a_liczba =  50000 * $million;
var_dump($du¿a_liczba);
// wynik: float(50000000000)
]]>
       </programlisting>
      </informalexample>
      <warning>
       <simpara>
        Niestety, b³±d w PHP powodowa³ czasem nieprawid³ow± pracê z liczbami
        ujemnymi. Na przyk³ad: wynikiem dzia³ania <literal>-50000 *
        $million</literal> by³a liczba <literal>-429496728</literal>. B³±d ten
        pojawia³ siê tylko przy liczbach ujemnych i nie dotyczy³ warto¶ci
        dodatnich.
       </simpara>
       <simpara>
        Powy¿szy problem zosta³ rozwi±zany w PHP 4.1.0.
       </simpara>
      </warning>
     </para>
     <para>
      W PHP nie ma operatora dzielenia ca³kowitego.
      <literal>1/2</literal> daje wynik typu <type>float</type> o warto¶ci
      <literal>0.5</literal>.
       <!-- See ??? for more information. (with the
      operators, or with type-jug) -->
      <informalexample>
       <programlisting role="php">
<![CDATA[
var_dump( 25/7 );
// wynik: float(3.5714285714286)
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>
   

    <sect2 id="language.types.integer.casting">
     <title>Konwersja na liczby ca³kowite</title>
      <simpara>
       Do jawnej konwersji warto¶ci na typ <type>integer</type> u¿ywa siê
       operatora rzutowania <literal>(int)</literal> lub
       <literal>(integer)</literal>. W wiêkszo¶ci przypadków jednak rzutowanie
       nie jest potrzebne, gdy¿ warto¶æ zostanie skonwertowana automatycznie,
       o ile operator, funkcja lub struktura kontrolna wymaga argumentu typu
       <type>integer</type>.
      </simpara>
      <simpara>
       Zobacz te¿ 
       <link linkend="language.types.type-juggling">wykorzystywanie 
       typów danych</link>.
      </simpara>
      
      <sect3 id="language.types.integer.casting.from-boolean">
       <title>Z <link linkend="language.types.boolean"
           >boolowskiej</link></title>
       <simpara>
        &false; bêdzie mieæ warto¶æ 
        <literal>0</literal> (zero), a &true; 
        bêdzie mieæ warto¶æ <literal>1</literal> (jeden).
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-float">
       <title>Z <link linkend="language.types.float">liczb
       zmiennoprzecinkowych</link></title> 
       <simpara>
        Przy konwersji z liczb zmiennoprzecinkowych do ca³kowitych, liczba
        zostanie zaokr±glona <emphasis>w dó³</emphasis>.
       </simpara>
       
       <para>
        Je¶li liczba zmiennoprzecinkowa jest poza zakresem liczb ca³kowitych,
        (zwykle <literal>+/- 2.15e+9 = 2^31</literal>), wynik operacji
        rzutowania jest niezdefiniowany, poniewa¿ liczba zmiennoprzecinkowa nie
        ma odpowiedniej precyzji, aby zwróciæ dok³adn± liczbê ca³kowit±. W tej
        sytuacji nie pojawi siê ¿adne ostrze¿enie ani informacja odno¶nie
        powsta³ego b³êdu!
       </para>
       
       <warning><para>
        Nigdy nie nale¿y rzutowaæ nieznanego u³amka do typu
        <type>integer</type>, gdy¿ mo¿e to doprowadziæ do otrzymania
        nieprzewidywalnych wyników.
        <informalexample>
         <programlisting role="php">
<![CDATA[
echo (int) ( (0.1+0.7) * 10 ); // wy¶wietla 7!
]]>
         </programlisting>
        </informalexample>
        
        Wiêcej informacji na ten temat w rozdziale <link 
        linkend="warn.float-precision">precyzja liczb
        zmiennoprzecinkowych</link>.
       </para></warning>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-string">
       <title>Z ³añcuchów znaków</title>
       <simpara>
        Zobacz <link linkend="language.types.string.conversion">konwersja
        ³añcuchów znaków</link>
       </simpara>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-other">
       <title>Z innych typów</title>
       <para>
        <caution>
         <simpara>
          Wynik konwersji do liczb ca³kowitych z innych typów jest nieokre¶lony.
          Obecnie zachowanie jest takie samo, jakby zmienna zosta³a najpierw
          <link linkend="language.types.boolean.casting">skonwertowana do
          typu boolowskiego</link>. <emphasis>Nie</emphasis> nale¿y jednak
          polegaæ na tym zachowaniu, gdy¿ mo¿e ono ulec zmianie bez ¿adnego
          ostrze¿enia.
         </simpara>
        </caution>
       </para>
       <!--
        
        IMO, it would more sense as (int) $arr returned the 
        number of elements in $arr. This won't break anything,
        since this behaviour was never defined before, and 
        (bool)(int) $arr will still behave the same.
        
        -->
      </sect3>
      
    </sect2>
  </sect1>

  <sect1 id="language.types.float">
   <title>Liczby zmiennoprzecinkowe (float)</title>
   <para>
    Liczby zmiennoprzecinkowe (typ float, double lub liczby rzeczywiste)
    mog± byæ zapisane przy u¿yciu dowolnej z poni¿szych sk³adni:
    <synopsis>
$a = 1.234; $a = 1.2e3; $a = 7E-10;
    </synopsis>
    <!--  
    
LNUM	[0-9]+
DNUM	([0-9]*[\.][0-9]+)|([0-9]+[\.][0-9]*)
EXPONENT_DNUM	(({LNUM}|{DNUM})[eE][+-]?{LNUM})
    
    -->
    Maksymalna wielko¶æ liczby zmiennoprzecinkowej jest zale¿na od platformy
    operacyjnej, zwykle jest to ~1.8e308, przy precyzji 14 liczb dziesiêtnych
    po przecinku (jest to 64 bitowy format IEEE).
   </para>
   <warning id="warn.float-precision">
    <title>Precyzja liczb zmiennoprzecinkowych</title>
    <para>
     Jest oczywiste, ¿e nawet proste u³amki dziesiêtne, takie jak
     <literal>0.1</literal> lub <literal>0.7</literal>, nie mog± zostaæ
     skonwertowane na ich dwójkowe odpowiedniki bez niewielkiej straty
     dok³adno¶ci. Mo¿e to powodowaæ pewne problemy: na przyk³ad wyra¿enie
     <literal>floor((0.1+0.7)*10)</literal> zwykle ma warto¶æ
     <literal>7</literal>, zamiast oczekiwanej <literal>8</literal>, gdy¿
     wewnêtrzna reprezentacja tego warto¶ci to liczba 
     <literal>7.9999999999...</literal>.
    </para>
    <para>
     Powi±zane jest to z faktem, ¿e dla pewnych u³amków zwyk³ych nie istnieje
     skoñczone rozwiniêcie dziesiêtne. Na przyk³ad <literal>1/3</literal> w
     reprezentacji dziesiêtnej ma warto¶æ <literal>0.3333333. . .</literal>.
    </para>
    <para>
     Dlatego nigdy nie nale¿y wierzyæ liczbom zmiennoprzecinkowym do ostatniej
     cyfry i nigdy nie nale¿y wykonywaæ operacji porównania na stwierdzenie
     równo¶ci. Do operacji na liczbach zmiennoprzecinkowych o naprawdê du¿ej
     precyzji nale¿y u¿yæ <link
     linkend="ref.bc">biblioteki BCMath</link> lub funkcji 
     <link linkend="ref.gmp">gmp</link>.
    </para>
   </warning>
  </sect1>

  <sect1 id="language.types.string">
   <title>£añcuchy znaków (string)</title>
   <para>
    Typ <type>string</type> oznacza ³añcuch znaków. W PHP znak jest tym sam co
    bajt, co oznacza, ¿e jest mo¿liwych 256 ró¿nych znaków. Oznacza to tak¿e,
    ¿e PHP nie posiada ¿adnej wbudowanej obs³ugi Unikodu.
    <!-- how about unicode? will we support that eventually? Are
    there current any ways to work with unicode?
    -->
   </para>
   <note>
    <simpara>
     Nie ma technicznych problemów, które utrudnia³yby tworzenie bardzo d³ugich
     ci±gów znaków. Nie ma te¿ ustalonej maksymalnej d³ugo¶ci ³añcuchów znaków
     obs³ugiwanych w PHP, wiêc nie ma powodu do obaw, ¿e dany ³añcuch jest zbyt
     d³ugi.
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>Sk³adnia</title>
    <para>
     £añcuch znaków mo¿na utworzyæ na trzy sposoby.
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">pojedyncze
        cudzys³owy</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">podwójne
        cudzys³owy</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">sk³adnia
        heredoc</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>Pojedyncze cudzys³owy</title>
     <para>
      Najprostszym sposóbem na zdefiniowanie prostego ³añcucha znaków, jest
      umieszczenie go w pojedynczych cudzys³owach (znak <literal>'</literal>).
     </para>
     <para>
      Aby w takim ³añcuch umie¶ciæ symbol pojedynczego cudzys³owu, nale¿y go
      poprzedziæ uko¶nikiem wstecznym (<literal>\</literal>), tak jak w wielu
      innych jêzykach programowania. Je¶li uko¶nik wsteczny ma wyst±piæ przed
      symbolem pojedynczego cudzys³owu lub na koñcu ³añcucha, wtedy nale¿y
      napisaæ go dwukrotnie. W przypadku u¿ycia uko¶nika wstecznego z innym
      znakiem, uko¶nik te¿ zostanie wy¶wietlony! Nie ma zatem potrzeby pisania
      uko¶nika dwukrotnie w innych sytuacjach.
      <note>
       <simpara>
        W PHP 3, ostrze¿enie na poziomie <literal>E_NOTICE</literal> zostanie
        wy¶wietlone, je¶li zajdzie powy¿sza sytuacja.
       </simpara>
      </note>
      <note>
       <simpara> 
        W przeciwieñstwie do dwóch pozosta³ych sk³adni, zmienne
        <emphasis>nie</emphasis> bêd± zamienione na swoje warto¶ci, kiedy
        pojawi± siê pomiêdzy pojedynczymi cudzys³owami.
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
echo 'przyk³adowy tekst';
echo 'Wewn±trz ³añcuchów znaków mog± siê znajdowaæ prze³amania linii,
o w³a¶nie takie.';
echo 'Adam powiedzia³: "I\'ll be back"';
// wynik: ... "I'll be back"
echo 'Czy na pewno chcesz skasowaæ C:\\*.*?';
// wynik: ... skasowaæ C:\*.*?
echo 'Czy na pewno chcesz skasowaæ C:\*.*?';
// wynik: ... skasowaæ C:\*.*?
echo 'Próbujê w tym miejscu wprowadziæ: \n znak nowej linii';
// wynik: ... wprowadziæ: \n znak nowej linii
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>Podwójne cudzys³owy</title>
     <para>
      Kiedy ³añcuch znaków jest umieszczony pomiêdzy podwójnymi cudzys³owami,
      PHP interpretuje wiêcej sekwencji cytowania dla znaków specjalnych:
     </para>
     <table>
      <title>Znaki cytowane (specjalne)</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>sekwencja</entry>
         <entry>znaczenie</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>nowa linia (LF lub 0x0A (10) w ASCII)</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>powrót karetki (CR lub 0x0D (13) w ASCII)</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>tabulacja pozioma (HT lub 0x09 (9) w ASCII)</entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>odwrotny uko¶nik</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>znak dolara</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>cudzys³ów podwójny</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          sekwencja znaków pasuj±ca do powy¿szego wyra¿enia regularnego daje
          znak zapisany w notacji ósemkowej
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          sekwencja znaków pasuj±ca do powy¿szego wyra¿enia regularnego daje
          znak zapisany w notacji szesnastkowej
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      Tak jak w poprzedniej sk³adni, zapisanie uko¶nika wstecznego przed
      ka¿dym innymi znakiem spowoduje wy¶wietlenie zarówno uko¶nika, jak i
      znaku.
     </para>
     <para>
      Ale najwa¿niejsz± w³a¶ciwo¶ci± podwójnych cudzys³owów jest to, ¿e zapisane
      w nich zmienne zostan± zamienione na ich warto¶ci. Wiêcej informacji
      w rozdziale <link linkend="language.types.string.parsing">parsowanie
      ³añcuchów znaków</link>.
     </para>
    </sect3>
    
    <sect3 id="language.types.string.syntax.heredoc">
     <title>Sk³adnia Heredoc</title>
     <simpara>
      Jeszcze jednym sposobem na zapisanie ³añcucha znaków jest u¿ycie skladni
      heredoc ("&lt;&lt;&lt;"). Po operatorze <literal>&lt;&lt;&lt;</literal>
      powinno siê umie¶ciæ identyfikator i takim samym identyfikatorem trzeba
      zakoñczyæ ³añcuch znaków.
     </simpara>     
     <simpara>
      Identyfikator zamykaj±cy <emphasis>musi</emphasis> zaczynaæ siê w
      pierwszej kolumnie nowej linii. Identyfikator musi te¿ podlegaæ regu³om
      nazewnictwa w PHP: musi siê sk³adaæ wy³±cznie z alfanumerycznych znaków
      oraz znaku podkre¶lenia i musi zaczynaæ siê od litery lub znaku
      podkre¶lenia.
     </simpara>
     
     <warning>
      <simpara>
       Wa¿ne by pamiêtaæ, ¿e linia zawieraj±ca identyfikator zamykaj±cy nie
       mo¿e zawieraæ ¿adnych innych znaków, z <emphasis>wyj±tkiem</emphasis>
       ¶rednika (<literal>;</literal>). Znaczy to przede wszystkim, ¿e
       identyfikator zamykaj±cy <emphasis>nie mo¿e byæ wcinany</emphasis>,
       i nie mo¿e byæ ¿adnych spacji ani tabulacji przed lub za ¶rednikiem.
      </simpara>
      <simpara>
       Najbardziej dokuczliwym ograniczeniem jest to, ¿e wewn±trz tego ³añcucha
       znaków nie mo¿e byæ znaku powrotu karetki (<literal>\r</literal>) na
       koñcu linii, jedynie znak nowej linii (<literal>\n</literal>).
       Poniewa¿ Microsoft Windows u¿ywa jako znaku koñca linii sekwencji
       <literal>\r\n</literal>, ³añcuchy znaków zapisne w sk³adni heredoc
       mog± nie dzia³aæ, je¶li skrypt zostanie napisany w edytorze windowsowym.
       Na szczê¶cie wiêkszo¶æ edytorów tekstowych udostêpnia mo¿liwo¶æ zapisania
       pliku w uniksowym formacie koñca linii.
       <!--
       FTP will sometimes automatically convert \r\n to \n while
       transferring your files to your webserver (which
       is *nix, of course)
       -->
      </simpara>
     </warning>

     <para>
      Sk³adnia heredoc zachowuje siê podobnie jak tekst w cudzys³owach
      podwójnych. Oznacza to te¿, ze nie ma potrzeby cytowania cudzys³owów w tej
      sk³adni, ale nadal mo¿na u¿ywaæ znaków cytowanych, opisanych powy¿ej.
      W tej sk³adni nazwa zmiennej zamieniana jest na jej warto¶æ, ale nale¿y
      zachowaæ ostro¿no¶æ przy zapisie z³o¿onych zmiennych razem z tekstem.
      <example> 
       <title>Przyk³ad sk³adni heredoc</title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Przyk³ad ³añcucha znaków,
zajmuj±cego kilka linii,
zapisanego w sk³adni heredoc.

Przyk³adowe zastosowanie w przezentacji liryki.

Litwo! Ojczyzno moja! ty jeste¶ jak zdrowie;
Ile ciê trzeba ceniæ, ten tylko siê dowie,
Kto ciê straci³. Dzi¶ piêkno¶æ tw± w ca³ej ozdobie
Widzê i opisujê, bo têskniê po tobie.
\tAdam Mickiewicz - Pan Tadeusz
EOD;

/* Bardziej z³o¿ony przyk³ad, ze zmiennymi */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MojeImiê';

echo <<<EOT
Nazywam siê "$name". Wy¶wietlam $foo->foo.
A teraz wy¶wietlam z tablicy: {$foo->bar[1]}.
Po dwukropku powinien pojawiæ siê znak 'A': \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>
  
     <note>
      <para>
       Obs³uga sk³adni heredoc zosta³a dodana w PHP 4.
      </para>
     </note>
  
    </sect3>
    <sect3 id="language.types.string.parsing">
     <title>Parsowanie zmiennych</title>
     <simpara>
      Kiedy ³añcuch znaków jest zapisany w cudzys³owach podwójnych lub w sk³adni
      heredoc, zawarte w nim nazwy zmiennych s± parsowane, tzn. 
      zamieniane na ich warto¶ci.
     </simpara>
     <simpara>
      S± dwa rodzaje sk³adni,
      <link linkend="language.types.string.parsing.simple">prosta</link>
      i
      <link linkend="language.types.string.parsing.complex">z³o¿ona</link>.
      Sk³adnia prosta jest najbardziej popularna i najwygodniejsza, pozwala
      na parsowanie zmiennej, warto¶ci z tablicy oraz w³a¶ciwo¶ci obiektu.
     </simpara>
     <simpara>
      Sk³adnia z³o¿ona pojawi³a siê w PHP 4, i mo¿na j± rozpoznaæ po nawiasach
      klamrowych, otaczaj±cych wyra¿enie.
     </simpara>
     <sect4 id="language.types.string.parsing.simple">
      <title>Sk³adnia prosta</title>
      <simpara>
       Je¶li wewn±trz zmiennej pojawi siê znak dolara (<literal>$</literal>),
       parser pobierze tyle znaków, ile tylko siê da, aby utworzyæ poprawn±
       nazwê zmiennej. Aby jawnie okre¶liæ koniec nazwy zmiennej, nale¿y j±
       zapisaæ w klamrach.
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$beer = 'Heineken';
echo "$beer's taste is great"; /* dzia³a, "'" nie jest poprawnym znakiem nazwy
zmiennej*/
echo "He drunk some $beers"; /* nie dzia³a, 's' jest poprawnym znakiem nazwy
zmiennej*/ 
echo "He drunk some ${beer}s"; // dzia³a
]]>
       </programlisting>
      </informalexample>
      <simpara>
       Podobnie dzia³a parsowanie elementu tablicy lub w³a¶ciwo¶ci obiektu.
       Dla tablic, prawy nawias prostok±tny (<literal>]</literal>) oznacza
       koniec indeksu. Dla w³a¶ciwo¶ci obiektu obowi±zuj± te same regu³y
       jak dla zwyk³ych zmiennych, jednak nie dzia³aj± tu opisane powy¿ej
       sztuczki ze zmiennymi.
       
       <!-- XXX isn't &true; :(, this would be the trick
       Also,
       the same trick with curly-braces works if you
       want to limit the greediness of parsers (aren't they
       paying them enough or something?).
       -->
      
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$owoce = array( 'truskawka' => 'czerwona' , 'banan' => '¿ó³ty' );

// zauwa¿ ¿e to dzia³a inaczej poza cudzys³owami
echo "Banan jest $owoce[banan].";

echo "Kwadrat ma szeroko¶æ $kwadrat->szeroko¶æ metrów.";

// Nie dzia³a. Trzeba tu zastosowaæ sk³adniê z³o¿on±
echo "Kwadrat ma szeroko¶æ $kwadrat->szeroko¶æ00 centymetrów.";

]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       Do wyra¿eñ bardziej skomplikowanych nale¿y u¿ywaæ sk³adni z³o¿onej.
      </simpara>
     </sect4>
     <sect4 id="language.types.string.parsing.complex">
      <title>Sk³adnia z³o¿ona</title>
      <simpara>
       Nazwa tej sk³adni nie pochodzi od skomplikowanego zapisu, tylko od
       mo¿liwo¶ci obs³ugi bardziej z³o¿onych wyra¿eñ.
     </simpara>
     <simpara>
      Za pomoc± tej sk³adni mo¿na umieszczaæ w ³añcuchach znaków ka¿d± warto¶æ
      istniej±c± w przestrzeni nazw. Odpowiednie wyra¿enie pisze siê tak, jakby
      mia³o ono znajdowaæ siê gdziekolwiek poza ³añcuchem znaków, a potem tylko
      umieszcza siê je miêdzy { i }. Poniewa¿ nie mo¿na cytowaæ "{", sk³adnia
      ta bêdzie prawid³owo rozpoznana tylko wtedy, kiedy $ znajduje siê
      bezpo¶rednio za {. (U¿yj "{\$" lub "\{$" aby uzyskaæ "{$"). Poni¿ej kilka
      przyk³adów:
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
$fajne = 'fantastyczne';
echo "To jest { $fajne}"; // nie dzia³a, zwraca: To jest { fantastyczne}
echo "To jest {$fajne}";  // dzia³a, zwraca: To jest fantastyczne
echo "Kwadrat ma szeroko¶æ {$kwadrat->szeroko¶æ}00 centimetrów."; 
echo "To dzia³a: {$arr[4][3]}";     

// Tak jest ¼le z tego samego powodu
// co $foo[bar] poza ³añcuchem. 
echo "Tak jest ¼le: {$arr[foo][3]}"; 

echo "Prawid³owo jest tak: {$arr['foo'][3]}";
echo "Mo¿na nawet pisaæ tak: {$obj->warto¶ci[3]->nazwa}";
echo "To jest warto¶æ zmiennej o nazwie $nazwa: {${$nazwa}}";
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>
    
    <sect3 id="language.types.string.substr">
     <title>Indeksowanie ³añcucha (ofsety)</title>
     <para>
      Dostêp do pojedynczego znaku ³añcucha jest mo¿liwy po podaniu jego
      indeksu (ofsetu) w nawiasach klamrowych, zaraz po nazwie zmiennej.
      Pierwszy znak w ³añcuchu ma indeks zero.
     </para>
     <note>
      <simpara>
       Dla zachowania kompatybilno¶ci wstecznej, nadal mo¿na u¿ywaæ nawiasów
       kwadratowych, jednak sk³adnia ta w PHP 4 uznana jest za przestarza³±.
      </simpara>
     </note>
     <para>
      <example>
       <title>Przyk³ady u¿ywania ³añcuchów znaków</title>
       <programlisting role="php">
<!-- TODO: either move these examples to a example section,
as with arrays, or distribute them under the applicable
sections. -->
<![CDATA[
<?php
/* Przypisywanie ³añcucha do zmiennej */
$str = "To jest ³añcuch znaków";

/* Do³±czanie innego ³añcucha */
$str = $str . " a to jego dalsza czê¶æ";

/* inny sposób do³±czania, ze znakiem nowej linii na koñcu */
$str .= " wraz ze znakiem nowej linii na koñcu.\n";

/* Ten ³añcuch bêdzie zawieraæ: "<p>Liczba: 9</p>" */
$num = 9;
$str = "<p>Liczba: $num</p>";

/* Natomiast tutaj bêdzie: "<p>Liczba: $num</p>" */
$num = 9;
$str = '<p>Liczba: $num</p>';

/* Pobranie pierwszego znaku ³añcucha  */
$str = 'To jest przyk³ad.';
$pierwszy = $str{0};

/* Ostatni znak ³añcucha */
$str = 'Dalsza czê¶æ przyk³adu.';
$ostatni = $str{strlen($str)-1};
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>Przydatne funkcje i operatory</title><!-- and operators -->
    <para>
     £añcuchy znaków ³±czy siê za pomoc± operatora '.' (kropka). Proszê
     pamiêtaæ, ¿e operator dodawania '+' nie wykonuje operacji ³±czenia
     ³añcuchów. Wiêcej informacji w rozdziale 
     <link linkend="language.operators.string">operatory ³añcuchowe</link>.
    </para>
    <para>
     PHP posiada mnóstwo funkcji operuj±cych na ³añcuchach znaków.
    </para>
    <simpara>
     Najwiêcej na ten temat w rozdziale 
     <link linkend="ref.strings">funkcje ³añcuchowe</link>. Poza tym obs³ugiwane
     s± wyra¿enia regularne dla potrzeb zaawnsowanych operacji znajd¼ i zamieñ
     (w dwóch odmianach: <link linkend="ref.pcre">Perl</link> oraz 
     <link linkend="ref.regex">POSIX extended</link>).
    </simpara>
    <simpara>
     S± tak¿e <link linkend="ref.url">funkcje obs³ugi ³añcuchów URL</link>,
     jak równie¿ funkcje szyfrowania i deszyfrowania ³añcuchów 
     (<link linkend="ref.mcrypt">mcrypt</link> oraz 
     <link linkend="ref.mhash">mhash</link>).
    </simpara>
    <simpara>
     Je¶li nadal nie znalaz³e¶ tego, czego potrzebujesz, byæ mo¿e pomog±
     ci <link linkend="ref.ctype">funkcje kontroli typu znaków</link>.
    </simpara>
   </sect2>
   <sect2 id="language.types.string.conversion">
    <title>Konwersja ³añcuchów znaków</title>

    <simpara>
     Je¶li ³añcuch znaków jest konwertowany na postaæ liczbow±, rezultat
     konwersji bêdzie zale¿a³ od poni¿szych czynników.
    </simpara>
    <simpara>
     £añcuch zostanie skonwertowany do typu <type>float</type>, je¶li zawiera
     znaki ".", "e" lub "E". W przeciwnym razie zostanie skonwertowany do typu
     <type>integer</type>.
    </simpara>
    <para>
     Warto¶æ liczbowa ³añcucha znaków zale¿y od pierwszych znaków tego
     ³añcucha. Je¶li ³añcuch zaczyna siê od poprawnej warto¶ci liczbowej,
     warto¶æ ta bêdzie u¿ywa przy konwersji. W przeciwnym razie zwrócona bêdzie
     warto¶æ 0 (zero). Poprawna warto¶æ liczbowa zaczyna siê od opcjonalnego
     znaku, po którym znajduje siê jedna, lub kilka cyfr (opcjonalnie
     zawieraj±ce przecinek dziesiêtny), po którym opcjonalnie znajduje siê
     eksponent. Eksponent jest to znak "e" lub "E", po którym nastêpuje jedna,
     lub wiêcej cyfr.
    </para>
    <simpara>
     Kiedy pierwszym wyra¿eniem jest ³añcuch znaków, typ zmiennej bêdzie zale¿a³
     od drugiego wyra¿enia.
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$foo = 1 + "10.5";              // $foo jest typu float (11.5)
$foo = 1 + "-1.3e3";            // $foo jest typu float (-1299)
$foo = 1 + "bob-1.3e3";         // $foo jest typu integer (1)
$foo = 1 + "bob3";              // $foo jest typu integer (1)
$foo = 1 + "10 ma³ych ¶winek";    // $foo jest typu integer (11)
$foo = 1 + "10 malutkich ¶winek"; // $foo jest typu integer (11)
$foo = "10.0 ¶winek " + 1;        // $foo jest typu float (11)
$foo = "10.0 ¶winek " + 1.0;      // $foo jest typu float (11)     
]]>
     </programlisting>
    </informalexample>
    <simpara>
     Wiêcej informacji na temat tej konwersji znajduje siê w podrêczniku Uniksa,
     na stronie polecenia strtod(3).
    </simpara>
    <para>
     Je¶li chcia³by¶ przetestowaæ który¶ z przyk³adów w tym rozdziale, mo¿esz
     je skopiowaæ i wkleiæ, a nastêpnie dodaæ poni¿sz± liniê i obserwowaæ
     rezultaty.
     <informalexample>
      <programlisting role="php">
<![CDATA[
echo "\$foo==$foo; jest typu " . gettype ($foo) . "<br>\n";
]]>
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>Tablice (array)</title>

   <para>
    Tablica w PHP jest obecnie uporz±dkowan± map±. Mapa jest typem, który
    przyporz±dkowuje <emphasis>warto¶ci</emphasis> do
    <emphasis>kluczy</emphasis>. Typ ten jest optymalizowany na wiele sposobów,
    wiêc mo¿na go u¿ywaæ jako typow± tablicê, albo listê (wektorow±),
    tablicê asocjacyjn± (która jest jedn± z implementacji mapy), s³ownik,
    kolekcjê, stos, kolejkê, i temu podobne. Poniewa¿ warto¶ci± tablicy mo¿e
    byæ inna tablica PHP, mo¿na tak¿e ³atwo symulowaæ drzewa.
   </para>
   <para>
    Wyjasnienie wspomnianych struktur wykracza poza problematykê tego
    podrêcznika,
    aczkolwiek poni¿ej uwzglêdniono conajmniej jeden przyk³ad na ka¿d± z nich.
    G³êbiej zainteresowanych czytelników odsy³amy do odpowiedniej literatury
    informatycznej. 
    <!-- like goodrich&tamassia: datastructures and algorithmes.
    Only, the subtitle is: in Java, and it's quite academic too -->
   </para>
   
   <sect2 id="language.types.array.syntax">
    <title>Sk³adnia</title>
    
    <sect3 id="language.types.array.syntax.array-func">
     <title>Tworzenie za pomoc± <function>array</function></title>
     <para>
      Tablicê mo¿na utworzyæ za pomoc± konstrukcji jêzykowej
      <function>array</function>. Argumentem tej konstrukcji s± rozdzielone
      przecinkiem pary 
      <literal><replaceable>klucz</replaceable> =&gt; <replaceable
      >warto¶æ</replaceable></literal>.
     </para>
     <para>
      <varname>klucz</varname> mo¿e byæ albo nieujemn± liczb± ca³kowit±,  
      <!-- 
      
      Negative integers are also allowed, however, IMO it's best to not 
      document that, or even disencourage it. 
      
      Why?
      
      First, because it is very tricky. But the real reason is that the key
      '-1' will be interpreted as a string, and not as a integer. Therefore,
      the usage
      
      "the -1'st value of \$arr is $arr[-1]" is ambigious. By the way,
      it results in a parse-error anyway, which is another argument for
      not documenting it.
      
      -Jeroen
      
      -->
      albo ³añcuchem znaków.
      Je¶li klucz jest standardow± reprezentacj± nieujemnej liczby ca³kowitej,
      zostanie zinterpretowany tak, jak jest (tzn. <literal>'8'</literal> 
      bêdzie zinterpretowane jako <literal>8</literal>, podczas gdy
      <literal>'08'</literal> bêdzie zinterpretowane jako
      <literal>'08'</literal>).
     </para>
     <para>
      Warto¶ci± mo¿e byæ cokolwiek.
     </para>
     <para>
      Je¶li pominiesz klucz, to jako klucz zostanie u¿yty najwy¿szy indeks
      ca³kowity + 1. Je¶li nie ma w ogóle indeksu ca³kowitego, to klucz bêdzie
      mia³ warto¶æ <literal>0</literal> (zero). Je¶li u¿yjesz klucza, do którego
      ju¿ wcze¶niej zosta³a przypisana warto¶æ, warto¶æ ta zostanie nadpisana.
     </para>
     
     <para>
      <synopsis>
array( <optional> <replaceable>klucz</replaceable> =&gt; </optional>
<replaceable>warto¶æ</replaceable>
     , ...
     )
// <replaceable>klucz</replaceable> jest albo ³añcuchem znaków, albo nieujemn±
                                    liczb± ca³kowit±
// <replaceable>warto¶æ</replaceable> mo¿e byæ dowolna
      </synopsis>
     </para>
    </sect3>
    
    <sect3 id="language.types.array.syntax.modifying">
     <title>Tworzenie i edytowanie sk³adni± nawiasów kwadratowych</title>
     <para>
      Mo¿na zmieniaæ istniej±c± tablicê jawnie ustawiaj±c warto¶ci.
     </para>
     <para>
      Robi siê to przez przypisanie warto¶ci do tablicy z podaniem klucza w
      nawiasach kwadratowych. Mo¿na tak¿e pomin±æ klucz i u¿yæ pustej pary
      nawiasów ("<literal>[]</literal>").
      <synopsis>
$arr[<replaceable>klucz</replaceable>] = <replaceable>warto¶æ</replaceable>;
$arr[] = <replaceable>warto¶æ</replaceable>;
// <replaceable>klucz</replaceable> jest albo ³añcuchem znaków, albo nieujemn±
                                    liczb± ca³kowit±
// <replaceable>warto¶æ</replaceable> mo¿e byæ dowolna
      </synopsis>
      Je¶li tablica <varname>$arr</varname> nie istnieje, zostanie stworzona.
      Jest to wiêc metoda na tworzenie tablic. Aby zmieniæ warto¶æ konkretnego
      klucza, po prostu przypisz now± warto¶æ do niego. Aby usun±æ parê
      klucz/warto¶æ, trzeba u¿yæ funkcji <function>unset</function>.
      
     </para>

    </sect3>
    

   </sect2><!-- end syntax -->
   
   <sect2 id="language.types.array.useful-funcs">
    <title>Przydatne funkcje</title>
    <para>
     Jest wiele przydatnych funkcji obs³ugi tablic, o czym wiêcej w rozdziale
     <link linkend="ref.array">Tablice</link>.
    </para>
    <note>
     <para>
      Funkcja <function>unset</function> pozwala kasowaæ komórki tablicy.
      W takiej sytuacji jednak tablica NIE zostanie zreindeksowana.
      <informalexample>
       <programlisting role="php">
<![CDATA[
$a = array( 1 => 'jeden', 2 => 'dwa', 3 => 'trzy' );
unset( $a[2] );
/* to tak, jakby utworzyæ tablicê:
   $a = array( 1 => 'jeden', 3 => 'trzy');
   ale NIE:
   $a = array( 1 => 'jeden', 2 => 'trzy');
*/   
]]>
      </programlisting>
     </informalexample>
     
     </para>    
    </note> 
    <para>
     Struktura kontrolna 
     <link linkend="control-structures.foreach">foreach</link> zosta³a stworzona
     specjalnie dla potrzeb tablic. Dziêki niej mo¿na ³atwo trawersowaæ tablicê.
    </para>
    
    
   </sect2>
   
   <sect2 id="language.types.array.donts">
    <title>Co wolno, a czego nie w tablicach?</title>

    <sect3 id="language.types.array.foo-bar">
     <title>Dlaczego zapis
     <literal>$foo[bar]</literal> jest niepoprawny?</title>
     <para>
      W starych skryptach mo¿na spotkaæ tak± sk³adniê:
      <informalexample>
       <programlisting role="php">
<![CDATA[
$foo[bar] = 'co¶';
echo $foo[bar];
// itd.
]]>
       </programlisting>
      </informalexample>
      Ten zapis jest niepoprawny, ale dzia³a. Dlaczego zatem jest niepoprawny?
      Powód jest to, co opisano w rozdziale <link
      linkend="language.types.array.syntax">sk³adnia</link>, ¿e pomiêdzy
      nawiasami kwadratowymi ('<literal>[</literal>' i '<literal>]</literal>')
      musi znajdowaæ siê wyra¿enie. Oznacza to, ¿e mo¿na u¿ywaæ czego¶ takiego:
      <informalexample>
       <programlisting role="php">
<![CDATA[
echo $arr[ foo(true) ];        
]]>
       </programlisting>
      </informalexample>
      Jest to przyk³ad u¿ycia warto¶ci zwracanej przez funkcjê jako indeksu
      tablicy. PHP zna te¿ sta³e, wiêc mo¿na spotkaæ zastosowanie      
      <literal>E_*</literal>.      

      <informalexample>
       <programlisting role="php">
<![CDATA[
$opis_b³êdu[E_ERROR] = "Wyst±pi³ powa¿ny b³±d";
$opis_b³êdu[E_WARNING] = "PHP wys³a³o ostrze¿enie";
$opis_b³êdu[E_NOTICE] = "To jest tylko nieformalna uwaga";
]]>
       </programlisting>
      </informalexample>
      Proszê pamiêtaæ, ¿e <literal>E_ERROR</literal> jest tak¿e wa¿nym
      identyfikatorem, tak jak <literal>bar</literal> w pierwszym przyk³adzie.
      Ale ostatni przyk³ad znaczy to samo co:
      <informalexample>
       <programlisting role="php">
<![CDATA[
$opis_b³êdu[1] = "Wyst±pi³ powa¿ny b³±d";
$opis_b³êdu[2] = "PHP wys³a³o ostrze¿enie";
$opis_b³êdu[8] = "To jest tylko nieformalna uwaga";
]]>
       </programlisting>
      </informalexample>
      poniewa¿ <literal>E_ERROR</literal> znaczy to samo co
      <literal>1</literal>, itd.
     </para>
     <para>
      W takiem razie, jak to mo¿liwe, ¿e <literal>$foo[bar]</literal> dzia³a?
      To dzia³a, poniewa¿ <literal>bar</literal>, zgodnie z jego zapisem
      powinien byæ sta³±. Jednak¿e w tym przypadku nie instnieje sta³a o nazwie
      <literal>bar</literal>. PHP teraz zak³ada, ¿e masz na my¶li
      <literal>bar</literal> literalnie, czyli jako ³añucuch
      <literal>"bar"</literal>, tylko ¿e zapomnia³e¶ napisaæ cudzys³owów.
     </para>
     <sect4>
      <title>Wiêc dlaczego tak jest ¼le?</title>
      <para>
       Kiedy¶ w przysz³o¶ci grupa PHP mo¿e chcieæ dodaæ jeszcze jedn± sta³± lub
       s³owo kluczowe i wtedy bêdziesz mia³ k³opot. Dla przyk³adu, obecnie
       ju¿ nie mo¿na u¿ywaæ s³ów <literal>empty</literal> i
       <literal>default</literal>, gdy¿ s± to specjalne s³owa kluczowe.
       <!-- <jeroen>hmm... i'm doubting this myself. Finish it if you like</jeroen>
       But probably 
       the most threatening
       thing is yourself, or whoever will maintain the script. You'll 
       maybe get very strange behaviour, and 
       -->
      </para>
      <para>
       Poza tym, je¶li dot±d argumenty nie przekonuj± ciê: ta sk³adnia jest
       po prostu odrzucona i kiedy¶ mo¿e przestaæ dzia³aæ.
      </para>
      <note>
       <simpara>
        Po prze³±czeniu <link linkend="function.error-reporting"
        >error_reporting</link> na <literal>E_ALL</literal>, zobaczysz, ¿e
        PHP generuje ostrze¿enie, kiedy tylko powy¿sza sk³adnia zostanie
        u¿yta. Tak samo generowane bêd± ostrze¿enia odno¶nie innych odrzuconych
        "udogodnieñ". (umie¶æ w swoim skrypcie liniê 
        <literal>error_reporting(E_ALL);</literal>)
       </simpara>
      </note>
      <note>
       <simpara>
        Sk³adnia ta jest dozwolona wewn±trz ³añcucha znaków w podwójnych
        cudzys³owach. Wiêcej szczegó³ów na ten temat w rozdziale
        <link linkend="language.types.string.parsing"
        >parsowanie zmiennych</link>.
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>Przyk³ady</title>
    <para>
     Typ tablicowy w PHP jest bardzo ró¿norodny, co prezentuj± poni¿sze
     przyk³ady.
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
// to:
$a = array( 'kolor' => 'czerowny'
          , 'smak' => 's³odki'
          , 'kszta³t' => 'okr±g³y'
          , 'nazwa'  => 'jab³ko'
          ,            4        // kluczem bêdzie 0
          );

// znaczy dok³adnie to samo, co to:
$a['kolor'] = 'czerwony';
$a['smak'] = 's³odki';
$a['kszta³t'] = 'okr±g³y';
$a['nazwa'] = 'jab³ko';
$a[]        = 4;        // kluczem bêdzie 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// znaczy to samo co: array( 0 => 'a' , 1 => 'b' , 2 => 'c' ),
// albo pro¶ciej: array('a', 'b', 'c')
]]>
       </programlisting>
      </informalexample>
     </para>
    
    <example>
     <title>U¿ycie array()</title>
     <programlisting role="php">
<![CDATA[
// tablica jako mapa w³a¶ciwo¶ci
$mapa = array( 'version'    => 4
            , 'OS'         => 'Linux'
            , 'lang'       => 'polski'
            , 'short_tags' => true
            );
            
// tylko klucze liczbowe
$array = array( 7
              , 8
              , 0
              , 156
              , -10
              );
// znaczy to samo co array( 0 => 7, 1 => 8, ...)

$zmiany = array(            10 // klucz = 0
                  , 5    =>  6
                  , 3    =>  7 
                  , 'a'  =>  4
                  ,         11 // klucz = 6 (najwy¿szy indeks ca³kowity by³ 5)
                  , '8'  =>  2 // klucz = 8 (ca³kowity!)
                  , '02' => 77 // klucz = '02'
                  , 0    => 12 // warto¶æ 10 bêdzie nadpisana przez 12
                  );
                  
// pusta tablica
$pusta = array();         
]]>
<!-- TODO example of
- mixed keys
- overwriting keys
- integer keys as string
- using vars/functions as key/values
- mixed skipping
-->
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>Kolekcja</title>
     <programlisting role="php">
<![CDATA[
$kolory = array('czerwony','niebieski','zielony','¿ó³ty');

foreach ( $kolory as $kolor ) {
    echo "Czy lubisz $kolor?\n";
}

/* wynik:
Czy lubisz czerwony?
Czy lubisz niebieski?
Czy lubisz zielony?
Czy lubisz ¿ó³ty?
*/
]]>
     </programlisting>
    </example>
    
    <para>
     Obecnie nie jest mo¿liwa zmiana warto¶ci w tabeli przy u¿yciu takiej pêtli. 
      <!--
       Should be made possible, if you write:
       foreach ( $colors as &$color )
      
       See bug#3074
      -->
     Mo¿na to jednak rozwi±zaæ tak: 
     <example id="language.types.array.examples.changeloop">
      <title>Collection</title>
      <programlisting role="php">
<![CDATA[
foreach ($kolory as $klucz => $kolor) {
    // nie dzia³a:
    //$kolor = strtoupper($kolor);
    
    // dzia³a:
    $kolory[$klucz] = strtoupper($kolor);
}
print_r($kolory);

/* wynik:
Array
(
    [0] => CZERWONY
    [1] => NIEBIESKI
    [2] => ZIELONY
    [3] => ¯Ó£TY
)
*/
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Poni¿szy przyk³ad tworzy tablicê z pierwszym kluczem 1.
     <example>
      <title>Pierwszy klucz 1</title>
      <programlisting role="php">
<![CDATA[
$kwarta³  = array(1 => 'Styczeñ', 'Luty', 'Marzec');
print_r($kwarta³);

/* wynik:
Array 
(
    [1] => 'Styczeñ'
    [2] => 'Luty'
    [3] => 'Marzec'
)
*/
]]>   
      </programlisting>
     </example>
    </para>
    <example>
     <title>Wype³nianie prawdziwej tablicy</title>
     <programlisting role="php">
<![CDATA[
// wype³nij tablicê zawarto¶ci± folderu
$uchwyt = opendir('.');
while ($plik = readdir($uchwyt)) 
{
    $pliki[] = $plik;
}
closedir($uchwyt); 
]]>
     </programlisting>
    </example>
    <para>
     Dane w tablicach s± uporz±dkowane. Ich kolejno¶æ mo¿e byæ zmieniona za
     pomoc± ró¿norodnych funkcji sortuj±cych. Wiêcej na ten temat w rozdziale
     <link linkend="ref.array">tablice</link>.
    </para>
    <example>
     <title>Sortowanie tablic</title>
     <programlisting role="php">
<![CDATA[
sort($pliki);
print_r($pliki);
]]>
     </programlisting>
    </example>
    <para>
     Poniewa¿ warto¶ci± tablicy mo¿e byæ wszystko, mo¿e te¿ ni± byæ inna
     tablica. Mo¿na w ten sposób tworzyæ tablice rekursywne i wielowymiarowe.
    </para>
    <example>
     <title>Tablice rekursywne i wielowymiarowe</title>
     <programlisting role="php">
<![CDATA[
$owoce = array ( "owoce"  => array (   "a" => "pomarañcza"
                                     , "b" => "banan"
                                     , "c" => "jab³ko"
                                     )
                , "liczby" => array ( 1
                                     , 2
                                     , 3
                                     , 4
                                     , 5
                                     , 6
                                     )
                , "dziury"   => array (      "pierwsza"
                                     , 5 => "druga"
                                     ,      "trzecia"
                                     )
                );
]]>
<!-- quite duplicate...
$a = array(
     "apple"  => array(
          "color"  => "red",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "orange"  => array(
          "color"  => "orange",
          "taste"  => "tart",
          "shape"  => "round"
     ),
     "banana"  => array(
          "color"  => "yellow",
          "taste"  => "paste-y",
          "shape"  => "banana-shaped"
     )
);
-->
     </programlisting>
    </example>

   </sect2>
   
   <!-- TODO
   <sect2>
    <title>Misc</title>
   
   </sect2>
   
   - example multi-dim with $arr[bla][bla] syntax
   - converting to array
   - warning about references
   - note that assigning is copy (usually...)
   
   
   -->  

<!-- there is no such thing as multi/singel dim arrays (at least in PHP4) 
   <sect2 id="language.types.array.single-dim">
    <title>Single Dimension Arrays</title>

    <para>
     PHP supports both scalar and associative arrays. In fact, there
     is no difference between the two.  You can create an array using
     the 
     
     <function>list</function> 
     
     Nope
     
     
     
     
     or <function>array</function>
     functions, or you can explicitly set each array element value.
     <informalexample>
      <programlisting role="php"> 
$a[0] = "abc"; 
$a[1] = "def"; 
$b["foo"] = 13;
      </programlisting>
     </informalexample>
    </para>
    <para>
     You can also create an array by simply adding values to the
     array. When you assign a value to an array variable using empty
     brackets, the value will be added onto the end of the array.
     <informalexample>
      <programlisting role="php"> 
$a[] = "hello"; // $a[2] == "hello"
$a[] = "world"; // $a[3] == "world" 
      </programlisting>
     </informalexample>
    </para>
    <para>
     Arrays may be sorted using the <function>asort</function>,
     <function>arsort</function>, <function>ksort</function>,
     <function>rsort</function>, <function>sort</function>,
     <function>uasort</function>, <function>usort</function>, and
     <function>uksort</function> functions depending on the type of
     sort you want.
    </para>
    <para>
     You can count the number of items in an array using the
     <function>count</function> function.
    </para>
    <para>
     You can traverse an array using <function>next</function> and
     <function>prev</function> functions.  Another common way to
     traverse an array is to use the <function>each</function>
     function.
    </para>
   </sect2>

   <sect2 id="language.types.array.multi-dim">
    <title>Multi-Dimensional Arrays</title>

    <para>
     Multi-dimensional arrays are actually pretty simple.  For each
     dimension of the array, you add another [key] value to the end:
     <informalexample>
      <programlisting role="php"> 
$a[1]      = $f;               # one dimensional examples
$a["foo"]  = $f;   

$a[1][0]     = $f;             # two dimensional
$a["foo"][2] = $f;             # (you can mix numeric and associative indices)
$a[3]["bar"] = $f;             # (you can mix numeric and associative indices)

$a["foo"][4]["bar"][0] = $f;   # four dimensional!
      </programlisting>
     </informalexample>
    </para>
    <para>
     In PHP 3 it is not possible to reference multidimensional arrays
     directly within strings. For instance, the following will not
     have the desired result:
     <informalexample>
      <programlisting role="php"> 
$a[3]['bar'] = 'Bob';
echo "This won't work: $a[3][bar]";
      </programlisting>
     </informalexample>
     In PHP 3, the above will output <computeroutput>This won't work:
     Array[bar]</computeroutput>. The string concatenation operator,
     however, can be used to overcome this:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "This will work: " . $a[3]['bar'];
      </programlisting>
     </informalexample>
    </para>
    <para>
     In PHP 4, however, the whole problem may be circumvented by
     enclosing the array reference (inside the string) in curly
     braces:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "This will work: {$a[3][bar]}";
      </programlisting>
     </informalexample>
    </para>
    <para>
     You can "fill up" multi-dimensional arrays in many ways, but the
     trickiest one to understand is how to use the
     <function>array</function> command for associative arrays.  These
     two snippets of code fill up the one-dimensional array in the
     same way:
     <informalexample>
      <programlisting role="php"> 
# Example 1:

$a["color"]	= "red";
$a["taste"]	= "sweet";
$a["shape"]	= "round";
$a["name"]	= "apple";
$a[3]		= 4;

# Example 2:
$a = array(
     "color" => "red",
     "taste" => "sweet",
     "shape" => "round",
     "name"  => "apple",
     3       => 4
);
      </programlisting>
     </informalexample>
    </para>
    <para>
     The <function>array</function> function can be nested for
     multi-dimensional arrays:
     <informalexample>
      <programlisting role="php"> 
&lt;?php
$a = array(
     "apple"  => array(
          "color"  => "red",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "orange"  => array(
          "color"  => "orange",
          "taste"  => "tart",
          "shape"  => "round"
     ),
     "banana"  => array(
          "color"  => "yellow",
          "taste"  => "paste-y",
          "shape"  => "banana-shaped"
     )
);

echo $a["apple"]["taste"];    # will output "sweet"
?>
      </programlisting>
     </informalexample>
    </para>

   </sect2>
   
   -->
  </sect1>

  <sect1 id="language.types.object">
   <title>Obiekty (object)</title>

   <sect2 id="language.types.object.init">
    <title>Inicjowanie obiektów</title>

    <para>
     Aby zainicjowaæ obiekt, nale¿y u¿yæ s³owa kluczowego <literal>new</literal>
     aby przypisaæ instancjê obiektu do zmiennej.

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function do_foo()
    {
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Pe³na informacja na ten temat znajduje siê w rozdziale <link
     linkend="language.oop">Klasy i Obiekty</link>.
    </simpara>

   </sect2>
  </sect1>

  <sect1 id="language.types.resource">
   <title>Identyfikator zasobów (resource)</title>
    
    <para>
     Identyfikator zasobów jest specjaln± zmienn±, przechowywuj±c± odno¶nik
     do zewnêtrznego ¼ród³a zasobów. Identyfikatory zasobów s± tworzone
     i wykorzystywane przez specjalne funkcje. Zobacz
     <link linkend="resource">suplement</link> z list± tych funkcji i
     powi±zanych z tym typów zasobów.     
    </para>
    
    <note>
     <simpara>
      Identyfikator zasobów zosta³ wprowadzony w PHP 4.
     </simpara>
    </note>

    <sect2 id="language.types.resource.self-destruct">
     <title>Zwalnianie zasobów</title>
    
    <para>
     Dziêki systemowi kontroli zasobów, wprowadzonemu w opracowanym przez Zend
     silniku skryptowym PHP 4, automatycznie wykrywana jest sytuacja, kiedy
     nie ma ju¿ odno¶ników do zasobu (tak jak w Java). W takie sytuacji zasoby
     systemowe u¿ywane do tego zasobu zostaj± zwolnione przez destruktor
     zasobów. Dlatego nie jest
     konieczne, aby zwalniaæ pamiêæ rêcznie za pomoc± funkcji typu free_result.
     <note>
      <simpara>
       Wyj±tkiem s± tu sta³e po³±czenia z serwerami baz danych, które
       <emphasis>nie</emphasis> s±
       niszczone przez destruktor zasobów. Zobacz te¿ <link 
       linkend="features.persistent-connections">sta³e po³±czenia</link>.
      </simpara>
     </note>
    </para>
    
   </sect2>
  </sect1>
    
  <sect1 id="language.types.null">
   <title>Typ NULL (null)</title>
    
   <para>
    Specjalna warto¶æ &null; oznacza, ¿e zmienna nie przechowuje ¿adnej
    warto¶ci. &null; jest jedyn± mo¿liw± warto¶ci± typu <type>NULL</type>.
   </para>
    <note>
     <simpara>
      Typ <type>NULL</type> zosta³ wprowadzony w PHP 4.
     </simpara>
    </note>
    
   <sect2 id="language.types.null.syntax">
    <title>Sk³adnia</title>
    <para>
     Jest tylko jedna warto¶æ, jak± mo¿e mieæ typ &null; i jest ni± s³owo
     kluczowe &null;. Wielko¶æ liter s³owa &null; nie gra roli.
     <informalexample>
      <programlisting role="php">
$var = NULL;       
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>Wykorzystywanie typów danych</title>

   <simpara>
    PHP nie wymaga (a nawet nie obs³uguje) jawnej deklaracji typów zmiennych.
    Typ zmiennej jest okre¶lany na podstawie kontekstu, w jakim ta zmienna jest
    u¿ywana. Oznacza to m.in., ¿e przy przypisaniu ³añcucha znaków do zmiennej
    <parameter>var</parameter>, zmienna ta zmienia swój typ na string. Je¶li
    potem zostanie przypisana warto¶æ ca³kowita, <parameter>var</parameter>
    zmienia swój typ na integer.
   </simpara>
   <para>
    Przyk³adem automatyczniej konwersji typów jest operator dodawania '+'.
    Je¶li którykolwiek z operandów jest typu float, to wszystkie operandy
    zostan± potraktowane jako liczby float i taki te¿ typ bêdzie zwrócony jako
    wynik dodawania. W przeciwnym razie operandy zostan± potraktowane jako
    liczby ca³kowite i wynikiem tak¿e bêdzie liczba ca³kowita. Proszê jednak
    zwróciæ uwagê, ¿e dzia³anie to NIE zmienia typów samych operandów; zmienia
    jedynie sposób ich interpretacji przez operator dodawania.
    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo jest ³añcuchem znaków (ASCII 48)
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo is the string "1" (ASCII 49)
-->
$foo += 2;   // $foo jest liczb± ca³kowit± (2)
$foo = $foo + 1.3;  // $foo jest liczb± zmiennoprzecinkow± (3.3)
$foo = 5 + "10 Ma³ych ¶winek"; // $foo jest liczb± ca³kowit± (15)
$foo = 5 + "10 Wiêkszych ¶winek";     // $foo jest liczb± ca³kowit± (15)
<!--

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Je¶li dwa ostanie przyk³ady wydaj± siê tobie dziwne, zajrzyj do rozdzia³u
    <link linkend="language.types.string.conversion">Konwersja ³añcuchów
    znaków</link>.
   </simpara>
   <simpara>
    Je¶li chcesz skonwertowaæ zmienn± z jednego typu do innego, u¿yj
    <link linkend="language.types.typecasting">rzutowania typów</link>. Aby
    zmieniæ typ zmiennej, u¿yj <function>settype</function>.
   </simpara>
   <para>
    Je¶li chcesz przetestowaæ którykolwiek z przyk³adów z tego rozdzia³u, mo¿esz
    u¿yæ funkcji <function>var_dump</function>.
   </para>
   <note>
    <para>
     Efekty automatycznej konwersji do tablicy s± aktualnie nieokre¶lone.
     <informalexample>
      <programlisting role="php">
$a = 1;       // $a jest liczb± ca³kowit±
$a[0] = "f";  // $a staje siê tablic±, $a[0] zawiera "f"
      </programlisting>
     </informalexample>
    </para>
    <para>
     W powy¿szym przyk³adzie wydawaæ siê mo¿e oczywiste, ¿e $a stanie siê
     tablic± z pierwszym elementem "f"; rozwa¿ jednak poni¿szy przyk³ad:
     <informalexample>
      <programlisting role="php">
$a = "1";     // $a jest ³añcuchem znaków
$a[0] = "f";  // Co z ofsetami ³añcuchów? Co siê dzieje?
      </programlisting>
     </informalexample>
    </para>
    <para>
     Poniewa¿ PHP obs³uguje indeksowanie ³añcuchów za pomoc± ofsetów, u¿ywaj±c
     tej samej sk³adni co indeksowanie tablic, powy¿szy przyk³ad powoduje
     problem: czy $a powinno zostaæ tablic± z pierwszym elementem o warto¶ci
     "f", czy raczej "f" powinno zostaæ pierwszym znakiem ³añcucha $a?
    </para>
    <para>
     Z tego w³a¶nie powodu, od PHP 3.0.12 i PHP 4.0b3-RC4, efekt automatycznej
     konwersji pozostaje nieokre¶lony. Dyskusje odno¶nie tego problemu trwaj±.
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>Rzutowanie typów</title>

    <para>
     Rzutowanie typów w PHP dzia³a mniej wiêcej tak jak w jêzyku C: nazwa
     docelowego typu umieszczana jest w nawiasach przed nazw± zmiennej, która
     ma byæ zrzutowana.
     <informalexample>
      <programlisting role="php">
$foo = 10;   // $foo jest liczb± ca³kowit±
$bar = (float) $foo;   // $bar jest typu float (zmiennoprzecinkowego)
      </programlisting>
     </informalexample>
    </para>
    <para>
     Operatory rzutowania s± nastêpuj±ce:
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - rzutowanie do liczb ca³kowitych</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - rzutowanie do typu boolowskiego</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - rzutowanie do liczb
       zmiennoprzecinkowych</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - rzutowanie do ³añcucha znaków</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - rzutowanie do tablicy</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - rzutowanie do obiektu</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <note>
     <simpara>
      Zamiast rzutowaæ zmienn± do ³añcucha znaków operatorem, mo¿na te¿ umie¶ciæ
      zmienn± w cudzys³owie podwójnym. 
      <!-- TODO: example -->
     </simpara>
    </note>
     
    <para>
     Wewn±trz nawiasów operatora rzutowania mog± znajdowaæ siê tabulacje i
     spacje, wiêc poni¿sze przyk³ady s± funkcjonalnie identyczne:
     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>
    <para>
     Efekt rzutowania pomiêdzy niektórymi typami nie zawsze daje spodziewany
     wynik. Wiêcej informacji o skutkach rzutowania w rozdzia³ach:
    
     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">Konwersja
       do typu boolowskiego</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">Konwersja do
       liczb ca³kowitych</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.float.casting">Converting to 
        float</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">Converting to 
        string</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">Converting to 
        array</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">Converting to 
        object</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">Converting to 
        resource</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to 
        &null;</link></simpara>
      </listitem>
      -->
     </itemizedlist>
    
    </para>
    <para>
     <!-- TODO: move to 'converting to string' -->
     Przy rzutowaniu lub wymuszeniu konwersji z tablicy do ³añcucha znaków,
     rezultatem bêdzie s³owo <literal>Array</literal>. Przy rzutowaniu lub
     wymuszeniu konwersji z obiektu do ³añcucha znaków, rezultatem bêdzie
     s³owo <literal>Object</literal>. 
     
     <!-- not with my PHP, not even a notice... maybe in PHP3? 
     Does someone know? 
     
     In both cases a warning will
     be issued. -->
    </para>
    <para>
     Przy rzutowaniu ze zmiennej skalarnej lub ³añcucha do tablicy, warto¶æ
     zmiennej stanie siê pierwszym elementem tablicy:
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$arr = (array) $var;
echo $arr[0];  // wynik: 'ciao'  
      </programlisting>
     </informalexample>
    </para>
    <para>
     Przy rzutowaniu ze zmiennej skalarnej lub ³añcucha do obiektu, warto¶æ
     zmiennej stanie siê w³a¶ciwo¶ci± obiektu; w³a¶ciwo¶æ ta bêdzie nazywaæ
     siê 'scalar':
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$obj = (object) $var;
echo $obj-&gt;scalar;  // wynik: 'ciao'
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
