<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: 1.28 Maintainer: leszek Status: ready -->
<!-- $Revision: 1.11 $ -->
 <chapter id="functions">
  <title>Funkcje</title>

  <sect1 id="functions.user-defined">
   <title>Funkcje zdefiniowane przez u¿ytkownika</title>
 
   <para>
    Funkcja mo¿e byæ zdefiniowana u¿ywaj±c sk³adni takiej jak poni¿sza:
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
function foo ($arg_1, $arg_2, ..., $arg_n)
{
    echo "Przyk³adowa funkcja.\n";
    return $retval;
}
]]>
     </programlisting>
    </informalexample>
   </para>
   
   <!--
    
    status of func(const $param) ?
    zend doesn't care at all whether or not you specify it.
    I've never seen it before... what's its use? (or was...)
    
    -->
     
   <simpara>
    Dowolny poprawny kod PHP mo¿e siê pojawiæ wewn±trz funkcji, tak¿e
    definicje innych funkcji i  <link linkend="keyword.class">klas</link>.
   </simpara>
   <simpara>
    W PHP 3, funkcje musz± byæ zdefiniowane przed odwo³aniem do nich. W PHP 4
    nie ma takiego wymagania.
   </simpara>
   <simpara>
    PHP nie obs³uguje przeci±¿ania funkcji. Nie jest tak¿e mo¿liwa
    od-definiowanie lub przedefiniowanie wcze¶niej zadeklarowanych funkcji.
   </simpara>
   <simpara>
    PHP 3 nie obs³uguje funkcji o zmiennej liczbie argumentów, ale obs³uguje
    domy¶lne argumenty (zobacz rozdzial <link
    linkend="functions.arguments.default">Warto¶ci domy¶lne argumentów
    </link> aby uzyskaæ wiêcej informacji). PHP 4 obs³uguje jedne i drugie:
    zobacz <link
    linkend="functions.variable-arg-list">Listy argumentów o zmiennej d³ugo¶ci
    </link> i opisy funkcji
    <function>func_num_args</function>,
    <function>func_get_arg</function>, i
    <function>func_get_args</function> aby uzyskaæ wiêcej informacji.
   </simpara>

  </sect1>
 
  <sect1 id="functions.arguments">
   <title>Argumenty funkcji</title>
 
   <simpara>
    Informacje mog± byæ przekazywane do funkcji przez listê argumentów, która
    jest separowan± przecinkami list± zmiennych i/lub sta³ych.
   </simpara> 
   <para>
     PHP obs³uguje przekazywanie argumentów przez warto¶æ (domy¶lnie), 
     <link linkend="functions.arguments.by-reference">przez referencjê </link>,
     i <link linkend="functions.arguments.default">warto¶ci domy¶lne
     argumentów</link>. Listy argumentów o zmiennej d³ugo¶ci s± obs³ugiwane
     tylko w PHP 4 i nowszych; zobacz rozdzia³ <link
     linkend="functions.variable-arg-list">Listy argumentów o zmiennej
     d³ugo¶ci</link> i opisy funkcji
     <function>func_num_args</function>,
     <function>func_get_arg</function>, i
     <function>func_get_args</function> aby uzyskaæ wiêcej informacji. Podobny
     efekt mo¿e byæ uzyskany w PHP 3 przez przekazywanie tablicy argumentów do
     funkcji:
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
function pobiera_tablice($wejscie)
{
    echo "$wejscie[0] + $wejscie[1] = ", $wejscie[0]+$wejscie[1];
}
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <sect2 id="functions.arguments.by-reference">
    <title>Przekazywanie argumentów przez referencjê</title>
 
    <simpara>
     Domy¶lnie, argumenty funkcji s± przekazywane przez warto¶æ (a wiêc je¶li
     zmienisz warto¶æ argumentu wewn±trz funkcji, nie zmieni siê ona poza
     funkcj±). Je¶li chcesz pozwoliæ funkcji na modyfikacjê swoich argumentów,
     musisz przekazaæ je przez referencjê.
    </simpara>
    <para>
     Je¶li chcesz, aby argumenty by³y zawsze przekazywane przez referencjê,
     przed nazw± zmiennej w definicji funkcji wstaw znak ampersand (&amp;):
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
function dodaj_cos_extra(&$string)
{
    $string .= 'i co¶ extra.';
}
$str = 'To jest string, ';
dodaj_cos_extra($str);
echo $str;    // wy¶wietla 'To jest string string, i co¶ extra.'
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
 
   <sect2 id="functions.arguments.default">
    <title>Warto¶ci domy¶lne argumentów</title>
 
    <para>
     Funkcja mo¿e definiowaæ, podobnie jest w C++,  warto¶ci domy¶lne dla
     argumentów skalarnych:
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
function robkawe ($typ = "cappucino")
{
    return "Robiê kubek $type.\n";
}
echo robkawe ();
echo robkawe ("espresso");
]]>
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     Powy¿szy kawa³ek kody wy¶wietli:
 
     <screen>
Robiê kubek cappucino.
Robiê kubek espresso.
     </screen>
    </para>
 
    <simpara>
     Domy¶lna warto¶æ musi byæ sta³ym wyra¿eniem, nie (na przyk³ad) zmienn±
     lub cz³onkiem klasy.
    </simpara>
    <para>
     Zauwa¿, ¿e u¿ywaj±c domy¶lnych argumentów, argumenty zawieraj±ce warto¶ci
     domy¶lne powinny byæ po prawej stronie tych nie zawieraj±cych warto¶ci
     domy¶lnych; w przeciwnym przypadku funkcja mo¿e nie dzia³aæ tak jak siê
     tego spodziewa³e¶. Zobacz to na poni¿szym przyk³adzie:
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
function robjogurt ($typ = "acidophilus", $smak)
{
    return "Robiê miskê $typ $smak.\n";
}
 
echo robjogurt ("malinowy");   // nie dzia³a tak jak siê spodziewali¶my
]]>
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     Powy¿sza funkcja wy¶wietla:
 
     <screen>
Warning: Missing argument 2 in call to robjogurt() in 
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Robiê miskê malinowy .
     </screen>
    </para>
 
    <para>
     Porównaj powy¿szy przyk³ad z tym:
 
     <informalexample>
      <programlisting role="php">
<![CDATA[
function robjogurt ($smak, $typ = "acidophilus")
{
    return "Robiê miskê $type $flavour.\n";
}
 
echo robjogurt ("malinowy");   // dzia³a tak jak siê spodziewali¶my
]]>
      </programlisting>
     </informalexample>
    </para>
 
    <para>
     Powy¿szy kod wy¶wietla:
 
     <screen>
Robiê miskê acidophilus malinowy.
     </screen>
    </para>

   </sect2>

   <sect2 id="functions.variable-arg-list">
    <title>Listy argumentów o zmiennej d³ugo¶ci</title>
	
    <simpara>
     PHP 4 obs³uguje listy o zmiennej d³ugo¶ci w funkcjach zdefiniowanych
     przez u¿ytkownika. Jest naprawdê prostê przy u¿yciu funkcji
     <function>func_num_args</function>,
     <function>func_get_arg</function> i
     <function>func_get_args</function>.
    </simpara>

    <simpara>
     Nie wymagana jest ¿adna specjalna sk³adnia. Listy argumentów mog± byæ
     ci±gle jawnie podane przy definicji funkcji i bêd± siê zachowywaæ
     normalnie.
    </simpara>

   </sect2>

  </sect1>
 
  <sect1 id="functions.returning-values">
   <title>Zwracane warto¶ci</title>
 
   <para>
    Warto¶ci s± zwracane przy u¿yciu opcjonalnej instrukcji return. Mo¿e byæ
    zwracany dowonlny typ, w³±czaj±c w to tablice i obiekty. Spowoduje to
    natychmiastowe zakoñczenie dzia³ania funkcji i przekazanie kontroli do
    linii, z której by³a wywo³ana. Wiêcej informacji w opisie
    <function>return</function>.
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
function kwadrat ($num)
{
    return $num * $num;
}
echo kwadrat (4);   // wy¶wietla '16'.
]]>
     </programlisting>
    </informalexample>
   </para>
      
   <para>
    Nie mo¿esz zwracaæ zwracaæ wielu warto¶ci z funkcji, ale podobne efekty
    mog± byæ uzyskane przez zwracanie listy.
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
function maleLiczby()
{
    return array (0, 1, 2);
}
list ($zero, $jeden, $dwa) = maleLiczby();
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Aby funkcja zwraca³a referencjê, musisz u¿yæ operatora referencji &amp; i
    w deklaracji funkcji i przy przypisywaniu zwracanej warto¶ci do zmiennej:
    <informalexample>
     <programlisting role="php">
<![CDATA[
function &zwrocReferencje()
{
    return $jakasref;
}

$nowaref =& zwrocReferencje();
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Wiêcej informacji na temat referencji w rozdziale
    <link linkend="language.references">References Explained</link>.
   </simpara>
  </sect1>
 
  <sect1 id="functions.old-syntax">
   <title><literal>old_function</literal></title>
 
   <simpara>
    Instrukcja <literal>old_function</literal> pozwala na zadeklarowanie
    funkcji korzystaj±c ze sk³adni takiej samej jak w PHP/FI2 (tylko ¿e
    zamiast 'function' musisz u¿yæ 'old_function'.
   </simpara>
   <simpara>
    Jest to niezalecana opcja i powinna byæ u¿ywana tylko przez konwerter
    PHP/FI2->PHP 3.
   </simpara>
   <warning>
    <para>
     Funkcje zadekladowane jako <literal>old_function</literal> nie mog± byæ
     wywo³ane z kodu wewnêtrznego PHP. Miêdzy innymi oznacza to, ¿e nie mo¿esz
     u¿ywaæ ich z takich funkcji jak <function>usort</function>,
     <function>array_walk</function> i <function>register_shutdown_function
     </function>. Mo¿esz obej¶æ to ograniczenie przez napisanie interfejsu (w
     normalnej dla PHP 3 postaci) wywo³uj±cego <literal>old_function</literal>.
    </para>
   </warning>

  </sect1>

  <sect1 id="functions.variable-functions">
   <title>Zmienne funkcje</title>

   <para>
    PHP obs³uguje koncepcjê zmiennych funkcji. Oznacza to, ¿e je¶li po nazwie
    zmiennej wystêpuj± nawiasy, PHP bêdzie szuka³o funkcji o nazwie bêd±cej
    warto¶ci± zmiennej i bêdzie próbowa³o wywo³aæ j±. Miêdzy innymi mo¿e byæ
    to u¿yte do implementacji funkcji callback, tablicy funkcji itp.
   </para>
   <para>
    Zmienne funkcje nie bêd± dzia³aæ z elementami sk³adowymi jêzyka, takimi
    jak <function>echo</function>, <function>unset</function>,
    <function>isset</function>, <function>empty</function>,
    <function>include</function> i <function>print</function>.
   </para>
   <para>
    <example>
     <title>Przyk³ad zmiennej funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
    echo "W foo()<br>\n";
}

function bar($arg = '')
{
    echo "W bar(); argumentem jest '$arg'.<br>\n";
}

$func = 'foo';
$func();
$func = 'bar';
$func('test');
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Zobacz równie¿ <link linkend="language.variables.variable">
    variable variables</link> i <function>function_exists</function>.
   </para>

  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
