<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: n/a Maintainer: pirate Status: ready -->
<!-- $Revision$ -->
 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Funkcje</title>

  <sect1 xml:id="functions.user-defined">
   <title>Funkcje definiowane przez u¿ytkownika</title>
 
   <para>
    Funkcja mo¿e byæ definiowana przy u¿yciu nastêpuj±cej sk³adni:
   </para>
   <para>
    <example>
     <title>Pseudokod demonstruj±cy u¿ycie funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Przyk³adowa funkcja.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <simpara>
    Ka¿dy poprawny kod mo¿e byæ u¿yty wewn±trz funkcji,
    ³±cznie z definicjami innych funkcji i 
    <link linkend="keyword.class">klas</link>.
   </simpara>
   <para>
    Nazwy funkcji obowi±zuj± identyczne zasady, jak w przypadku wszystkich innych etykiet w PHP. 
    Poprawna nazwa funkcji zaczyna siê od litery lub podkre¶lnika, po których nastêpuje 
    dowolna ilo¶æ liter, cyfr i podkre¶lników. Jako wyra¿enie regularne, okre¶lone 
   zosta³oby to nastêpuj±co: 
    <literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>.
   </para>
   &tip.userlandnaming;
   <simpara>
    Funkcje nie musz± byæ zdefiniowane przed odniesieniem siê do nich,
    <emphasis>oprócz</emphasis> sytuacji, w których funkcja jest
    zdefiniowana warunkowo jak w dwóch poni¿szych przyk³adach.
   </simpara>
   <para>
    Kiedy funkcja jest zdefiniowana warunkowo, jak w dwóch poni¿szych przyk³adach,
    jej definicja musi byæ przetworzona <emphasis>przed</emphasis>
    jej wywo³aniem.
   </para>
   <para>
    <example>
     <title>Funkcje zdefiniowane warunkowo</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Nie mo¿emy tu wywo³aæ foo() 
   poniewa¿ jeszcze nie istnieje,
   ale mo¿emy wywo³aæ bar() */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Nie istniejê, dopóki nie zostanê wykonana.\n";
  }
}

/* Teraz mo¿emy bezpiecznie wywo³aæ foo()
   poniewa¿ $makefoo ma warto¶æ logiczn± 1 */

if ($makefoo) foo();

function bar() 
{
  echo "Istniejê od pocz±tku dzia³ania skryptu.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Funkcje wewn±trz funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "Nie istniejê, dopóki foo() nie jest wywo³ana.\n";
  }
}

/* Nie mo¿emy tu wywo³aæ bar() 
   poniewa¿ jeszcze nie istnieje. */

foo();

/* Teraz mo¿emy wywo³aæ bar(),
   wykonanie foo() spodowa³o
   ¿e jest to ju¿ mo¿liwe. */

bar();

?>  
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Wszystkie funkcje i klasy w PHP maj± globalny zasiêg - mog± byæ
    wykonane poza funkcj±, nawet je¶li by³y zdefiniowane wewn±trz niej, i odwrotnie.
   </para>
   <simpara>
    PHP nie umo¿liwia prze³adowywania funkcji, nie jest te¿ mo¿liwe
    usuniêcie jej definicji lub redefiniowanie poprzednio okre¶lonych funkcji.
   </simpara>
   <note>
    <simpara>
     Nazwy funkcji nie rozró¿niaj± wielko¶ci liter, ale dobrym zwyczajem jest
     wywo³ywanie ich w formie, w której zosta³y zdefiniowane.
    </simpara>
   </note>   
   <simpara>
    Zarówno <link linkend="functions.variable-arg-list">przyjmowanie ró¿nej ilo¶ci
    argumentów</link> jak i <link linkend="functions.arguments.default">warto¶ci domy¶lne
    argumentów</link> s± obs³ugiwane w funkcjach. Zobacz tak¿e opisy
    funkcji
    <function>func_num_args</function>,
    <function>func_get_arg</function>, i
    <function>func_get_args</function> aby uzyskaæ wiêcej informacji.
   </simpara>
   
   <para>
    W PHP jest mo¿liwe wykonywanie rekurencyjnych funkcji. Unikaj jednak wywo³ywania
    rekurencyjnych funkcji/metod które osi±gaj± poziom rekurencji wiêkszy ni¿ 100-200,
    poniewa¿ mo¿e to spowodowaæ przepe³nienie stosu i zakoñczenie wykonywania skryptu.
    <example>
     <title>Funkcje rekurencyjne</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   </para>

  </sect1>
 
  <sect1 xml:id="functions.arguments">
   <title>Argumenty funkcji</title>
 
   <simpara>
    Dane mog± byæ przekazywane do funkcji przez listê argumentów,
    która jest list± oddzielonych przecinkami wyra¿eñ.
   </simpara> 
   <para>
    PHP obs³uguje podawanie argumentów jako warto¶ci (domy¶lnie), <link
    linkend="functions.arguments.by-reference">przez
    referencjê</link>, oraz <link
    linkend="functions.arguments.default">domy¶lne warto¶ci
    argumentów</link>. <link linkend="functions.variable-arg-list">Ró¿na ilo¶æ
    argumentów</link> tak¿e jest obs³ugiwana, zobacz opisy funkcji
    <function>func_num_args</function>,
    <function>func_get_arg</function>, i
    <function>func_get_args</function> aby dowiedzieæ siê wiêcej.
   </para>
   <para>
    <example>
     <title>Tablica jako argument funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>
 
   <sect2 xml:id="functions.arguments.by-reference">
    <title>Podawanie argumentów jako referencji</title>
 
    <simpara>
     Domy¶lnie, argumenty funkcji podawane s± jako warto¶ci (kiedy
     warto¶æ argumentu wewn±trz funkcji siê zmienia, nie wp³ywa
     to na warto¶æ zmiennej poza funkcj±). Aby pozwoliæ funkcji na modyfikacjê jej
     jej argumentów, musz± one byæ podane przez referencjê.
    </simpara>
    <para>
     Aby argument zawsze by³ podawany przez referencjê, poprzed¼ nazwê
     argumentu znakiem (&amp;) w definicji funkcji:
    </para>
    <para>
     <example>
      <title>Podawanie parametrów funkcji przez referencjê</title>
      <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 'i co¶ ekstra.';
}
$str = 'To jest ci±g znaków, ';
add_some_extra($str);
echo $str;    // wypisuje 'To jest ci±g znaków, i co¶ ekstra.'
?>
]]>
      </programlisting>
     </example>
    </para>
 
   </sect2>
 
   <sect2 xml:id="functions.arguments.default">
    <title>Domy¶lne warto¶ci argumentów</title>
 
    <para>
     Mo¿na zdefiniowaæ domy¶lne warto¶ci skalarne 
     argumentów w stylu C++ nastêpuj±co:
    </para>
    <para>
     <example>
      <title>U¿ycie domy¶lnych warto¶ci argumentów w funkcji</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($type = "cappuccino")
{
    return "Robiê kubek $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("espresso");
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Wynikiem powy¿szego kodu jest:
    </para>
    <para>
     <screen>
Robiê kubek cappuccino.
Robiê kubek .
Robiê kubek espresso.
     </screen>
    </para>
    <para>
     PHP pozwala równie¿ na u¿ycie tablic(<type>array</type>) i specjalnego typu &null;
     jako domy¶lnych warto¶ci, na przyk³ad:
    </para>
    <para>
     <example>
      <title>U¿ycie nie-skalarnych typów jako domy¶lnych warto¶ci</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "r±k" : $coffeeMaker;
    return "Robiê kubek ".join(", ", $types)." za pomoc± $device.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
    
    </para>
    <simpara>
     Domy¶lna warto¶æ musi byæ sta³ym wyra¿eniem, a nie na przyk³ad
     zmienn±, cz³onkiem klasy czy wywo³aniem funkcji.
    </simpara>
    <para>
     Zauwa¿, ¿e przy u¿yciu domy¶lnych warto¶ci, powinne one byæ
     zdefiniowane po prawej stronie nie-domy¶lnych argumentów; 
     W przeciwnym wypadku, nie zadzia³a to jak powinno. Na przyk³ad: 
    </para>
    <para>
     <example>
      <title>Niepoprawne u¿ycie domy¶lnych warto¶ci argumentów</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($type = "acidophilus", $flavour)
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt("raspberry");   // nie zadzia³a tak, jak oczekujemy
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Wynik powy¿szego skryptu to:
    </para>
    <para>
     <screen>
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Making a bowl of raspberry .
     </screen>
    </para>
    <para>
     Porównaj go teraz z:
    </para>
    <para>
     <example>
      <title>Poprawne u¿ycie domy¶lnych warto¶ci argumentów</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($flavour, $type = "jogurtu")
{
    return "Robiê miskê $type $flavour.\n";
}
 
echo makeyogurt("malinowego");   // dzia³a zgodnie z naszymi oczekiwaniami
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Wynikiem dzia³ania powy¿szego przyk³adu jest:
    </para>
    <para>
     <screen>
Robiê miskê malinowego jogurtu.
     </screen>
    </para>
    
    <note>
     <simpara>
      Od PHP 5 domy¶lne warto¶ci argumentów mog± byæ podawane przez referencjê.
     </simpara>
    </note>

   </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>Podawanie ró¿nej ilo¶ci argumentów</title>

    <simpara>
     Od PHP 4 mo¿liwe jest u¿ycie ró¿nej ilo¶ci argumentów dla
     funkcji definiowanych przez u¿ytkownika. Jest to dosyæ proste przy u¿yciu funkcji
     <function>func_num_args</function>,
     <function>func_get_arg</function> i
     <function>func_get_args</function>.
    </simpara>

    <simpara>
     Nie wymaga to ¿adnej specjalnej sk³adni, listy argumentów
     w dalszym ci±gu podawane s± przy definiowaniu funkcji i zachowuj±
     siê normalnie.
    </simpara>

   </sect2>

  </sect1>
 
  <sect1 xml:id="functions.returning-values">
   <title>Zwracanie warto¶ci</title>
 
   <para>
    Warto¶ci zwracane s± przy u¿yciu opcjonalnego wyra¿enia return. Wszystkie
    typy mog± byæ zwracane, ³±cznie z tablicami i obiektami. Powoduje to natychmiastowe
    zakoñczenie wykonywania funkcji i wznowienie wykonywania skryptu od linijki w której
    funkcja zosta³a wywo³ana. Zobacz <function>return</function>
    aby uzyskaæ wiêcej informacji.
   </para>
   <para>
    <example>
     <title>U¿ycie <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // wypisuje '16'.
?>
]]>
     </programlisting>
    </example>
   </para>
      
   <para>
    Funkcjia nie mo¿e zwracaæ wielu warto¶ci, ale podobny efekt
    mo¿e zostaæ osi±gniêty poprzez zwracanie tablicy.
   </para>
   <para>
    <example>
     <title>Zwracanie tablicy</title>
     <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Aby zwróciæ referencjê, u¿yj operatora &amp; zarówno
    w deklaracji funkcji jak i podczas przypisywania zwracanej warto¶ci
    zmiennej:
   </para>
   <para>
    <example>
     <title>Zwracanie referencji</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Aby uzyskaæ wiêcej informacji o referencjach, przejd¼ do <link
    linkend="language.references">Wyja¶nienie Referencji</link>.
   </simpara>
  </sect1>
 
  <sect1 xml:id="functions.variable-functions">
   <title>Funkcje zmiennych</title>

   <para>
    PHP obs³uguje opcjê funkcji zmiennych. Oznacza to, ¿e je¶li
    do nazwy zmiennej dodane s± nawiasy, PHP postara siê znale¼æ
    funkcjê o nazwie takiej jak warto¶æ zmiennej
    i spróbuje j± wykonaæ. Miêdzy innymi, mo¿e to s³u¿yæ do
    zaimplementowania tzw. callbacks, tablic funkcji, a tak¿e wielu innych rzeczy.
   </para>
   <para>
    Funkcje zmiennych nie zadzia³aj± z takimi elementami jêzyka
    jak <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function> i podobnymi. U¿ywaj okrê¿nych funkcji
    aby skorzystaæ z którego¶ z powy¿szych elementów jêzyka jako funkcji zmiennych.
   </para>
   <para>
    <example>
     <title>Przyk³ad funkcji zmiennych</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "W foo()<br />\n";
}

function bar($arg = '')
{
    echo "W bar(); argumentem by³o '$arg'.<br />\n";
}

// To jest funkcja okrê¿na dla "echo"
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Wywo³uje foo()

$func = 'bar';
$func('test');  // Wywo³uje bar()

$func = 'echoit';
$func('test');  // Wywo³uje echoit()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Jako funkcje zmiennych mog± byæ tak¿e wywo³ywane metody obiektów.
    <example>
     <title>Przyk³ad metod zmiennych</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Zmienna()
    {
        $name = 'Bar';
        $this->$name(); // Wywo³uje metodê Bar()
    }
    
    function Bar()
    {
        echo "To jest Bar";
    }
}

$foo = new Foo();
$funcname = "Zmienna";
$foo->$funcname();  // Wywo³uje $foo->Zmienna()

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Zobacz tak¿e <function>call_user_func</function>,
    <link linkend="language.variables.variable">
    zmienne zmienne</link> oraz <function>function_exists</function>.
   </para>
  </sect1>
  
  <sect1 xml:id="functions.internal">
   <title>Wewnêtrzne (wbudowane) funkcje</title>
   
   <para>
    PHP zapewnia wiele wbudowanych funkcji i konstrukcji. Istniej± tak¿e
    funkcje wymagaj±ce wkompilowania specyficznych rozszerzeñ PHP, w przeciwnym wypadku
    wywo³anie ich skutkuje b³êdami "undefined function". Na przyk³add, aby u¿yæ funkcji
    <link linkend="ref.image">obrazków</link> takich jak
    <function>imagecreatetruecolor</function>, PHP musi byæ skompilowane z obs³ug±
    <productname>GD</productname>. Aby u¿yæ
    <function>mysql_connect</function>, PHP musi byæ skompilowane z obs³ug±
    <link linkend="ref.mysql">MySQL</link>. Jest wiele funkcji wbudowanych
    w rdzeñ ka¿dej wersji PHP, takich jak funkcje
    <link linkend="ref.strings">typu string</link> oraz 
    <link linkend="ref.var">zmiennych</link>. Wywo³anie
    to <function>phpinfo</function> lub
    <function>get_loaded_extensions</function> poka¿e, które rozszerzenia
    PHP s± za³adowane. Zauwa¿, ¿e wiele rozszerzeñ jest domy¶lnie za³adowanych i 
    podrêcznik PHP jest podzielony wed³ug rozszerzeñ. Zobacz rozdzia³y o 
    <link linkend="configuration">konfiguracji</link>,
    <link linkend="install">instalacji</link>, a tak¿e te dotycz±ce
    poszczególnych rozszerzeñ, aby dowiedzieæ siê jak uruchomiæ PHP.
   </para>
   <para>
    Czytanie i rozumienie prototypów funkcji wyja¶nione jest w rozdziale
    podrêcznika zatytu³owanym <link linkend="about.prototypes">jak czytaæ
    definicje funkcji</link>. Wa¿ne jest zrozumienie, czy funkcja zwraca konkretn± warto¶æ
    czy operuje bezpo¶rednio na podanej zmiennej. Na przyk³ad,
    <function>str_replace</function> zwróci zmodyfikowany obiekt typu string, podczas gdy
    <function>usort</function> pracuje bezpo¶rednio na podanej zmiennej.
    Ka¿da funkcja posiada swoj± stronê w podrêczniku PHP, która podaje informacje takie jak
    parametry funkcji, jej zachowanie, warto¶ci zwracane po poprawnym wykonaniu i w przypadku b³êdu,
    a tak¿e dane dotycz±ce jej dostêpno¶ci.
    Znanie tych wa¿nych (chocia¿ czêsto drobnych) ró¿nic jest kluczowe podczas
    pisania kodu w PHP.
   </para>
   <note>
    <simpara>
     Je¶li parametry podane funkcji nie s± takie, jak spodziewane, na przyk³ad 
     tablica(<type>array</type>) podawana jest w miejscu, gdzie oczekiwana jest zmienna typu <type>string</type>, 
     warto¶æ zwracana przez funkcjê nie jest zdefiniowana. W takim wypadku funkcja prawdopodobnie
     zwróci &null; ale jest to jedynie konwencja
     a nie zasada, na której mo¿na siê opieraæ.
    </simpara>
   </note>
   <para>
    Zobacz tak¿e <function>function_exists</function>, 
    <link linkend="funcref">the function reference</link>,
    <function>get_extension_funcs</function> i 
    <function>dl</function>.
   </para>
   
   <!-- FIXME: Fixes build -->
   <para xml:id='functions.anonymous'><link xlink:href="http://php.net/manual/en/functions.anonymous">Anonymous Functions</link></para>
   
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
