<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: n/a Maintainer: pirate Status: ready -->
<!-- $Revision$ -->
 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Funkcje</title>

  <sect1 xml:id="functions.user-defined">
   <title>Funkcje definiowane przez użytkownika</title>
 
   <para>
    Funkcja może być definiowana przy użyciu następującej składni:
   </para>
   <para>
    <example>
     <title>Pseudokod demonstrujący użycie funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Przykładowa funkcja.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <simpara>
    Każdy poprawny kod może być użyty wewnątrz funkcji,
    łącznie z definicjami innych funkcji i 
    <link linkend="keyword.class">klas</link>.
   </simpara>
   <para>
    Nazwy funkcji obowiązują identyczne zasady, jak w przypadku wszystkich innych etykiet w PHP. 
    Poprawna nazwa funkcji zaczyna się od litery lub podkreślnika, po których następuje 
    dowolna ilość liter, cyfr i podkreślników. Jako wyrażenie regularne, określone 
   zostałoby to następująco: 
    <literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>.
   </para>
   &tip.userlandnaming;
   <simpara>
    Funkcje nie muszą być zdefiniowane przed odniesieniem się do nich,
    <emphasis>oprócz</emphasis> sytuacji, w których funkcja jest
    zdefiniowana warunkowo jak w dwóch poniższych przykładach.
   </simpara>
   <para>
    Kiedy funkcja jest zdefiniowana warunkowo, jak w dwóch poniższych przykładach,
    jej definicja musi być przetworzona <emphasis>przed</emphasis>
    jej wywołaniem.
   </para>
   <para>
    <example>
     <title>Funkcje zdefiniowane warunkowo</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Nie możemy tu wywołać foo() 
   ponieważ jeszcze nie istnieje,
   ale możemy wywołać bar() */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Nie istnieję, dopóki nie zostanę wykonana.\n";
  }
}

/* Teraz możemy bezpiecznie wywołać foo()
   ponieważ $makefoo ma wartość logiczną 1 */

if ($makefoo) foo();

function bar() 
{
  echo "Istnieję od początku działania skryptu.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Funkcje wewnątrz funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "Nie istnieję, dopóki foo() nie jest wywołana.\n";
  }
}

/* Nie możemy tu wywołać bar() 
   ponieważ jeszcze nie istnieje. */

foo();

/* Teraz możemy wywołać bar(),
   wykonanie foo() spodowało
   że jest to już możliwe. */

bar();

?>  
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Wszystkie funkcje i klasy w PHP mają globalny zasięg - mogą być
    wykonane poza funkcją, nawet jeśli były zdefiniowane wewnątrz niej, i odwrotnie.
   </para>
   <simpara>
    PHP nie umożliwia przeładowywania funkcji, nie jest też możliwe
    usunięcie jej definicji lub redefiniowanie poprzednio określonych funkcji.
   </simpara>
   <note>
    <simpara>
     Nazwy funkcji nie rozróżniają wielkości liter, ale dobrym zwyczajem jest
     wywoływanie ich w formie, w której zostały zdefiniowane.
    </simpara>
   </note>   
   <simpara>
    Zarówno <link linkend="functions.variable-arg-list">przyjmowanie różnej ilości
    argumentów</link> jak i <link linkend="functions.arguments.default">wartości domyślne
    argumentów</link> są obsługiwane w funkcjach. Zobacz także opisy
    funkcji
    <function>func_num_args</function>,
    <function>func_get_arg</function>, i
    <function>func_get_args</function> aby uzyskać więcej informacji.
   </simpara>
   
   <para>
    W PHP jest możliwe wykonywanie rekurencyjnych funkcji. Unikaj jednak wywoływania
    rekurencyjnych funkcji/metod które osiągają poziom rekurencji większy niż 100-200,
    ponieważ może to spowodować przepełnienie stosu i zakończenie wykonywania skryptu.
    <example>
     <title>Funkcje rekurencyjne</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   </para>

  </sect1>
 
  <sect1 xml:id="functions.arguments">
   <title>Argumenty funkcji</title>
 
   <simpara>
    Dane mogą być przekazywane do funkcji przez listę argumentów,
    która jest listą oddzielonych przecinkami wyrażeń.
   </simpara> 
   <para>
    PHP obsługuje podawanie argumentów jako wartości (domyślnie), <link
    linkend="functions.arguments.by-reference">przez
    referencję</link>, oraz <link
    linkend="functions.arguments.default">domyślne wartości
    argumentów</link>. <link linkend="functions.variable-arg-list">Różna ilość
    argumentów</link> także jest obsługiwana, zobacz opisy funkcji
    <function>func_num_args</function>,
    <function>func_get_arg</function>, i
    <function>func_get_args</function> aby dowiedzieć się więcej.
   </para>
   <para>
    <example>
     <title>Tablica jako argument funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>
 
   <sect2 xml:id="functions.arguments.by-reference">
    <title>Podawanie argumentów jako referencji</title>
 
    <simpara>
     Domyślnie, argumenty funkcji podawane są jako wartości (kiedy
     wartość argumentu wewnątrz funkcji się zmienia, nie wpływa
     to na wartość zmiennej poza funkcją). Aby pozwolić funkcji na modyfikację jej
     jej argumentów, muszą one być podane przez referencję.
    </simpara>
    <para>
     Aby argument zawsze był podawany przez referencję, poprzedź nazwę
     argumentu znakiem (&amp;) w definicji funkcji:
    </para>
    <para>
     <example>
      <title>Podawanie parametrów funkcji przez referencję</title>
      <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 'i coś ekstra.';
}
$str = 'To jest ciąg znaków, ';
add_some_extra($str);
echo $str;    // wypisuje 'To jest ciąg znaków, i coś ekstra.'
?>
]]>
      </programlisting>
     </example>
    </para>
 
   </sect2>
 
   <sect2 xml:id="functions.arguments.default">
    <title>Domyślne wartości argumentów</title>
 
    <para>
     Można zdefiniować domyślne wartości skalarne 
     argumentów w stylu C++ następująco:
    </para>
    <para>
     <example>
      <title>Użycie domyślnych wartości argumentów w funkcji</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($type = "cappuccino")
{
    return "Robię kubek $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("espresso");
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Wynikiem powyższego kodu jest:
    </para>
    <para>
     <screen>
Robię kubek cappuccino.
Robię kubek .
Robię kubek espresso.
     </screen>
    </para>
    <para>
     PHP pozwala również na użycie tablic(<type>array</type>) i specjalnego typu &null;
     jako domyślnych wartości, na przykład:
    </para>
    <para>
     <example>
      <title>Użycie nie-skalarnych typów jako domyślnych wartości</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "rąk" : $coffeeMaker;
    return "Robię kubek ".join(", ", $types)." za pomocą $device.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
    
    </para>
    <simpara>
     Domyślna wartość musi być stałym wyrażeniem, a nie na przykład
     zmienną, członkiem klasy czy wywołaniem funkcji.
    </simpara>
    <para>
     Zauważ, że przy użyciu domyślnych wartości, powinne one być
     zdefiniowane po prawej stronie nie-domyślnych argumentów; 
     W przeciwnym wypadku, nie zadziała to jak powinno. Na przykład: 
    </para>
    <para>
     <example>
      <title>Niepoprawne użycie domyślnych wartości argumentów</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($type = "acidophilus", $flavour)
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt("raspberry");   // nie zadziała tak, jak oczekujemy
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Wynik powyższego skryptu to:
    </para>
    <para>
     <screen>
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Making a bowl of raspberry .
     </screen>
    </para>
    <para>
     Porównaj go teraz z:
    </para>
    <para>
     <example>
      <title>Poprawne użycie domyślnych wartości argumentów</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($flavour, $type = "jogurtu")
{
    return "Robię miskę $type $flavour.\n";
}
 
echo makeyogurt("malinowego");   // działa zgodnie z naszymi oczekiwaniami
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Wynikiem działania powyższego przykładu jest:
    </para>
    <para>
     <screen>
Robię miskę malinowego jogurtu.
     </screen>
    </para>
    
    <note>
     <simpara>
      Od PHP 5 domyślne wartości argumentów mogą być podawane przez referencję.
     </simpara>
    </note>

   </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>Podawanie różnej ilości argumentów</title>

    <simpara>
     Od PHP 4 możliwe jest użycie różnej ilości argumentów dla
     funkcji definiowanych przez użytkownika. Jest to dosyć proste przy użyciu funkcji
     <function>func_num_args</function>,
     <function>func_get_arg</function> i
     <function>func_get_args</function>.
    </simpara>

    <simpara>
     Nie wymaga to żadnej specjalnej składni, listy argumentów
     w dalszym ciągu podawane są przy definiowaniu funkcji i zachowują
     się normalnie.
    </simpara>

   </sect2>

  </sect1>
 
  <sect1 xml:id="functions.returning-values">
   <title>Zwracanie wartości</title>
 
   <para>
    Wartości zwracane są przy użyciu opcjonalnego wyrażenia return. Wszystkie
    typy mogą być zwracane, łącznie z tablicami i obiektami. Powoduje to natychmiastowe
    zakończenie wykonywania funkcji i wznowienie wykonywania skryptu od linijki w której
    funkcja została wywołana. Zobacz <function>return</function>
    aby uzyskać więcej informacji.
   </para>
   <para>
    <example>
     <title>Użycie <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // wypisuje '16'.
?>
]]>
     </programlisting>
    </example>
   </para>
      
   <para>
    Funkcjia nie może zwracać wielu wartości, ale podobny efekt
    może zostać osiągnięty poprzez zwracanie tablicy.
   </para>
   <para>
    <example>
     <title>Zwracanie tablicy</title>
     <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Aby zwrócić referencję, użyj operatora &amp; zarówno
    w deklaracji funkcji jak i podczas przypisywania zwracanej wartości
    zmiennej:
   </para>
   <para>
    <example>
     <title>Zwracanie referencji</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Aby uzyskać więcej informacji o referencjach, przejdź do <link
    linkend="language.references">Wyjaśnienie Referencji</link>.
   </simpara>
  </sect1>
 
  <sect1 xml:id="functions.variable-functions">
   <title>Funkcje zmiennych</title>

   <para>
    PHP obsługuje opcję funkcji zmiennych. Oznacza to, że jeśli
    do nazwy zmiennej dodane są nawiasy, PHP postara się znaleźć
    funkcję o nazwie takiej jak wartość zmiennej
    i spróbuje ją wykonać. Między innymi, może to służyć do
    zaimplementowania tzw. callbacks, tablic funkcji, a także wielu innych rzeczy.
   </para>
   <para>
    Funkcje zmiennych nie zadziałają z takimi elementami języka
    jak <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function> i podobnymi. Używaj okrężnych funkcji
    aby skorzystać z któregoś z powyższych elementów języka jako funkcji zmiennych.
   </para>
   <para>
    <example>
     <title>Przykład funkcji zmiennych</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "W foo()<br />\n";
}

function bar($arg = '')
{
    echo "W bar(); argumentem było '$arg'.<br />\n";
}

// To jest funkcja okrężna dla "echo"
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Wywołuje foo()

$func = 'bar';
$func('test');  // Wywołuje bar()

$func = 'echoit';
$func('test');  // Wywołuje echoit()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Jako funkcje zmiennych mogą być także wywoływane metody obiektów.
    <example>
     <title>Przykład metod zmiennych</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Zmienna()
    {
        $name = 'Bar';
        $this->$name(); // Wywołuje metodę Bar()
    }
    
    function Bar()
    {
        echo "To jest Bar";
    }
}

$foo = new Foo();
$funcname = "Zmienna";
$foo->$funcname();  // Wywołuje $foo->Zmienna()

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Zobacz także <function>call_user_func</function>,
    <link linkend="language.variables.variable">
    zmienne zmienne</link> oraz <function>function_exists</function>.
   </para>
  </sect1>
  
  <sect1 xml:id="functions.internal">
   <title>Wewnętrzne (wbudowane) funkcje</title>
   
   <para>
    PHP zapewnia wiele wbudowanych funkcji i konstrukcji. Istnieją także
    funkcje wymagające wkompilowania specyficznych rozszerzeń PHP, w przeciwnym wypadku
    wywołanie ich skutkuje błędami "undefined function". Na przykładd, aby użyć funkcji
    <link linkend="ref.image">obrazków</link> takich jak
    <function>imagecreatetruecolor</function>, PHP musi być skompilowane z obsługą
    <productname>GD</productname>. Aby użyć
    <function>mysql_connect</function>, PHP musi być skompilowane z obsługą
    <link linkend="ref.mysql">MySQL</link>. Jest wiele funkcji wbudowanych
    w rdzeń każdej wersji PHP, takich jak funkcje
    <link linkend="ref.strings">typu string</link> oraz 
    <link linkend="ref.var">zmiennych</link>. Wywołanie
    to <function>phpinfo</function> lub
    <function>get_loaded_extensions</function> pokaże, które rozszerzenia
    PHP są załadowane. Zauważ, że wiele rozszerzeń jest domyślnie załadowanych i 
    podręcznik PHP jest podzielony według rozszerzeń. Zobacz rozdziały o 
    <link linkend="configuration">konfiguracji</link>,
    <link linkend="install">instalacji</link>, a także te dotyczące
    poszczególnych rozszerzeń, aby dowiedzieć się jak uruchomić PHP.
   </para>
   <para>
    Czytanie i rozumienie prototypów funkcji wyjaśnione jest w rozdziale
    podręcznika zatytułowanym <link linkend="about.prototypes">jak czytać
    definicje funkcji</link>. Ważne jest zrozumienie, czy funkcja zwraca konkretną wartość
    czy operuje bezpośrednio na podanej zmiennej. Na przykład,
    <function>str_replace</function> zwróci zmodyfikowany obiekt typu string, podczas gdy
    <function>usort</function> pracuje bezpośrednio na podanej zmiennej.
    Każda funkcja posiada swoją stronę w podręczniku PHP, która podaje informacje takie jak
    parametry funkcji, jej zachowanie, wartości zwracane po poprawnym wykonaniu i w przypadku błędu,
    a także dane dotyczące jej dostępności.
    Znanie tych ważnych (chociaż często drobnych) różnic jest kluczowe podczas
    pisania kodu w PHP.
   </para>
   <note>
    <simpara>
     Jeśli parametry podane funkcji nie są takie, jak spodziewane, na przykład 
     tablica(<type>array</type>) podawana jest w miejscu, gdzie oczekiwana jest zmienna typu <type>string</type>, 
     wartość zwracana przez funkcję nie jest zdefiniowana. W takim wypadku funkcja prawdopodobnie
     zwróci &null; ale jest to jedynie konwencja
     a nie zasada, na której można się opierać.
    </simpara>
   </note>
   <para>
    Zobacz także <function>function_exists</function>, 
    <link linkend="funcref">the function reference</link>,
    <function>get_extension_funcs</function> i 
    <function>dl</function>.
   </para>
   
   <!-- FIXME: Fixes build -->
   <para xml:id='functions.anonymous'><link xlink:href="http://php.net/manual/en/functions.anonymous">Anonymous Functions</link></para>
   
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
