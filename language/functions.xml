<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: 1.60 Maintainer: leszek Status: ready -->
<!-- $Revision: 1.13 $ -->
 <chapter id="functions">
  <title>Funkcje</title>

  <sect1 id="functions.user-defined">
   <title>Funkcje zdefiniowane przez u¿ytkownika</title>
 
   <para>
    Funkcja mo¿e byæ zdefiniowana u¿ywaj±c sk³adni takiej jak poni¿sza:
   </para>
   <para>
    <example>
     <title>Pseudo-kod ilustruj±cy zastosowanie funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo ($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Przyk³adowa funkcja.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <simpara>
    Dowolny poprawny kod PHP mo¿e siê pojawiæ wewn±trz funkcji, tak¿e
    definicje innych funkcji i <link linkend="keyword.class">klas</link>.
   </simpara>
   <para>
    Nazwy funkcji podlegaj± takim samym ograniczeniom jak wszystkie inne
    etykiety w PHP. Poprawna nazwa funkcji zaczyna siê od litery lub
    podkre¶lenia, po których nastêpuje dowolna liczba liter, liczb lub
    podkre¶leñ. Powy¿sza zasada w postaci wyra¿enia regularnego przedstawia
    siê nastêpuj±co:
    <literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>.
   </para>
   <simpara>
    W PHP 3, funkcje musz± byæ zdefiniowane przed odwo³aniem do nich. W PHP 4
    nie ma takiego wymagania. <emphasis>Wyj±tkiem</emphasis> jest warunkowe
    definiowanie funkcji, tak jak pokazano to w dwóch przyk³adach
    zamieszczonych poni¿ej.
   </simpara>
   <para>
    Kiedy funkcja jest definiowana w postaci warunkowej, tak jak to
    przedstawiono na dwóch poni¿szych przyk³adach, jej definicja musi
    nastêpowaæ <emphasis>przed</emphasis> jej wywo³aniem.
   </para>
   <para>
    <example>
     <title>Funkcje warunkowe</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Nie mo¿na wywo³aæ foo() z tego miejsca,
   poniewa¿ funkcja ta jeszcze nie istnieje.
   Mo¿na natomiast wywo³aæ bar() */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Nie istniejê dopóki wykonanie programu nie dojdzie do tego miejsca.\n";
  }
}

/* W tym momencie mo¿na spokojnie wywo³aæ foo()
   poniewa¿ $makefoo ma warto¶æ true */

if ($makefoo) foo();

function bar() 
{
  echo "Istniejê od samego pocz±tku dzia³ania programu.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Funkcje wewn±trz funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "Nie istniejê dopóki foo() nie zostanie wywo³ana.\n";
  }
}

/* Nie mo¿na wywo³aæ bar()
   poniewa¿ nie istnieje. */

foo();

/* Teraz mo¿na wywo³aæ bar(),
   poniewa¿ wywo³anie foo() utworzy³o
   t± funkcjê. */

bar();

?>  
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Wszystkie funkcje i klasy w PHP maj± zasiêg globalny - mo¿na je wywo³aæ
    spoza cia³a funkcji, nawet je¶li zosta³y w niej zdefiniowane, i vice
    versa.
   </para>
   <simpara>
    PHP nie obs³uguje przeci±¿ania funkcji. Nie jest tak¿e mo¿liwa
    od-definiowanie lub przedefiniowanie wcze¶niej zadeklarowanych funkcji.
   </simpara>
   <note>
    <simpara>
     W nazwach funkcji nie jest istotna wielko¶æ znaków, jednak¿e dobrze jest
     wywo³ywaæ funkcje tak, jak zosta³y zdeklarowane.
    </simpara>
   </note>   
   <simpara>
    PHP 3 nie obs³uguje funkcji o zmiennej liczbie argumentów, ale obs³uguje
    domy¶lne argumenty (zobacz rozdzial <link
    linkend="functions.arguments.default">Warto¶ci domy¶lne argumentów
    </link> aby uzyskaæ wiêcej informacji). Od wersji PHP 4 obs³ugiwane s±
    jedne i drugie: zobacz <link linkend="functions.variable-arg-list">Listy
     argumentów o zmiennej d³ugo¶ci </link> i opisy funkcji
    <function>func_num_args</function>, <function>func_get_arg</function>, i
    <function>func_get_args</function> aby uzyskaæ wiêcej informacji.
   </simpara>
   <para>
    W PHP mo¿liwe jest rekurencyjne wywo³ywanie funkcji. Nale¿y jednak unikaæ
    rekurencyjnych wywo³añ funkcji lub metod o g³êboko¶ci wiêkszej ni¿ 100-200
    poziomów, gdy¿ mo¿e to zniszczyæ stos i spowodowaæ przerwanie dzia³ania
    skryptu.
    <example>
     <title>Funkcje rekurencyjne</title>
     <programlisting role="php">
<![CDATA[
<?php
function rekurencja($a)
{
    if ($a < 20) {
        echo "$a\n";
        rekurencja($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   </para>

  </sect1>
 
  <sect1 id="functions.arguments">
   <title>Argumenty funkcji</title>
 
   <simpara>
    Informacje mog± byæ przekazywane do funkcji przez listê argumentów, która
    jest separowan± przecinkami list± wyra¿eñ.
   </simpara> 
   <para>
     PHP obs³uguje przekazywanie argumentów przez warto¶æ (domy¶lnie), 
     <link linkend="functions.arguments.by-reference">przez referencjê </link>,
     i <link linkend="functions.arguments.default">warto¶ci domy¶lne
     argumentów</link>. Listy argumentów o zmiennej d³ugo¶ci s± obs³ugiwane
     tylko w PHP 4 i nowszych; zobacz rozdzia³ <link
     linkend="functions.variable-arg-list">Listy argumentów o zmiennej
     d³ugo¶ci</link> i opisy funkcji
     <function>func_num_args</function>,
     <function>func_get_arg</function>, i
     <function>func_get_args</function> aby uzyskaæ wiêcej informacji. Podobny
     efekt mo¿e byæ uzyskany w PHP 3 przez przekazywanie tablicy argumentów do
     funkcji.
    </para>
    <para>
     <example>
      <title>Przekazywanie tablic do funkcji</title>
      <programlisting role="php">
<![CDATA[
function pobiera_tablice($wejscie)
{
    echo "$wejscie[0] + $wejscie[1] = ", $wejscie[0]+$wejscie[1];
}
]]>
      </programlisting>
     </example>
    </para>
 
   <sect2 id="functions.arguments.by-reference">
    <title>Przekazywanie argumentów przez referencjê</title>
 
    <simpara>
     Domy¶lnie, argumenty funkcji s± przekazywane przez warto¶æ (a wiêc je¶li
     zmienisz warto¶æ argumentu wewn±trz funkcji, nie zmieni siê ona poza
     funkcj±). Je¶li chcesz pozwoliæ funkcji na modyfikacjê swoich argumentów,
     musisz przekazaæ je przez referencjê.
    </simpara>
    <para>
     Je¶li chcesz, aby argumenty by³y zawsze przekazywane przez referencjê,
     przed nazw± zmiennej w definicji funkcji wstaw znak ampersand (&amp;):
    </para>
    <para>
     <example>
      <title>Przekazywanie argumentów przez referencjê</title>
      <programlisting role="php">
<![CDATA[
<?php
function dodaj_cos_extra(&$string)
{
    $string .= 'i co¶ extra.';
}
$str = 'To jest string, ';
dodaj_cos_extra($str);
echo $str;    // wy¶wietla 'To jest string string, i co¶ extra.'
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
 
   <sect2 id="functions.arguments.default">
    <title>Warto¶ci domy¶lne argumentów</title>
 
    <para>
     Funkcja mo¿e definiowaæ, podobnie jest w C++, warto¶ci domy¶lne dla
     argumentów skalarnych.
    </para>
    <para>
     <example>
      <title>U¿ycie domy¶lnych warto¶ci argumentów</title>
      <programlisting role="php">
<![CDATA[
<?php
function rob_kawe ($typ = "cappucino")
{
    return "Robiê kubek $typ.\n";
}
echo rob_kawe ();
echo rob_kawe ("espresso");
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Powy¿szy kawa³ek kody wy¶wietli:
    </para>
    <para>
     <screen>
Robiê kubek cappucino.
Robiê kubek espresso.
     </screen>
    </para>
    <para>
     PHP pozwala tak¿e na korzystanie z tablic i specjalnego typu NULL jako
     warto¶ci domy¶lnych.
    </para>
    <para>
     <example>
      <title>U¿ywanie nieskalarnych typów jako warto¶ci domy¶lne</title>
      <programlisting role="php">
<![CDATA[
<?php
function rob_kawe($typy = array("cappuccino"), $urzadzenie = NULL)
{
    $urzadzenie = is_null($urzadzenie) ? "rece" : $urzadzenie;
    return "Robie kubek ".join(", ", $types)." poprzez $urzadzenie.\n";
}
echo rob_kawe();
echo rob_kawe(array("cappuccino", "lavazza"), "ekspres");
?>
]]>
      </programlisting>
     </example>
    
    </para>
 
    <simpara>
     Domy¶lna warto¶æ musi byæ sta³ym wyra¿eniem, nie (na przyk³ad) zmienn±.
     cz³onkiem klasy lub wywo³aniem funkcji.
    </simpara>
    <para>
     Zauwa¿, ¿e u¿ywaj±c domy¶lnych argumentów, argumenty zawieraj±ce warto¶ci
     domy¶lne powinny byæ po prawej stronie tych nie zawieraj±cych warto¶ci
     domy¶lnych; w przeciwnym przypadku funkcja mo¿e nie dzia³aæ tak jak siê
     tego spodziewa³e¶. Przedstawione to zosta³o na poni¿szym przyk³adzie.
    </para>
    <para>
     <example>
      <title>B³êdne zastosowanie domy¶lnych argumentów funkcji</title>
      <programlisting role="php">
<![CDATA[
<?php
function robjogurt ($typ = "acidophilus", $smak)
{
    return "Robiê miskê $typ $smak.\n";
}
 
echo robjogurt ("malinowy");   // nie dzia³a tak jak siê spodziewali¶my
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Powy¿szy przyk³ad wy¶wietli:
    </para>
    <para>
     <screen>
Warning: Missing argument 2 in call to robjogurt() in 
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Robiê miskê malinowy .
     </screen>
    </para>
 
    <para>
     Porównaj powy¿szy przyk³ad z tym:
    </para>
    <para>
     <example>
      <title>Poprawne u¿ycie domy¶lnych argumentów funkcji</title>
      <programlisting role="php">
<![CDATA[
<?php
function robjogurt ($smak, $typ = "acidophilus")
{
    return "Robiê miskê $type $flavour.\n";
}
 
echo robjogurt ("malinowy");   // dzia³a tak jak siê spodziewali¶my
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Powy¿szy kod wy¶wietli:
    </para>
    <para>
     <screen>
Robiê miskê acidophilus malinowy.
     </screen>
    </para>
    <note>
     <simpara>
      Od PHP 5, domy¶lne argumenty funkcji mog± byæ przekazywane przez
      referencjê.
     </simpara>
    </note>

   </sect2>

   <sect2 id="functions.variable-arg-list">
    <title>Listy argumentów o zmiennej d³ugo¶ci</title>
	
    <simpara>
     PHP 4 i nowsze obs³uguj± listy o zmiennej d³ugo¶ci w funkcjach zdefiniowanych
     przez u¿ytkownika. Jest naprawdê prostê przy u¿yciu funkcji
     <function>func_num_args</function>,
     <function>func_get_arg</function> i
     <function>func_get_args</function>.
    </simpara>

    <simpara>
     Nie wymagana jest ¿adna specjalna sk³adnia. Listy argumentów mog± byæ
     ci±gle jawnie podane przy definicji funkcji i bêd± siê zachowywaæ
     normalnie.
    </simpara>

   </sect2>

  </sect1>
 
  <sect1 id="functions.returning-values">
   <title>Zwracane warto¶ci</title>
 
   <para>
    Warto¶ci s± zwracane przy u¿yciu opcjonalnej instrukcji return. Mo¿e byæ
    zwracany dowonlny typ, w³±czaj±c w to tablice i obiekty. Spowoduje to
    natychmiastowe zakoñczenie dzia³ania funkcji i przekazanie kontroli do
    linii, z której by³a wywo³ana. Wiêcej informacji w opisie
    <function>return</function>.
   </para>
   <para>
    <example>
     <title>Zastosowanie <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function kwadrat ($num)
{
    return $num * $num;
}
echo kwadrat (4);   // wy¶wietla '16'.
?>
]]>
     </programlisting>
    </example>
   </para>
      
   <para>
    Nie mo¿na zwracaæ zwracaæ wielu warto¶ci z funkcji, ale podobne efekty
    mog± byæ uzyskane przez zwracanie listy.
   </para>
   <para>
    <example>
     <title>Zwracanie tablicy dla uzyskania wielu wyników</title>
     <programlisting role="php">
<![CDATA[
<?php
function maleLiczby()
{
    return array (0, 1, 2);
}
list ($zero, $jeden, $dwa) = maleLiczby();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Aby funkcja zwraca³a referencjê, musisz u¿yæ operatora referencji &amp; i
    w deklaracji funkcji i przy przypisywaniu zwracanej warto¶ci do zmiennej.
   </para>
   <para>
    <example>
     <title>Zwracanie referencji przez funkcjê</title>
     <programlisting role="php">
<![CDATA[
<?php
function &zwrocReferencje()
{
    return $jakasref;
}

$nowaref =& zwrocReferencje();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Wiêcej informacji na temat referencji w rozdziale
    <link linkend="language.references">References Explained</link>.
   </simpara>
  </sect1>
 
  <sect1 id="functions.variable-functions">
   <title>Zmienne funkcje</title>

   <para>
    PHP obs³uguje koncepcjê zmiennych funkcji. Oznacza to, ¿e je¶li po nazwie
    zmiennej wystêpuj± nawiasy, PHP bêdzie szuka³o funkcji o nazwie bêd±cej
    warto¶ci± zmiennej i bêdzie próbowa³o wywo³aæ j±. Miêdzy innymi mo¿e byæ
    to u¿yte do implementacji funkcji callback, tablicy funkcji itp.
   </para>
   <para>
    Zmienne funkcje nie bêd± dzia³aæ z elementami sk³adowymi jêzyka takimi
    jak <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function> i innymi podobnymi. Aby zastosowaæ zmienne
    funkcje z takimi sk³adowymi, niezbêdne jest zastosowanie funkcji
    obudowuj±cych.
   </para>
   <para>
    <example>
     <title>Przyk³ad zmiennej funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "W foo()<br />\n";
}

function bar($arg = '') {
    echo "W bar(); argumentem jest '$arg'.<br />\n";
}

// Funkcja obudowuj±ca sk³adniê echo

function echoIt($string) {
    echo $string;
}

$func = 'foo';
$func(); // wywo³a foo()

$func = 'bar';
$func('test'); // wywo³a bar()

$func = 'echoIt';
$func('test'); // wywo³a echoIt()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Mo¿liwe jest tak¿e wywo³anie metody obiektu korzystaj±c z mechanizmu
    zmiennych funkcji.
    You can also call an object's method by using the variable functions
    feature.
    <example>
     <title>Przyk³ad zmiennych metod</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Zmienna()
    {
        $name = 'Bar';
        $this->$name(); // Wywo³a metodê Bar()
    }
    
    function Bar()
    {
        echo "To jest Bar";
    }
}

$foo = new Foo();
$funkcja = "Zmienna";
$foo->$funkcja();  // Wywo³a $foo->Zmienna()

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Patrz tak¿e <function>call_user_func</function>, <link
     linkend="language.variables.variable"> variable variables</link> i
    <function>function_exists</function>.
   </para>

  </sect1>

  <sect1 id="functions.internal">
   <title>Wewnêtrzne (wbudowane) funkcje</title>
   
   <para>
    PHP standardowo zawiera wiele funkcji i sk³adni. Istnieje tak¿e wiele
    funkcji, które wymagaj± skompilowania konkretnych rozszerzeñ PHP, gdy¿ w
    przeciwnym wypadku próba ich wywo³ania spowoduje b³±d "undefined
    function". Na przyk³ad, aby u¿ywaæ funkcji
    <link linkend="ref.image">przetwarzania obrazów</link>, jak na przyk³ad
    <function>imagecreatetruecolor</function>, niezbêdne jest skompilowanie
    PHP z obs³ug± <productname>GD</productname>. Podobnie, aby skorzystaæ z
    funkcji <function>mysql_connect</function>, trzeba mieæ PHP skompilowane z
    obs³ug± <link linkend="ref.mysql">MySQL</link>. Jest tak¿e wiele funkji,
    które s± zawarte w ka¿dej wersji PHP, jak na przyk³ad funkcje obs³ugi
    <link linkend="ref.strings">ci±gów znakowych</link> czy
    <link linkend="ref.var">zmiennych</link>. Listê za³adowanych rozszerzeñ
    mo¿na uzyskaæ przez wywo³anie funkcji <function>phpinfo</function> lub
    <function>get_loaded_extensions</function>. Warto zauwa¿yæ, ¿e niektóre
    rozszerzenia s± domy¶lnie w³±czone, a tak¿e ¿e podrêcznik PHP jest
    podzielony wed³ug rozszerzeñ. Informacje na temat przygotowania swojego
    PHP mo¿na znale¼æ w rozdzia³ach po¶wiêconych <link
     linkend="configuration">konfiguracji</link>,  <link
     linkend="install">instalacji</link>, a tak¿e w rozdzia³ach dotycz±cych
    poszczególnych rozszerzeñ.
   </para>
   <para>
    Czytanie i rozumienie prototypów funkcji zosta³o wyja¶nione w rozdziale
    <link linkend="about.prototypes">Jak czytaæ definicje funkcji</link>.
    Bardzo wa¿ne jest zrozumienie co funkcja zwraca lub czy funkcja operuje
    bezpo¶rednio na przekazywanych warto¶ciach. Na przyk³ad, 
    <function>str_replace</function> zwróci zmodyfikowany ci±g znakowy,
    natomiast <function>usort</function> pracuje bezpo¶rednio na tablicy
    przekazanej jako argument. Ka¿da strona podrêcznika zawiera tak¿e
    konkretne informacje na temat argumentów wywo³ania funkcji, zmian
    zachowania, zwracanych warto¶ciach, zarówno w przypadku powodzenia jak i
    wyst±pienia b³êdu, a tak¿e informacje o dostêpno¶ci. Znajomo¶æ tych
    wa¿nych, choæ czasem subtelnych ró¿nic, jest kluczowa dla pisania
    poprawnego kodu PHP.
   </para>
   <para>
    Patrz tak¿e <function>function_exists</function>, 
    <link linkend="funcref">indeks funkcji</link>,
    <function>get_extension_funcs</function> i 
    <function>dl</function>.
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
