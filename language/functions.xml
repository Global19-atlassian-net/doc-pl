<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 0e9eb8a8c76de2365decd77a46d96ddfeec2bac8 Maintainer: sobak Status: ready -->
<!-- $Revision$ -->
<!-- CREDITS: pirate -->
 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Funkcje</title>

  <sect1 xml:id="functions.user-defined">
   <title>Funkcje definiowane przez użytkownika</title>
 
   <para>
    Funkcja może być definiowana przy użyciu następującej składni:
   </para>
   <para>
    <example>
     <title>Pseudokod demonstrujący użycie funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Przykładowa funkcja.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <simpara>
    Każdy poprawny kod może być użyty wewnątrz funkcji,
    łącznie z definicjami innych funkcji i 
    <link linkend="keyword.class">klas</link>.
   </simpara>
   <para>
    Nazwy funkcji obowiązują identyczne zasady, jak w przypadku wszystkich innych etykiet w PHP. 
    Poprawna nazwa funkcji zaczyna się od litery lub podkreślnika, po których następuje 
    dowolna ilość liter, cyfr i podkreślników. Jako wyrażenie regularne, określone 
    zostałoby to następująco: 
    <literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>.
   </para>
   &tip.userlandnaming;
   <simpara>
    Funkcje nie muszą być zdefiniowane przed odniesieniem się do nich,
    <emphasis>oprócz</emphasis> sytuacji, w których funkcja jest
    zdefiniowana warunkowo jak w dwóch poniższych przykładach.
   </simpara>
   <para>
    Kiedy funkcja jest zdefiniowana warunkowo, jak w dwóch poniższych przykładach,
    jej definicja musi być przetworzona <emphasis>przed</emphasis>
    jej wywołaniem.
   </para>
   <para>
    <example>
     <title>Funkcje zdefiniowane warunkowo</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Nie możemy tu wywołać foo() 
   ponieważ jeszcze nie istnieje,
   ale możemy wywołać bar() */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Nie istnieję, dopóki nie zostanę wykonana.\n";
  }
}

/* Teraz możemy bezpiecznie wywołać foo()
   ponieważ $makefoo ma wartość logiczną 1 */

if ($makefoo) foo();

function bar() 
{
  echo "Istnieję od początku działania skryptu.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Funkcje wewnątrz funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "Nie istnieję, dopóki foo() nie jest wywołana.\n";
  }
}

/* Nie możemy tu wywołać bar() 
   ponieważ jeszcze nie istnieje. */

foo();

/* Teraz możemy wywołać bar(),
   wykonanie foo() spodowało
   że jest to już możliwe. */

bar();

?>  
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Wszystkie funkcje i klasy w PHP mają globalny zasięg - mogą być
    wykonane poza funkcją, nawet jeśli były zdefiniowane wewnątrz niej, i odwrotnie.
   </para>
   <simpara>
    PHP nie umożliwia przeładowywania funkcji, nie jest też możliwe
    usunięcie jej definicji lub redefiniowanie poprzednio określonych funkcji.
   </simpara>
   <note>
    <simpara>
     Nazwy funkcji nie rozróżniają wielkości liter, ale dobrym zwyczajem jest
     wywoływanie ich w formie, w której zostały zdefiniowane.
    </simpara>
   </note>   
   <simpara>
    Zarówno <link linkend="functions.variable-arg-list">przyjmowanie różnej ilości
    argumentów</link> jak i <link linkend="functions.arguments.default">wartości domyślne
    argumentów</link> są obsługiwane w funkcjach. Zobacz także opisy
    funkcji
    <function>func_num_args</function>,
    <function>func_get_arg</function>, i
    <function>func_get_args</function> aby uzyskać więcej informacji.
   </simpara>
   
   <para>
    W PHP jest możliwe wykonywanie rekurencyjnych funkcji. Unikaj jednak wywoływania
    rekurencyjnych funkcji/metod które osiągają poziom rekurencji większy niż 100-200,
    ponieważ może to spowodować przepełnienie stosu i zakończenie wykonywania skryptu.
    <example>
     <title>Funkcje rekurencyjne</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   </para>

  </sect1>
 
  <sect1 xml:id="functions.arguments">
   <title>Argumenty funkcji</title>
 
   <simpara>
    Dane mogą być przekazywane do funkcji przez listę argumentów,
    która jest listą oddzielonych przecinkami wyrażeń. Argumenty są wykonywane
    od prawej do lewej.	
   </simpara> 
   <para>
    PHP obsługuje podawanie argumentów jako wartości (domyślnie), <link
    linkend="functions.arguments.by-reference">przez
    referencję</link>, oraz <link
    linkend="functions.arguments.default">domyślne wartości
    argumentów</link>. <link linkend="functions.variable-arg-list">Różna ilość
    argumentów</link> także jest obsługiwana.
   </para>
   <para>
    <example>
     <title>Tablica jako argument funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>
 
   <sect2 xml:id="functions.arguments.by-reference">
    <title>Podawanie argumentów jako referencji</title>
 
    <simpara>
     Domyślnie, argumenty funkcji podawane są jako wartości (kiedy
     wartość argumentu wewnątrz funkcji się zmienia, nie wpływa
     to na wartość zmiennej poza funkcją). Aby pozwolić funkcji na modyfikację jej
     jej argumentów, muszą one być podane przez referencję.
    </simpara>
    <para>
     Aby argument zawsze był podawany przez referencję, poprzedź nazwę
     argumentu znakiem (&amp;) w definicji funkcji:
    </para>
    <para>
     <example>
      <title>Podawanie parametrów funkcji przez referencję</title>
      <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 'i coś ekstra.';
}
$str = 'To jest ciąg znaków, ';
add_some_extra($str);
echo $str;    // wypisuje 'To jest ciąg znaków, i coś ekstra.'
?>
]]>
      </programlisting>
     </example>
    </para>
 
   </sect2>
 
   <sect2 xml:id="functions.arguments.default">
    <title>Domyślne wartości argumentów</title>
 
    <para>
     Można zdefiniować domyślne wartości skalarne 
     argumentów w stylu C++ następująco:
    </para>
    <para>
     <example>
      <title>Użycie domyślnych wartości argumentów w funkcji</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($type = "cappuccino")
{
    return "Robię filiżankę $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("espresso");
?>
]]>
      </programlisting>
      &example.outputs;
	  <screen>
<![CDATA[
Robię filiżankę cappuccino.
Robię filiżankę .
Robię filiżankę espresso.
]]>
      </screen>
     </example>
    </para>
    <para>
     PHP pozwala również na użycie tablic(<type>array</type>) i specjalnego typu &null;
     jako domyślnych wartości, na przykład:
    </para>
    <para>
     <example>
      <title>Użycie nie-skalarnych typów jako domyślnych wartości</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "rąk" : $coffeeMaker;
    return "Robię kubek ".join(", ", $types)." za pomocą $device.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
    
    </para>
    <simpara>
     Domyślna wartość musi być stałym wyrażeniem, a nie na przykład
     zmienną, członkiem klasy czy wywołaniem funkcji.
    </simpara>
    <para>
     Zauważ, że przy użyciu domyślnych wartości, powinne one być
     zdefiniowane po prawej stronie nie-domyślnych argumentów; 
     W przeciwnym wypadku, nie zadziała to jak powinno. Na przykład: 
    </para>
    <para>
     <example>
      <title>Niepoprawne użycie domyślnych wartości argumentów</title>
      <programlisting role="php">
<![CDATA[
<?php
function jogurt($typ = "homogenizowany", $smak)
{
    return "Robię $typ jogurt $smak.\n";
}
 
echo jogurt("malinowy");   // nie zadziała tak, jak oczekujemy
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Missing argument 2 in call to jogurt() in 
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Robię malinowy jogurt .
]]>
      </screen>
     </example>
    </para>
    <para>
     Porównaj go teraz z:
    </para>
    <para>
     <example>
      <title>Poprawne użycie domyślnych wartości argumentów</title>
      <programlisting role="php">
<![CDATA[
<?php
function jogurt($smak, $typ = "homogenizowany")
{
    return "Robię $typ jogurt $smak.\n";
}
 
echo makeyogurt("malinowy");   // działa zgodnie z naszymi oczekiwaniami
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Robię homogenizowany jogurt malinowy.
]]>
      </screen>
     </example>
    </para>
    
    <note>
     <simpara>
      Od PHP 5 argumenty, które są przekazywane przez referencję, mogą mieć wartości domyślne.
     </simpara>
    </note>

   </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>Podawanie różnej ilości argumentów</title>

    <simpara>
     PHP wspiera użycie różnej ilości argumentów dla
     funkcji definiowanych przez użytkownika. Jest to możliwe dzięki użyciu
     tokena <literal>...</literal> w PHP 5.6 i nowszych lub dzięki funkcjom
     <function>func_num_args</function>,
     <function>func_get_arg</function> i
     <function>func_get_args</function> w PHP 5.5 i wcześniejszych.
    </simpara>

    <sect3 xml:id="functions.variable-arg-list.new">
     <title><literal>...</literal> w PHP 5.6+</title>

     <para>
      W PHP 5.6 i nowszych lista argumentów może zawierać token
      <literal>...</literal>, który oznacza, że funkcja akceptuje
      zmienną ilość argumentów. Argumenty zostaną przekazane do
      do podanej zmiennej jako tablica, na przykład:

      <example>
       <title>Użycie <literal>...</literal> do zmiennej ilości argumentów</title>
       <programlisting role="php">
<![CDATA[
<?php
function suma(...$liczby) {
    $wynik = 0;
    foreach ($liczby as $liczba) {
        $wynik += $liczba;
    }
    return $wynik;
}

echo suma(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>

     <para>
      Możesz także użyć <literal>...</literal> podczas wywoływania funkcji, aby rozpakować
      zmienną tablicową lub <classname>Traversable</classname>, albo literal
      do listy argumentów:

      <example>
       <title>Użycie <literal>...</literal> do dostarczenia argumentów</title>
       <programlisting role="php">
<![CDATA[
<?php
function dodaj($a, $b) {
    return $a + $b;
}

echo dodaj(...[1, 2])."\n";

$a = [1, 2];
echo dodaj(...$a);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3
3
]]>
       </screen>
      </example>
     </para>

     <para>
      Możesz określić normalne argumenty pozycyjne przed tokenem
      <literal>...</literal>. W tym wypadku tylko końcowe argumenty,
      które nie pasują do żadnego argumentu pozycyjnego, zostaną dodane do tablicy
      generowanej przez <literal>...</literal>.
     </para>

     <para>
      Jest także możliwe
      <link linkend="language.oop5.typehinting">wskazanie typu</link> przez tokenem
      <literal>...</literal>. Jeżeli jest to obecne, to wszystkie argumenty
      pokrywane przez <literal>...</literal> muszą być obiektami wskazanej klasy.

      <example>
       <title>Różna ilość argumentów z określeniem typu</title>
       <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' dni';

// Jest to błędem, ponieważ null nie jest obiektem klasy DateInterval.
echo total_intervals('d', null);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3 dni
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
       </screen>
      </example>
     </para>

     <para>
      W końcu, możesz podać także różną ilość argumentów
      <link linkend="functions.arguments.by-reference">przez referencję</link>
      prefiksując <literal>...</literal> znakiem ampersand
      (<literal>&amp;</literal>).
     </para>
    </sect3>

    <sect3 xml:id="functions.variable-arg-list.old">
     <title>Starsze wersje PHP</title>

     <para>
      Do określenia, że funkcja przyjmuje zmienną ilość argumentów, nie jest wymagana specjalna składnia;
      jednak uzyskanie dostępu do argumentów funkcji wymaga użycia
      <function>func_num_args</function>, <function>func_get_arg</function>
      i <function>func_get_args</function>.
     </para>

     <para>
      Pierwszy przykład podany wyżej, w wersji PHP 5.5 i starszych,
      zostałby zapisany następująco

      <example>
       <title>Dostęp do zmiennej ilości argumentów w PHP 5.5 i starszych</title>
       <programlisting role="php">
<![CDATA[
<?php
function suma() {
    $wynik = 0;
    foreach (func_get_args() as $liczba) {
        $wynik += $liczba;
    }
    return $wynik;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>
    </sect3>

   </sect2>

  </sect1>
 
  <sect1 xml:id="functions.returning-values">
   <title>Zwracanie wartości</title>
 
   <para>
    Wartości zwracane są przy użyciu opcjonalnego wyrażenia return. Wszystkie
    typy mogą być zwracane, łącznie z tablicami i obiektami. Powoduje to natychmiastowe
    zakończenie wykonywania funkcji i wznowienie wykonywania skryptu od linijki w której
    funkcja została wywołana. Zobacz <function>return</function>
    aby uzyskać więcej informacji.
   </para>
   <note>
    <para>
     Jeżeli <function>return</function> zostanie pominięte, zwrócona będzie
     wartość &null;,
    </para>
   </note>
   <para>
    <example>
     <title>Użycie <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function kwadrat($liczba)
{
    return $liczba * $liczba;
}
echo kwadrat(4);   // wypisuje '16'.
?>
]]>
     </programlisting>
    </example>
   </para>
      
   <para>
    Funkcja nie może zwracać wielu wartości, ale podobny efekt
    może zostać osiągnięty poprzez zwracanie tablicy.
   </para>
   <para>
    <example>
     <title>Zwracanie tablicy</title>
     <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Aby zwrócić referencję, użyj operatora &amp; zarówno
    w deklaracji funkcji jak i podczas przypisywania zwracanej wartości
    zmiennej:
   </para>
   <para>
    <example>
     <title>Zwracanie referencji</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Aby uzyskać więcej informacji o referencjach, przejdź do <link
    linkend="language.references">Wyjaśnienie Referencji</link>.
   </simpara>
  </sect1>
 
  <sect1 xml:id="functions.variable-functions">
   <title>Funkcje zmiennych</title>

   <para>
    PHP obsługuje opcję funkcji zmiennych. Oznacza to, że jeśli
    do nazwy zmiennej dodane są nawiasy, PHP postara się znaleźć
    funkcję o nazwie takiej jak wartość zmiennej
    i spróbuje ją wykonać. Między innymi, może to służyć do
    zaimplementowania tzw. callbacks, tablic funkcji, a także wielu innych rzeczy.
   </para>
   <para>
    Funkcje zmiennych nie zadziałają z takimi elementami języka
    jak <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function> i podobnymi. Używaj okrężnych funkcji
    aby skorzystać z któregoś z powyższych elementów języka jako funkcji zmiennych.
   </para>
   <para>
    <example>
     <title>Przykład funkcji zmiennych</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "W foo()<br />\n";
}

function bar($arg = '')
{
    echo "W bar(); argumentem było '$arg'.<br />\n";
}

// To jest funkcja okrężna dla "echo"
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Wywołuje foo()

$func = 'bar';
$func('test');  // Wywołuje bar()

$func = 'echoit';
$func('test');  // Wywołuje echoit()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Jako funkcje zmiennych mogą być także wywoływane metody obiektów.
    <example>
     <title>Przykład metod zmiennych</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Zmienna()
    {
        $name = 'Bar';
        $this->$name(); // Wywołuje metodę Bar()
    }
    
    function Bar()
    {
        echo "To jest Bar";
    }
}

$foo = new Foo();
$funcname = "Zmienna";
$foo->$funcname();  // Wywołuje $foo->Zmienna()

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Gdy wywołuje się metody statyczne, wywołanie funkcji jest mocniejsze niż operator własności statycznej:
    <example>
     <title>Przykład zmiennej metody z właściwościami statycznymi</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $zmienna = 'własność statyczna';
    static function Zmienna()
    {
        echo 'Wywołano metodę Zmienna';
    }
}

echo Foo::$zmienna; // Wyświetli 'własność statyczna'. Potrzebna jest $zmienna w tym zasięgu.
$zmienna = "Zmienna";
Foo::$variable();  // Wywoła $foo->Zmienna() odczytując $zmienna w tym zasięgu.

?>
]]>
     </programlisting>
    </example>
   </para>
      
   <para>
    Zobacz także <function>is_callable</function>, <function>call_user_func</function>,
    <link linkend="language.variables.variable">
    zmienne zmienne</link> oraz <function>function_exists</function>.
   </para>
  </sect1>
  
  <sect1 xml:id="functions.internal">
   <title>Wewnętrzne (wbudowane) funkcje</title>
   
   <para>
    PHP zapewnia wiele wbudowanych funkcji i konstrukcji. Istnieją także
    funkcje wymagające wkompilowania specyficznych rozszerzeń PHP, w przeciwnym wypadku
    wywołanie ich skutkuje błędami "undefined function". Na przykładd, aby użyć funkcji
    <link linkend="ref.image">obrazków</link> takich jak
    <function>imagecreatetruecolor</function>, PHP musi być skompilowane z obsługą
    <productname>GD</productname>. Aby użyć
    <function>mysql_connect</function>, PHP musi być skompilowane z obsługą
    <link linkend="ref.mysql">MySQL</link>. Jest wiele funkcji wbudowanych
    w rdzeń każdej wersji PHP, takich jak funkcje
    <link linkend="ref.strings">typu string</link> oraz 
    <link linkend="ref.var">zmiennych</link>. Wywołanie
    to <function>phpinfo</function> lub
    <function>get_loaded_extensions</function> pokaże, które rozszerzenia
    PHP są załadowane. Zauważ, że wiele rozszerzeń jest domyślnie załadowanych i 
    podręcznik PHP jest podzielony według rozszerzeń. Zobacz rozdziały o 
    <link linkend="configuration">konfiguracji</link>,
    <link linkend="install">instalacji</link>, a także te dotyczące
    poszczególnych rozszerzeń, aby dowiedzieć się jak uruchomić PHP.
   </para>
   <para>
    Czytanie i rozumienie prototypów funkcji wyjaśnione jest w rozdziale
    podręcznika zatytułowanym <link linkend="about.prototypes">jak czytać
    definicje funkcji</link>. Ważne jest zrozumienie, czy funkcja zwraca konkretną wartość
    czy operuje bezpośrednio na podanej zmiennej. Na przykład,
    <function>str_replace</function> zwróci zmodyfikowany obiekt typu string, podczas gdy
    <function>usort</function> pracuje bezpośrednio na podanej zmiennej.
    Każda funkcja posiada swoją stronę w podręczniku PHP, która podaje informacje takie jak
    parametry funkcji, jej zachowanie, wartości zwracane po poprawnym wykonaniu i w przypadku błędu,
    a także dane dotyczące jej dostępności.
    Znanie tych ważnych (chociaż często drobnych) różnic jest kluczowe podczas
    pisania kodu w PHP.
   </para>
   <note>
    <simpara>
     Jeśli parametry podane funkcji nie są takie, jak spodziewane, na przykład 
     tablica(<type>array</type>) podawana jest w miejscu, gdzie oczekiwana jest zmienna typu <type>string</type>, 
     wartość zwracana przez funkcję nie jest zdefiniowana. W takim wypadku funkcja prawdopodobnie
     zwróci &null; ale jest to jedynie konwencja
     a nie zasada, na której można się opierać.
    </simpara>
   </note>
   <para>
    Zobacz także <function>function_exists</function>, 
    <link linkend="funcref">the function reference</link>,
    <function>get_extension_funcs</function> i 
    <function>dl</function>.
   </para>
   
  </sect1>
  
  <sect1 xml:id="functions.anonymous">
   <title>Funkcje anonimowe</title>

   <simpara>
    Funkcje anonimowe, znane także jako <literal>closures</literal> (pol. domknięcia), pozwalają
    pozwalają na utworzenie funkcji, które nie mają określonej nazwy. Są najbardziej użyteczne jako
    wartość parametru typu <link linkend="language.types.callback">callback</link>,
    ale mają też wiele innych zastosowań.
   </simpara>

   <example>
    <title>Przykład funkcji anonimowej</title>
    <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// wyświetli helloWorld
?>
]]>
    </programlisting>
   </example>

   <simpara>
    Domknięcia mogą zostać użyte także jako wartości zmiennych; PHP automatycznie 
    konwertuje takie wyrażenia na instancje
    wewnętrznej klasy <classname>Closure</classname>. Przypisanie domknięcia do
    zmiennej korzysta z takiej samej składni jak każde inne przypisanie, włączając w to
    średnik na końcu:
   </simpara>

   <example>
    <title>Przypisanie funkcji anonimowej do zmiennej</title>
    <programlisting role="php">
<![CDATA[
<?php
$greet = function($name)
{
    printf("Witaj %s\r\n", $name);
};

$greet('Świecie');
$greet('PHP');
?>
]]>
    </programlisting>
   </example>
   
   <simpara>
    Domknięcia mogą także dziedziczyć zmienne z zasięgu nadrzędnego. 
    Każda taka zmienna musi być przekazana za pomocą kontrukcji <literal>use</literal>. 
    Dziedziczenie zmiennych z zasięgu nadrzędnego to <emphasis>nie</emphasis> 
    to samo co użycie zmiennych globalnych. 
    Zmienne globalne istnieją w zasięgu globalnym, który jest jednakowy
    bez względu na wykonywaną funkcję. Nadrzędnym zasięgiem domknięcia jest
    funkcja, w której domknięcie zostało zadeklarowane (niekoniecznie funkcja,
    z której zostało wykonane). Zobacz poniższy przykład:
   </simpara>

   <example>
    <title>Domknięcia i zasięg</title>
    <programlisting role="php">
<![CDATA[
<?php
// Podstawowy koszyk sklepowy, który zawiera listę dodanych produktów
// i ilość każdego z nich. Zawiera metodę, która
// liczy całkowitą cenę produktów w koszyku używając
// funkcji anonimowej jako callbacku.
class Cart
{
    const PRICE_BUTTER  = 1.00;
    const PRICE_MILK    = 3.00;
    const PRICE_EGGS    = 6.95;

    protected $products = array();
    
    public function add($product, $quantity)
    {
        $this->products[$product] = $quantity;
    }
    
    public function getQuantity($product)
    {
        return isset($this->products[$product]) ? $this->products[$product] :
               FALSE;
    }
    
    public function getTotal($tax)
    {
        $total = 0.00;
        
        $callback =
            function ($quantity, $product) use ($tax, &$total)
            {
                $pricePerItem = constant(__CLASS__ . "::PRICE_" .
                    strtoupper($product));
                $total += ($pricePerItem * $quantity) * ($tax + 1.0);
            };
        
        array_walk($this->products, $callback);
        return round($total, 2);
    }
}

$my_cart = new Cart;

// Dodaj produkty do koszyka
$my_cart->add('butter', 1);
$my_cart->add('milk', 3);
$my_cart->add('eggs', 6);

// Wyświetl całkowitą cenę z 5% podatkiem.
print $my_cart->getTotal(0.05) . "\n";
// Wynik to 54.29
?>
]]>
    </programlisting>
   </example>
   
   <simpara>
    Funkcje anonimowe są implementowane przez klasę <link linkend="class.closure">
    <classname>Closure</classname></link>.
   </simpara>
   
   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>5.4.0</entry>
         <entry>
          <varname>$this</varname> może zostać użyte w funkcjach anonimowych.
         </entry>
        </row>
        <row>
         <entry>5.3.0</entry>
         <entry>
          Funkcje anonimowe stały się dostępne.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      Jest możliwe użycie <function>func_num_args</function>,
      <function>func_get_arg</function> i <function>func_get_args</function>
      z poziomu funkcji anonimowej.
     </simpara>
    </note>
   </sect2>

  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
