<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: 1.31 Maintainer: leszek Status: ready -->
<!-- $Revision: 1.13 $ -->
 <chapter xml:id="language.expressions" xmlns="http://docbook.org/ns/docbook">
   <title>Wyra¿enia</title>

   <simpara>
    Wyra¿enia s± nawa¿niejszymi elementami sk³adowymi PHP. W PHP prawie
    wszystko co napiszesz jest wyra¿eniem. Najprostsz± i najdok³adniejsz±
    definicj± wyra¿enia jest "wszystko co ma warto¶æ".
   </simpara>

   <simpara>
    Najbardziej podstawow± form± wyra¿eñ s± sta³e i zmienna. Je¶li napiszesz
    "$a = 5" przypisujesz '5' do '$a'. '5' ma oczywi¶cie warto¶æ 5, lub innymi
    s³owy '5' jest wyra¿eniem o warto¶ci 5 (w tym przypadku, '5' jest sta³±
    liczb± ca³kowit±).
   </simpara>

   <simpara>
    Po tym przypisaniu mo¿esz siê spodziwaæ, ¿e warto¶ci± $a jest tak¿e 5, wiêc
    je¶li napiszesz "$b = $a" mo¿esz siê spodziewaæ, ¿e bêdzie to równoznaczne
    z napisaniem "$b = 5". Innymi s³owy, $a jest wyra¿eniem o warto¶ci 5.
    Je¶li wszystko dzia³a prawid³owo, wszystko bêdzie siê dziaæ tak jak
    napisano wy¿ej.
   </simpara>

   <para>
    Trochê bardziej z³o¿onymi przyk³adami wyra¿eñ s± funkcje. Przyjrzyj siê
    poni¿szej funkcji:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo ()
{
    return 5;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <simpara>
    Zak³adaj±c ¿e oswoi³e¶ siê z koncepcj± funkcji (je¶li nie, przejrzyj
    najpierw rozdzia³ o <link linkend="language.functions">funkcjach</link>),
    mo¿esz za³o¿yæ, ¿e napisanie <literal>$c = foo()</literal> jest
    równoznaczne z napisaniem <literal>$c = 5</literal>, i masz raciê. Funkcje
    s± wyra¿eniami o warto¶ci któr± zwracaj±. Poniewa¿ foo() zwraca 5,
    warto¶ci± wyra¿enia 'foo()' jest 5. Zazwyczaj funkcje nie zwracaj±
    statycznej warto¶ci, ale co¶ obliczaj±.
   </simpara>

   <simpara>
    Oczywi¶cie warto¶ci w PHP nie musz± byæ liczbami ca³kowitymi, i bardzo
    czêsto nie s± nimi. PHP obs³uguje 3 skalarne warot¶ci danych: warto¶ci
    ca³kowite (<type>integer</type>), warto¶ci rzeczywiste (<type>float</type>
    i ci±gi znaków (<type>string</type>) (warto¶ci skalarne
    to takie, których nie mo¿esz 'rozbiæ' na mniejsze kawa³ki, w
    przeciwieñstwie do np. tablic). PHP obs³uguje tak¿e dwa z³o¿one
    (nieskalarne) typy danych: tablice i obiekty. Ka¿d± z tych warto¶ci mo¿na
    przypisaæ do zmiennych lub mo¿e byæ zwrócona przez funkcjê.
   </simpara>

   <simpara>
    PHP rozwija wyra¿enia znacznie bardziej, podobnie jak wiele innych jêzyków
    programowania.  PHP jest jêzykiem zorientowanym na wyra¿enia, co oznacza
    ¿e prawie wszystko jest wyra¿eniem. Przyjrzyj siê przyk³adowi który ju¿
    analizowali¶my, '$a = 5'. £atwo jest zauwa¿yæ, ¿e s± tu dwie warto¶ci.
    Warto¶æ sta³ej ca³kowitej '5', a tak¿e warto¶æ $a, która zostanie
    zamieniona na 5. Ale tak naprawdê jest tu jeszcze jedna warto¶æ, któr±
    jest warto¶æ operacji przypisania. Przypisanie przyjmuje warto¶æ
    przypisywanej warto¶ci, w tym przypadku 5. W praktyce oznacza to, ¿e '$a =
    5', niezale¿nie co to robi, jest wyra¿eniem o warto¶ci 5. Wynika z tego,
    ¿e napisanie '$b = ($a = 5)' jest równoznaczne napisaniu '$a = 5; $b = 5;'
    (¶rednik oznacza koniec instrukcji). Poniewa¿ przypisania s± przetwarzane
    od prawej do lewej, mo¿esz tak¿e napisaæ '$b = $a = 5'.
   </simpara>

   <simpara>
    Kolejnym dobrym przyk³adem orientacji wyra¿eniowej jest pre- i
    postinkrementacja i dekrementacja. U¿ytkownicy PHP i wielu innych
    jêzyków mog± byæ ju¿ zaznajomieni z notacj± zmienna++ i zmienna--. S± to
    <link linkend="language.operators.increment">operatory inkrementacji i
     dekrementacji</link>. W PHP/FI 2 instrukcja '$a++' nie ma warto¶ci (nie
    jest wyra¿eniem), wiêc nie mo¿esz jej przypisaæ lub u¿yæ w jakikolwiek
    sposób. PHP rozszerza mo¿liwo¶ci inkrementacji/dekrementacji robi±c tak¿e
    z nich wyra¿enia, podobnie jak w C. W PHP, tak jak w C, sa dwa typy
    inkrementacji: preinkrementacja i postinkrementacja. I pre- i
    postinkrementacja zwiêkszaj± warto¶æ zmiannej, wiêc efekt w stosunku do
    zmiennej jest taki sam. Ró¿nica jest w warto¶ci wyra¿enia inkrementacji.
    Preinkrementacja, która jest oznaczana jako '++$zmienna', zwraca
    zwiêkszon± warto¶æ (PHP zwiêksza zmienn± przed odczytaniem warto¶ci,
    dlatego nazywa siê to 'pre-inkrementacj±'). Postinkrementacja, która jest
    oznaczana jako '$zmienna++', zwraca orginaln± warto¶æ $zmienna przed
    zwiêkszeniem jej warto¶ci (PHP zwiêksza warto¶æ po odczytaniu jej
    warto¶ci, st±d nazwa 'post-inkrementacja').
   </simpara>

   <simpara>
    Popularnym typem wyra¿eñ s± <link
     linkend="language.operators.comparison">porównania</link>. Wyra¿enia te
    zwracaj± warto¶æ &false; lub &true;. PHP
    obs³uguje &gt; (wiêkszy), &gt;= (wiêkszy lub równy), == (równy), != (nie
    równy), &lt; (mniejszy) i &lt;= (mniejszy lub równy). Jêzyk obs³uguje
    tak¿e zbiór operatorów ¶cis³ego porównania: === (równy i tego samego typu)
    i !== (nie równy lub ró¿nego typu).  Wyra¿enia te s± powszechnie u¿ywane
    przy sprawdzaniu warunków, jak na przyk³ad instrukcje
    <literal>if</literal>.
   </simpara>

   <simpara>
    Ostatnim przyk³adem, którym bêdziemy siê tu zajmowaæ s± po³±czone
    wyra¿enia operacji i przypisania. Ju¿ wiesz, ¿e je¶li chcesz zwiêkszyæ
    warto¶æ zmiennej $a o 1, mo¿esz po prostu napisaæ '$a++' lub '++$a'. Ale
    co je¶li chcesz dodaæ do niej wiêcej ni¿ jeden, na przyk³ad 3? Móg³by¶
    napisaæ wielokrotnie '$a++', ale nie jest to sposób ani efektywny ani
    wygodny. Czê¶ciej spotykane jest u¿ywanie instrukcji '$a = $a + 3'. '$a +
    4' zwraca warto¶æ zmiennej $a plus 3, która jest przypisywana z powrotem do
    $a, co oznacza zwiêkszenie warto¶ci zmiennej $a o 3. W PHP, tak jak kilku
    innych jêzykach jak na przyk³ad C, mo¿esz napisaæ to krócej, co z czasem
    stanie siê tak¿e bardziej przejrzyste i ³atwiejsze do zrozumienia. Dodanie
    4 do bie¿±cej warto¶ci $a mo¿e byæ zapisane jako '$a += 4'. Oznacza to
    dok³adnie "we¼ warto¶æ $a, dodaj do niej 3 i przypisz j± z powrotem do $a".
    Oprócz bycia krótsz± i bardziej przejrzyst±, instrukcja ta jest tak¿e
    szybsza w wykonaniu. Warto¶æ '$a += 5', tak jak warto¶æ zwyk³ego
    przypisania, jest przypisywan± warto¶ci±. Zauwa¿, ¿e NIE jest to 4, ale
    po³±czona warot¶æ $a i 4 (jest to warto¶æ która jest przypisywana do $a).
    Dowolne dwuoperandowe operatory mog± byæ u¿yte w trybie
    operacji-przypisania, na przyk³ad '$a -= 5' (odejmij 5 od warto¶ci $a),
    '$b *= 7' (pomnó¿ warto¶æ $b przez 7), itp.
   </simpara>

   <para>
    Jest jeszcze jedno wyra¿enie, które mo¿e siê wydaæ dziwne je¶li nie
    widzia³e¶ go w innych jêzykac, trójoperandowy operator warunkowy:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$pierwsze ? $drugie : $trzecie
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para> 
    Je¶li warto¶ci± pierwszego podwyra¿enia jest &true; (rózna od zera), to
    zwracany jest drugie podwyra¿anie, i jest to wynik wyra¿enia warunkowego.
    W przeciwnym wypadku, zwracana jest warto¶æ trzeciego podwyra¿enia.
   </para>
   <para>
    Poni¿szy przyk³ad powinien pomóc w lepszym zrozumieniu pre- i
    postinkrementacji i ogólnie koncepcji wyra¿eñ:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function double($i)
{
    return $i*2;
}
$b = $a = 5;        /* przypisz warto¶æ piêc do zmiennej $a i $b */
$c = $a++;          /* postinkrementuj, przypisz pocz±tkow± warto¶æ
                       $a (5) do $c */
$e = $d = ++$b;     /* preinkrementuj, przypisz zwiêkszon± warto¶æ
                       $b (6) to $d i $e */

/* w tym momencie i $d i $e s± równe 6 */

$f = double($d++);  /* przypisz podwojon± warto¶æ $d przed
                       inkrementacji, 2*6 = 12 do $f */
$g = double(++$e);  /* przypisz podwojon± warto¶æ $e po
                       inkrementacji, 2*7 = 14 do $g */
$h = $g += 10;      /* na pocz±tku $g jest zwiêkszane o 10 i przyjmuje 
                       warto¶æ 24; warto¶æ przypisania (24) jest pó¼niej
                       przypisywana do $h, które przyjmuje warto¶æ 24. */
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <simpara>
    Na pocz±tku rozdzia³u powiedzieli¶my, ¿e bêdziemy opisywaæ ró¿ne typy
    instrukcji, i tak jak obiecywali¶my, wyra¿enia mog± byæ instrukcjami.
    Jednak¿e nie ka¿de wyra¿enie jest instrukcj±. 

    Niektóre wyra¿enia mog± byæ instrukcjami. Ten przypadek ma postaæ
    'wyra¿enie' ';', czyli wyra¿enie a po nim ¶rednik. W '$b=$a=5;', $a=5 jest
    poprawnym wyra¿eniem, ale nie jest instrukcj±. Jednak¿e '$b=$a=$b;' jest
    poprawn± intrukcj±.</simpara>

   <simpara>
    Ostatni± rzecz± wart± uwagi jest warto¶æ prawdy wyra¿eñ. W wielu
    przypadkach, g³ównie przy sprawdzaniu warunkow i w pêtlach, nie interesuje
    ciê warto¶æ wyra¿enia, ale tylko czy oznacza &true; czy &false;.
    
    <!-- (PHP nie mam dedykowanego typu boolean) : ¬LE, ma -->
    
    Sta³e &true; i &false; (niezale¿ne od wielko¶ci znaków) s± dwiema
    mo¿liwymi warto¶ciami logicznymi. Kiedy to konieczne, wyra¿enie jest
    automatycznie konwertowane na typ boolean. Zobacz
    <link linkend="language.types.typecasting">rozdzia³ o rzutowaniu typów
    </link> je¶li interesuj± ciê szczegó³y jak to jest przeprowadzane.
   </simpara>
   <simpara>
    PHP dostarcza pe³nej i potê¿nej implementacji wyra¿eñ i ca³kowita ich
    dokumentacja przekracza ramy tego podrêcznika. Powy¿sze przyk³ady powinny
    daæ ci ogólne pojêcie czym s± wyra¿enia i jak mo¿esz konstruowaæ przydatne
    wyra¿enia. Przez resztê podrêcznika bêdziemy pisaæ
    <varname>expr</varname> aby oznaczyæ dowolne poprawne wyra¿enie
    PHP.
   </simpara>

  </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml encoding=iso-8859-2
vi: ts=1 sw=1
-->
