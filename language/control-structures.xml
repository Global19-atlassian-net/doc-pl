<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: 1.59 Maintainer: qrak Status: ready -->
<!-- $Revision: 1.4 $ -->
 <chapter id="control-structures">
  <title>Struktury kontrolne</title>

  <simpara>
   Ka¿dy skrypt PHP zbudowany jest z wyra¿eñ. Wyra¿eniem mo¿e byæ przypisanie,
   odwo³anie do funkcji, pêtla, wyra¿enie warunkowe, a nawet wyra¿enie, które
   nic nie robi (puste wyra¿enie). Wyra¿enia zwykle koñcz± siê znakiem ¶rednika.
   Dodatkowo, wyra¿enia mog± byæ grupowane przez umieszczenie ich w nawiasach
   sze¶ciennych. Grupa wyra¿eñ sama tak¿e jest wyra¿eniem. W tym rozdziale
   opisano rozmaite rodzaje wyra¿eñ.
  </simpara>

  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    Instrukcja <literal>if</literal> (je¿eli) jest jednym z najwa¿niejszych
    mechanizmów dostêpnych w wielu jêzykach z PHP w³±cznie. Pozwala na
    wyodrêbnienie fragmentu kodu, który zostanie wykonany pod okre¶lonym
    warunkiem. Instrukcja <literal>if</literal> w PHP jest bardzo podobna do
    swojego odpowiednika z jêzyka C:
    <informalexample>
     <programlisting>
<![CDATA[
if (warunek)
    wyra¿enie
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Jak opisano w <link linkend="language.expressions">rozdziale na temat
    wyra¿eñ</link>, obliczana jest warto¶æ
    logiczna wyra¿enia <replaceable>warunek</replaceable>. Je¶li
    <replaceable>warunek</replaceable> jest równy &true; 
    <replaceable>wyra¿enie</replaceable> zostanie wykonane; w przeciwnym razie
    zostanie pominiête. Wiêcej informacji na temat obliczania logicznych
    warto¶ci wyra¿eñ w rozdziale <link
    linkend="language.types.boolean.casting">'Konwersja do typu
    boolowskiego'</link>.
   </simpara>
   <para>
    Poni¿szy przyk³ad wy¶wietli napis <computeroutput>a jest wiêksze ni¿
    b</computeroutput>, je¶li <replaceable>$a</replaceable> bêdzie wiêksze od
    <replaceable>$b</replaceable>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b)
    print "a jest wiêksze ni¿ b";
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Czêsto potrzeba, aby wiêcej ni¿ jedna instrukcja by³a wykonana pod przyjêtym
    warunkiem. Nie ma oczywi¶cie potrzeby umieszczaæ ka¿dej z tych instrukcji
    w osobnej strukturze <literal>if</literal>. Zamiast tego nale¿y zgrupowaæ
    te instrukcje za pomoc± instrukcji grupuj±cej. Na przyk³ad poni¿szy kod
    wy¶wietli <computeroutput>a jest wiêksze ni¿ b</computeroutput>, je¿eli
    <replaceable>$a</replaceable> jest wiêksze ni¿
    <replaceable>$b</replaceable>, i przypisze warto¶æ
    <replaceable>$a</replaceable> do <replaceable>$b</replaceable>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b) {
    print "a jest wiêksze ni¿ b";
    $b = $a;
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Instrukcje <literal>if</literal> mog± byæ dowolnie umieszczane wewn±trz
    innych instrukcji <literal>if</literal>, co zapewnia autorowi programu
    kompletn± elastyczno¶æ przy ustalaniu warunkowego wykonywania poszczególnych
    czê¶ci programu.
   </simpara>
  </sect1>

  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
    Czêsto potrzeba wykonaæ jedn± instrukcjê programu, gdy pewien warunek jest
    spe³niony, lub inn± inn±, gdy ten sam warunek nie jest spe³niony. S³u¿y
    do tego instrukcja <literal>else</literal>. <literal>else</literal>
    rozszerza mo¿liwo¶ci instrukcji <literal>if</literal> do sytuacji kiedy
    warunek opisany przy instrukcji <literal>if</literal> ma warto¶æ &false;.
    Na przyk³ad poni¿szy kod wy¶wietli <computeroutput>a jest wiêksze ni¿
    b</computeroutput> je¿eli <replaceable>$a</replaceable> jest wiêksze ni¿
    <replaceable>$b</replaceable>, lub <computeroutput>a NIE jest wiêksze ni¿
    b</computeroutput> w przeciwnym przypadku.:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b) {
    print "a jest wiêksze ni¿ b";
} else {
    print "a NIE jest wiêksze ni¿ b";
}
]]>
     </programlisting>
    </informalexample>
    
    Kod zawarty w instrukcji <literal>else</literal> wykonywany jest tylko
    wówczas, kiedy wyra¿enie logiczne przy instrukcji <literal>if</literal> 
    ma warto¶æ &false;, a je¶li w tej samej grupie znajdowa³y siê te¿ instrukcje
    <literal>elseif</literal> - tylko wówczas je¶li i w tych instrukcjach
    wyra¿enia logiczne mia³y warto¶æ &false; (Patrz tak¿e: instrukcja <link
    linkend="control-structures.elseif">elseif</link>).
   </para>
  </sect1>

  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    Instrukcja <literal>elseif</literal>, jak sama jej nazwa wskazuje, stanowi
    po³±czenie instrukcji <literal>if</literal> i <literal>else</literal>.
    Podobnie jak <literal>else</literal> rozszerza instrukcjê 
    <literal>if</literal> do sytuacji, kiedy wyra¿enie logiczne stoj±ce przy
    <literal>if</literal> ma warto¶æ &false;. Jednak¿e w przeciwieñstwie do
    typowej instrukcji <literal>else</literal>, kod objêty t± instrukcj± bêdzie
    wykonany, je¶li wyra¿enie logiczne stoj±ce przy tej instrukcji bêdzie mia³o
    warto¶æ &true;. Poni¿szy przyk³ad wy¶wietli <computeroutput>a jest wiêksze
    ni¿ b</computeroutput>, <computeroutput>a jest równe b</computeroutput>
    lub <computeroutput>a jest mniejsze ni¿ b</computeroutput>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a > $b) {
    print "a jest wiêksze ni¿ b";
} elseif ($a == $b) {
    print "a jest równe b";
} else {
    print "a jest mniejsze ni¿ b";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Mo¿na u¿yæ kilku instrukcji <literal>elseif</literal> w jednym bloku
    instrukcji <literal>if</literal>. Wykonany wtedy bêdzie ten blok, który
    pierwszy bêdzie mieæ warto¶æ &true;. W PHP mo¿na te¿ napisaæ 'else if'
    (dwoma s³owami) zamiast 'elseif' (jednym s³owem). Z punktu widzenia
    sk³adni jêzyka, wyra¿enia te ró¿ni± siê od siebie (je¶li znasz siê na C,
    jest to ta sama ró¿nica co w C), jednak wynik ich dzia³ania jest ten sam.
   </simpara>
   <simpara>
    Dana instrukcja <literal>elseif</literal> bêdzie wykonana tylko wówczas,
    je¶li wszystkie poprzedzaj±ce j± instrukcje <literal>if</literal> i
    <literal>elseif</literal> w danym bloku mia³y warto¶æ logiczn± &false;,
    a ona sama ma warto¶æ logiczn± &true;.
   </simpara>
  </sect1>

  <sect1 id="control-structures.alternative-syntax">
   <title>Sk³adnia alternatywna w strukturach kontrolnych</title>
   <para>
    PHP oferuje alternatywn± sk³adniê dla niektórych struktur kontrolnych,
    a dok³adnie dla: <literal>if</literal>, <literal>while</literal>,
    <literal>for</literal>, <literal>foreach</literal> i
    <literal>switch</literal>.
    W ka¿dym przypadku podstawowa forma sk³adni alternatywnej polega na zamianie
    nawiasu otwieraj±cego na dwukropek (:), a nawiasu zamykaj±cego na
    odpowiednie s³owo: <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, <literal>endforeach;</literal> lub
    <literal>endswitch;</literal>.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
A jest równe 5
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    W przyk³adzie powy¿ej, blok HTML "A jest równe 5" jest zagnie¿d¿ony w
    instrukcji <literal>if</literal> napisanej w sk³adni alternatywnej. Ten
    fragment kodu HTML zostanie wy¶wietlony tylko wówczas, kiedy $a bêdzie
    równe 5.
   </simpara>
   <para>
    Alternatywna sk³adnia obejmuje te¿ wyra¿enia <literal>else</literal> i
    <literal>elseif</literal>. Poni¿szy przyk³ad prezentuje obydwa
    wyra¿enia zapisane przy pomocy sk³adni alternatywej:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($a == 5):
    print "a jest równe 5";
    print "...";
elseif ($a == 6):
    print "a jest równe 6";
    print "!!!";
else:
    print "a jest ró¿ne od 5 lub 6";
endif;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Wiêcej przyk³adów w rozdzia³ach:
    <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>, i <link
    linkend="control-structures.if">if</link>.
   </para>
  </sect1>

  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    Pêtla <literal>while</literal> jest najprostrzym typem pêtli w PHP.
    Zachowuje siê ona identycznie jak jej odpowiednik z jêzyka C. Jej
    podstawowa forma wygl±da nastêpuj±co:
    <informalexample>
     <programlisting>
<![CDATA[
while (wyra¿enie) instrukcja
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Znaczenie instrukcji <literal>while</literal> jest bardzo proste. Nakazuje
    ona PHP tyle razy wykonywaæ okre¶lone instrukcje, jak d³ugo wyra¿enie
    przy s³owie <literal>while</literal> ma warto¶æ &true;. Warto¶æ tego
    wyra¿enia jest sprawdzana za ka¿dym razem na pocz±tku wykonywania nowej
    iteracji pêtli, wiêc je¶li jego warto¶æ zmieni siê w trakcie wykonywania
    instrukcji, wykonanie ca³ej pêtli nie skoñczy siê do momentu zakoñczenia
    ca³ej iteracji. Jedna iteracja jest to jednokrotne wykonanie wszystkich
    instrukcji w pêtli. Je¶li wyra¿enie logiczne ma warto¶æ &false; ju¿ na
    samym pocz±tku, instrukcje wewn±trz pêtli nie bêd± w ogóle wykonane.
   </simpara>
   <para>
    Podobnie jak w instrukcji <literal>if</literal>, w pêtli
    <literal>while</literal> mo¿na grupowaæ instrukcje za pomoc± nawiasów
    klamrowych, lub przez u¿ycie sk³adni alternatywnej:
    <informalexample>
     <programlisting>
<![CDATA[
while (wyra¿enie): instrukcja; instrukcja; ... endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Poni¿sze przyk³ady s± identyczne i obydwa wy¶wietlaj± liczby od 1 do 10:
    <informalexample>
     <programlisting role="php">
<![CDATA[
/* przyk³ad 1*/

$i = 1;
while ($i <= 10) {
    print $i++;  /* zmienna $i bêdzie inkrementowana po wy¶wietleniu
                    (post-inkrementacja) */
}

/* przyk³ad 2 */

$i = 1;
while ($i <= 10):
    print $i;
    $i++;
endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.do.while">
   <title><literal>do..while</literal></title>
   <simpara>
    Pêtla <literal>do..while</literal> zachowuje siê bardzo podobnie do pêtli
    <literal>while</literal>, z wyj±tkiem tego, ¿e warto¶æ wyra¿enia logicznego
    sprawdzana jest na koñcu iteracji, a nie na pocz±tku. Wynikaj±c± z tego
    g³ówn± ró¿nic± jest to, ¿e pierwsza iteracja w pêtli
    <literal>do..while</literal> na pewno zostanie wykonana (gdy¿ wyra¿enie
    logiczne bêdzie sprawdzone dopiero na koniec iteracji). Natomiast w pêtli
    <literal>while</literal>, gdzie wyra¿enie logiczne jest sprawdzane na
    pocz±tku iteracji, mo¿e doj¶æ do sytuacji, ¿e pêtla w ogóle nie zostanie
    wykonana, je¶li to wyra¿enie bêdzie mia³o warto¶æ &false; od pocz±tku.
   </simpara>
   <para>
    Pêtla <literal>do..while</literal> ma tylko jeden rodzaj sk³adni:

    <informalexample>
     <programlisting role="php">
<![CDATA[
$i = 0;
do {
   print $i;
} while ($i>0);
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Powy¿sza pêtla zostanie wykonana tylko raz, gdy¿ po pierwszej iteracji,
     warto¶æ wyra¿enia logicznego wynosiæ bêdzie &false; ($i nie jest wiêksze
     od 0) i pêtla zostanie zakoñczona.
   </simpara>
   <para>
    Zaawansowani programi¶ci C s± zaznajomieni z innym wykorzystaniem pêtli
    <literal>do..while</literal>, które s³u¿y do przerwania wykonywania bloku
    instrukcji w okre¶lonym momencie przez u¿ycie
    <literal>do..while</literal>(0) i instrukcji <link
    linkend="control-structures.break"><literal>break</literal></link>.
    Demonstruje to poni¿szy kod:
    <informalexample>
     <programlisting role="php">
<![CDATA[
do {
    if ($i < 5) {
        print "i jest za ma³e";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
    print "i jest w porz±dku";

     ...operacje na i...

} while(0);
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Nie przejmuj siê, je¶li nie rozumiesz tego do koñca lub w ogóle. Mo¿esz
    tworzyæ skrypty, nawet zaawansowane skrypty bez u¿ycia tego
    'mechanizmu'.
   </simpara>
  </sect1>

  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    Pêtla <literal>for</literal> jest najbardziej skomplikowanym rodzajem pêtli
    w PHP. Zachowuje siê identycznie jak jej odpowiedniki z C. Jej sk³adnia
    wygl±da nastêpuj±co:
    <informalexample>
     <programlisting>
<![CDATA[
for (wyra¿enie1; wyra¿enie2; wyra¿enie3) instrukcje
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <replaceable>wyra¿enie1</replaceable> jest wykonywane
    tylko raz, na pocz±tku pêtli.
   </simpara>
   <simpara>
    Na pocz±tku ka¿dej nowej iteracji, obliczana jest warto¶æ logiczna
    wyra¿enia <replaceable>wyra¿enie2</replaceable>. Je¶li wynikiem obliczenia
    jest &true;, to pêtla kontynuuje i nastêpuje wykonanie instrukcji
    umieszczonych w pêtli. Je¶li jednak wyra¿enie ma warto¶æ &false;, to 
    wykonanie pêtli zostaje przerwane.
   </simpara>
   <simpara>
    Na koñcu ka¿dej iteracji zostaje wykonane
    <replaceable>wyra¿enie3</replaceable>.
   </simpara>
   <simpara>
    Ka¿de z wyra¿eñ mo¿e byæ puste.
    Puste <replaceable>wyra¿enie2</replaceable> oznacza, ¿e pêtla jest
    nieskoñczona (PHP interpretuje to jako warto¶æ &true;, podobnie z reszt±
    jak C). Nie jest to jednak tak bezu¿yteczne, jak to siê mo¿e wydawaæ,
    gdy¿ czêsto stosuje siê to w po³±czeniu z instrukcj± <link
    linkend="control-structures.break"><literal>break</literal></link>,
    co zastêpuje <replaceable>wyra¿enie2</replaceable> w pêtli
    <literal>for</literal>.
   </simpara>
   <para>
    Wszystkie poni¿sze przyk³ady wy¶wietlaj± liczby od 1 do 10. Proszê zauwa¿yæ
    rozmaite odmiany sk³adni:
    <informalexample>
     <programlisting role="php">
<![CDATA[
/* przyk³ad 1 */

for ($i = 1; $i <= 10; $i++) {
    print $i;
}

/* przyk³ad 2 */

for ($i = 1;;$i++) {
    if ($i > 10) {
        break;
    }
    print $i;
}

/* przyk³ad 3 */

$i = 1;
for (;;) {
    if ($i > 10) {
        break;
    }
    print $i;
    $i++;
}

/* przyk³ad 4 */

for ($i = 1; $i <= 10; print $i, $i++);
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Oczywi¶cie najzgrabniejsza sk³adnia jest w przyk³adzie pierwszym (albo
    czwartym), ale w wielu sytuacjach puste wyra¿enia w pêtli
    <literal>for</literal> bardzo siê przydaj±.
   </simpara>
   <para>
    PHP obs³uguje równie¿ sk³adniê alternatywn± (z dwukropkiem) w pêtli
    <literal>for</literal>.
    <informalexample>
     <programlisting>
<![CDATA[
for (wyra¿enie1; wyra¿enie2; wyra¿enie3): instrukcja; ...; endfor;
]]>
     </programlisting>
     </informalexample>
   </para>
   <para>
    Inne jêzyki programowania posiadaj± pêtlê <literal>foreach</literal>
    do obs³ugi tablic itp. W PHP 3 nie ma takiej pêtli, natomiast zosta³a
    ona dodana do PHP 4. Wiêcej na ten temat w odpowiednim <link
    linkend="control-structures.foreach">rozdziale</link>. W PHP 3 mo¿na
    po³±czyæ instrukcje <link linkend="control-structures.while">while</link>,
    <function>list</function> i <function>each</function> co pozwoli osi±gn±æ
    ten sam efekt. Przyk³ady na to znajduj± siê w rozdzia³ach dotycz±cych
    wy¿ej wymienionych instrukcji.
   </para>

  </sect1>

  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
    PHP 4 zawiera, czego brak w PHP 3, konstrukcjê <literal>foreach</literal>,
    podobn± do jej odpowiedników z Perla i innych jêzyków. Pêtla ta umo¿liwia
    ³atw± iteracjê wewn±trz tablic. Istniej± dwie sk³adnie tej konstrukcji,
    przy czym druga jest mniej wa¿nym, lecz u¿ytecznym rozszerzeniem pierwszej:
    <informalexample>
     <programlisting>
<![CDATA[
foreach(wyra¿enie_tablicowe as $warto¶æ) wyra¿enie
foreach(wyra¿enie_tablicowe as $klucz => $warto¶æ) wyra¿enie
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Pierwsza odmiana iteruje wewn±trz tablicy podanej w
    <literal>wyra¿enie_tablicowe</literal>. Przy ka¿dej iteracji, warto¶æ
    aktualnego elementu tablicy jest przypisywana do zmiennej
    <literal>$warto¶æ</literal>, a wewnêtrzny wska¼nik tablicy jest przesuwany
    o jeden (wiêc w nastêpnej iteracji przypisany zostanie kolejny element
    tablicy).
   </simpara>
   <simpara>
    Druga odmiana dzia³a tak samo jak pierwsza, przy czym klucz aktualnego
    elementu tablicy zostanie przypisany do zmiennej <literal>$klucz</literal>
    w ka¿dej iteracji.
   </simpara>
   <para>
    <note>
     <para>
      Kiedy rozpoczyna siê wykonywanie pêtli <literal>foreach</literal>,
      wewnêtrzny wska¼nik tablicy jest automatycznie resetowany, co ustawia
      go na pierwszym elemencie tablicy. Oznacza to, ¿e nie trzeba wywo³ywaæ
      komendy <function>reset</function> przed rozpoczêciem pêtli
      <literal>foreach</literal>.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Proszê tak¿e pamiêtaæ, ¿e konstrukcja <literal>foreach</literal> operuje
      na kopii tablicy, a nie na oryginale, wiêc po³o¿enie wska¼nika tablicy
      nie jest modyfikowane jak w konstrukcji <function>each</function>,
      a zmiany dokonane na pobranym elemencie tablicy nie oddzia³uj± na
      oryginaln± tablicê.
     </para>
    </note>
   </para>
   <note>
    <para>    
     <literal>foreach</literal> nie pozwala na ukrycie komunikatów
     o b³êdach za pomoc± '@'.
    </para>
   </note>
   <para>
    Mo¿na zauwa¿yæ, ¿e poni¿sze przyk³ady s± funkcjonalnie identyczne:
    <informalexample>
     <programlisting role="php">
<![CDATA[
reset ($tabl);
while (list(, $warto¶æ) = each ($tabl)) {
    echo "Warto¶æ: $warto¶æ<br>\n";
}

foreach ($tabl as $warto¶æ) {
    echo "Warto¶æ: $warto¶æ<br>\n";
}
]]>
     </programlisting>
    </informalexample>
    Poni¿sze przyk³ady s± równie¿ funkcjonalnie identyczne:
    <informalexample>
     <programlisting role="php">
<![CDATA[
reset ($tabl);
while (list($klucz, $warto¶æ) = each ($tabl)) {
    echo "Klucz: $klucz; Warto¶æ: $warto¶æ<br>\n";
}

foreach ($tabl as $klucz => $warto¶æ) {
    echo "Klucz: $klucz; Warto¶æ: $warto¶æ<br>\n";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Wiêcej przyk³adów demonstruj±cych u¿ycie tej pêtli:
    <informalexample>
     <programlisting role="php">
<![CDATA[
/* przyk³ad 1 foreach: tylko warto¶æ */

$a = array (1, 2, 3, 17);

foreach ($a as $v) {
   print "Aktualna warto¶æ \$a: $v.\n";
}

/* przyk³ad 2 foreach: warto¶æ (z kluczem generowanym dla potrzeb ilustracji)*/

$a = array (1, 2, 3, 17);

$i = 0; /* tylko dla potrzeb ilustracyjnych */

foreach($a as $v) {
    print "\$a[$i] => $v.\n";
    $i++;
}

/* przyk³ad 3 foreach: klucz i warto¶æ */

$a = array (
    "jeden" => 1,
    "dwa" => 2,
    "trzy" => 3,
    "siedemna¶cie" => 17
);

foreach($a as $k => $v) {
    print "\$a[$k] => $v.\n";
}

/* przyk³ad 4 foreach: tablice wielowymiarowe */

$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach($a as $v1) {
    foreach ($v1 as $v2) {
        print "$v2\n";
    }
}

/* przyk³ad 5 foreach: tablice dynamiczne */

foreach(array(1, 2, 3, 4, 5) as $v) {
    print "$v\n";
}
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>break</literal> zakañcza wykonywanie aktualnej instrukcji
    <literal>for</literal>, <literal>foreach</literal>
    <literal>while</literal>, <literal>do..while</literal> lub
    <literal>switch</literal>.
   </simpara>
   <simpara>
    <literal>break</literal> akceptuje opcjonalny argument, który mówi, ile
    zagnie¿dzonych struktur kontrolnych ma zostaæ przerwanych w danym momencie.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$arr = array ('jeden', 'dwa', 'trzy', 'cztery', 'stop', 'piêæ');
while (list (, $val) = each ($arr)) {
    if ($val == 'stop') {
        break;    /* Mo¿na tu te¿ napisaæ: 'break 1;' */
    }
    echo "$val<br>\n";
}

/* U¿ycie opcjonalnego argumentu: */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "Na 5<br>\n";
        break 1;  /* Wyjd¼ tylko ze switch. */
    case 10:
        echo "Na 10; wyj¶cie<br>\n";
        break 2;  /* Wyjd¼ ze switch i z while. */
    default:
        break;
    }
}
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal> u¿ywane jest wewn±trz instukcji pêtli do
    przerwania wykonywania danej iteracji pêtli i rozpoczêcia zupe³nie nowej
    iteracji.
   </simpara>
   <simpara>
    <literal>continue</literal> akceptuje opcjonalny argument liczbowy, który
    mówi, ilu poziomów zagnie¿d¿onych pêtli dana instrukcja
    <literal>continue</literal> dotyczy.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
while (list ($klucz, $warto¶æ) = each ($arr)) {
    if (!($klucz % 2)) { // opu¶æ klucze nieparzyste
        continue;
    }
    zrób_co¶_z_nieparzystymi ($warto¶æ);
}

$i = 0;
while ($i++ < 5) {
    echo "Zewnêtrzna<br>\n";
    while (1) {
        echo "&nbsp;&nbsp;¦rodkowa<br>\n";
        while (1) {
            echo "&nbsp;&nbsp;Wewnêtrzna<br>\n";
            continue 3;
        }
        echo "To siê nigdy nie wy¶wietli.<br>\n";
    }
    echo "Ani to.<br>\n";
}
]]>
     </programlisting>
     </informalexample>
    </para>
  </sect1>

  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    Instrukcja <literal>switch</literal> jest podobna do serii instrukcji IF
    z warunkiem na to samo wyra¿enie. W wielu przypadkach istnieje potrzeba
    porównania jednej zmiennej (lub wyra¿enia) z wieloma ró¿nymi warto¶ciami
    i wykonania ró¿nych fragmentów kodu, w zale¿no¶ci od wyniku porównania tej
    zmiennej z ró¿nymi warto¶ciami. Do tego w³a¶nie s³u¿y instrukcja
    <literal>switch</literal>.
   </simpara>
   <para>
    Poni¿ej znajduj± siê dwa przyk³ady wykonuj±ce dok³adnie to samo, przy czym
    jeden z nich wykorzystuje seriê instrukcji <literal>if</literal>, za¶
    drugi u¿ywa instrukcji <literal>switch</literal>:
    <informalexample>
     <programlisting role="php">
<![CDATA[
if ($i == 0) {
    print "i jest równe 0";
}
if ($i == 1) {
    print "i jest równe 1";
}
if ($i == 2) {
    print "i jest równe 2";
}

switch ($i) {
    case 0:
        print "i jest równe 0";
        break;
    case 1:
        print "i jest równe 1";
        break;
    case 2:
        print "i jest równe 2";
        break;
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Wa¿ne jest by zrozumieæ, jak dzia³a instrukcja <literal>switch</literal>,
    ¿eby unikn±æ b³êdów. Instrukcja <literal>switch</literal> jest wykonywana
    linia po linii (dok³adnie wyra¿enie po wyra¿eniu). Na pocz±tku ¿aden
    fragment kodu nie jest wykonywany. Dopiero kiedy zostaje odnalezione
    wyra¿enie <literal>case</literal>, którego warto¶æ odpowiada wyra¿eniu
    przy instrukcji <literal>switch</literal>, PHP rozpoczyna wykonywanie
    kodu od miejsca, gdzie znajduje siê ta instrukcja <literal>case</literal>.
    PHP wykonuje instrukcje a¿ do momentu kiedy blok <literal>switch</literal>
    siê skoñczy, lub do momentu znalezienia instrukcji <literal>break</literal>.
    Je¶li nie napiszesz instrukcji <literal>break</literal> na koñcu instrukcji
    w danym wyra¿eniu <literal>case</literal> to PHP bêdzie wykonywaæ dalej
    instrukcje z nastêpnego wyra¿enia <literal>case</literal>. Na przyk³ad:

    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i) {
    case 0:
        print "i jest równe 0";
    case 1:
        print "i jest równe 1";
    case 2:
        print "i jest równe 2";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    W tym przypadku, je¶li $i jest równe 0, to PHP wykona wszystkie trzy
    instrukcje print. Je¶li natomiast bêdzie równe jeden - wtedy tylko dwie
    ostatnie. Zachowanie zgodne z oczekiwaniami bêdzie wtedy, kiedy $i bêdzie
    równe 2 - wtedy wykonane bêdzie tylko ostatnia instrukcja print. Nie wolno
    zatem zapominaæ o umieszczaniu na koñcu instrukcji <literal>break</literal>,
    chyba ¿e planuje siê wykorzystaæ jakie¶ specjalne mo¿liwo¶ci instrukcji
    <literal>switch</literal>, o czym dalej.
   </simpara>
   <simpara>
    W instrukcji <literal>switch</literal> warto¶æ wyra¿enia jest obliczana
    tylko raz, a nastêpnie jest porównywana z ka¿dym z wyra¿eñ przy etykiecie
    <literal>case</literal>. Natomiast w instrukcji <literal>elseif</literal>
    warto¶æ wyra¿enia jest obliczana ponownie. Dlatego, je¶li twoje wyra¿enie
    jest bardziej skomplikowane od zwyk³ego porównania, lub znajduje siê w
    zwartej pêtli (tight loop), <literal>switch</literal> mo¿e byæ szybszy.
   </simpara>
   <para>
    Po etykiecie case mog± nie wystêpowaæ ¿adne instrukcje, co oznacza po
    prostu, ¿e sterowanie zostaje przekazane do nastêpnej etykiety case.
    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i) {
    case 0:
    case 1:
    case 2:
        print "i jest mniejsze od 3, ale nie jest ujemne";
        break;
    case 3:
        print "i jest równe 3";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Specjaln± etykiet± jest etykieta warunku domy¶lnego - 
    <literal>default</literal>. Etykieta ta dotyczy sytuacji, w której wyra¿enie
    nie pasowa³o do warto¶ci przy innych etykietach typu
    <literal>case</literal>.
    W instrukcji <literal>switch</literal> ta etykieta powinna byæ ostatnia
    z listy. Na przyk³ad:
    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i) {
    case 0:
        print "i jest równe 0";
        break;
    case 1:
        print "i jest równe 1";
        break;
    case 2:
        print "i jest równe 2";
        break;
    default:
        print "i jest ró¿ne od 0, 1 i 2";
}
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Etykieta <literal>case</literal> mo¿e zawieraæ dowoln± warto¶æ typu
    prostego, czyli liczbê ca³kowit±, zmiennoprzecinkow± lub ³añcuch znaków.
    Tablice lub obiekty nie mog± byæ u¿yte, o ile nie zostan± przekszta³cone
    w jaki¶ typ prosty.
   </para>
   <para>
    Instrukcja switch obs³uguje te¿ sk³adniê alternatywn±. Wiêcej informacji
    na ten temat w rozdziale <link
    linkend="control-structures.alternative-syntax">Sk³adnia alternatywna w
    strukturach kontrolnych</link>. 
    <informalexample>
     <programlisting role="php">
<![CDATA[
switch ($i):
    case 0:
        print "i jest równe 0";
        break;
    case 1:
        print "i jest równe 1";
        break;
    case 2:
        print "i jest równe 2";
        break;
    default:
        print "i jest ró¿ne od 0, 1 i 2";
endswitch;
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
    Instrukcja <literal>declare</literal> s³u¿y do ustawienia dyrektyw
    wykonawczych dla bloku kodu. Sk³adnia instrukcji jest podobna do sk³adni 
    innych struktur kontrolnych:
    <informalexample>
     <programlisting>
<![CDATA[
declare (dyrektywa) instrukcje
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Argument <literal>dyrektywa</literal> pozwala na ustawienie zachowania
    siê danego bloku <literal>declare</literal>.
    W chwili obecnej rozpoznawana jest tylko jedna dyrektywa:
    <literal>ticks</literal>. (Wiêcej informacju na temat dyrektywy
    <link linkend="control-structures.declare.ticks">ticks</link>
    w dedykowanym podrozdziale).
   </para>
   <para>
    Kod zawarty w bloku <literal>instrukcje</literal> bêdzie wykonywany. Sposób
    i poboczne efekty wykonania tego kodu mog± zale¿eæ od argumentu
    <literal>dyrektywa</literal>.
   </para>
   <sect2 id="control-structures.declare.ticks">
    <title>Ticks</title>
    <para>
    Tykniêcie (tick) jest zdarzeniem, które nastêpuje po ka¿dych 
    <replaceable>N</replaceable> niskopoziomowych instrukcjach wykonywanych
    przez parser wewn±trz bloku <literal>declare</literal>. Warto¶æ parametru
    <replaceable>N</replaceable> jest okre¶lana przez umieszczenie wyra¿enia
    <literal>ticks=<replaceable>N</replaceable></literal> wewn±trz argumentu
    <literal>dyrektywa</literal> danego bloku <literal>declare</literal>.
   </para>
   <para>
    Zdarzenie wywo³ywanie na ka¿de tykniêcie okre¶la siê przez u¿ycie funkcji
    <function>register_tick_function</function>. Wiêcej szczegó³ów znajduje
    siê w poni¿szym przyk³adzie. Proszê pamiêtaæ, ¿e z ka¿dym tykniêciem mo¿e
    byæ wywo³ywane wiêcej ni¿ jedno zdarzenie.
   </para>
   <para>
    <example>
     <title>Profilowanie sekcji kodu PHP </title>
     <programlisting role="php">
<![CDATA[
<?php
// funkcja, która zapisuje czas jej wywo³ania
function profile ($wyrzuæ = FALSE)
{
    static $profile;

    // zwróæ tablicê czasów wywo³ania i wykasuj jej lokaln± kopiê
    if ($wyrzuæ) {
        $temp = $profile;
        unset ($profile);
        return ($temp);
    }

    $profile[] = microtime ();
}

// ustal wska¼nik tykniêcia
register_tick_function("profile");

// zainicjowanie funkcji przed blokiem declare
profile ();

// wykonaj poni¿szy kod, generuj±c tykniêcie co 2 instrukcje
declare (ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text (md5($x), md5($x*$x)), "<br />";
    }
}

// Wy¶wietl dane przechowywane w profilerze
print_r (profile (TRUE));
?>
]]>
     </programlisting>
    </example>
    Powy¿szy przyk³ad profiluje kod PHP wewn±trz bloku "declare", zapisuj±c
    czas wywo³ania co drugiej niskopoziomowej instrukcji w bloku instrukcji.
    Informacjê tê mo¿na wykorzystaæ do wykrycia fragmentów kodu wykonywanych
    w zbyt wolnym tempie. Problem wyszukania takich fragmentów mo¿na
    zrealizowaæ na wiele sposobów, przy czym u¿ycie tykniêæ jest najwygodniesze
    i naj³atwiejsze do zaimplementowania.
   </para>
   <simpara>
    Tykniêcia s± doskonale przystosowane dla potrzeb debugowania, implementacji
    prostej wielozadaniowo¶ci, wykonywania operacji We/Wy w tle i wielu innych
    zadañ.
   </simpara>
   <simpara>
    Patrz tak¿e <function>register_tick_function</function> i
    <function>unregister_tick_function</function>.
   </simpara>
   </sect2>
  </sect1>

  <sect1 id="function.return">
   <title>return</title>
   <simpara>
    Instrukcja <function>return</function>, wywo³ana z wnêtrza funkcji,
    natychmiastowo zakañcza wykonywanie tej funkcji i zwraca jako jej warto¶æ
    swój argument. <function>return</function> zakañcza równie¿ wykonywanie
    instrukcji <function>eval</function> lub danego pliku skryptowego.
   </simpara>
   <simpara>
    Instrukcja ta, wywo³ana w zasiêgu globalnym, zakañcza wykonywanie ca³ego
    pliku skryptowego. Je¶li dany skrypt by³ do³±czony funkcjami
    <function>include</function> lub <function>require</function>, sterowanie
    zostaje zwrócone do pliku wywo³uj±cego. Poza tym, je¶li plik zosta³
    do³±czony funkcj± <function>include</function>, argument przekazany do
    funkcji <function>return</function> bêdzie zwrócony jako warto¶æ funkcji
    <function>include</function>. Je¶li funkcja <function>return</function>
    zostanie wywo³ana w g³ównym pliku skryptowym, nast±pi zakoñczenie ca³ego
    skryptu. Je¶li dany skrypt zosta³ wywo³any przez dyrektywy konfiguracyjne
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link> lub <link
    linkend="ini.auto-append-file">auto_append_file</link> w <link
    linkend="configuration.file">plik konfiguracyjnym</link>, wtedy wykonywnie
    tego pliku skryptowego zostanie zakoñczone.
   </simpara>
   <simpara>Wiêcej informacji w rozdziale <link
   linkend="functions.returning-values">zwracanie warto¶ci</link>.
   </simpara>
   <note>
    <simpara>
     Proszê zauwa¿yæ, ¿e poniewa¿ <function>return</function> jest konstrukcj±
     jêzykow± a nie funkcj±, nawiasy otaczaj±ce jej argumenty nie s± konieczne.
     W rzeczywisto¶ci czê¶ciej s± one opuszczane przez programistów, choæ
     opuszczenie ich, czy nie, nie zmienia niczego.
    </simpara>
   </note>
  </sect1>


 <sect1 id="function.require">
   <title><function>require</function></title>

   <simpara>
    Instrukcja <function>require</function> s³u¿y do wczytania i wykonania
    skryptu z okre¶lonego pliku.
   </simpara>
   <simpara>
     <function>require</function> wczytuje i wykonuje skrypt z podanego pliku.
     Szczegó³owa informacja odno¶nie tego, jak dzia³a wczytywanie opisana jest
     w dokumentacji dla instrukcji <function>include</function>.
   </simpara>
   <simpara>
     Instrukcje
     <function>require</function> i <function>include</function>
     s± identyczne w ka¿dym szczególe, z wyj±tkiem obs³ugi b³êdów.
     W razie niepowodzenia, <function>include</function> generuje ostrze¿enie
     (<link linkend="internal.e-warning">Warning</link>), podczas gdy
     <function>require</function> generuje b³±d krytyczny (<link
     linkend="internal.e-error">Fatal Error</link>). Innymi s³owy, instrukcji
     <function>require</function> u¿ywa siê do wczytywania plików, które s±
     niezbêdne do dzia³ania skryptu i w przypadku ich braku wykonywanie skryptu
     musi zostaæ przerwane. Instukcja <function>include</function> nie zachowuje
     siê w ten sposób. W jej przypadku, przy braku pliku wykonywanie skryptu
     bêdzie kontynuowane. Proszê równie¿ pamiêtaæ o w³a¶ciwym ustawieniu
     dyrektywy konfiguracyjnej <link
     linkend="ini.include-path">include_path</link>.
   </simpara>
   <para>
    <example>
     <title>Podstawowe przyk³ady u¿ycia <function>require</function></title>
     <programlisting role="php">
<![CDATA[
<?php

require 'nag³ówek.php';

require $plik;

require ('jaki¶_plik.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    Wiêcej przyk³adów w dokumentacji instrukcji <function>include</function>.
   </simpara>
   <note>
    <simpara>
     Pocz±wszy od PHP 4.0.2, zachowanie instrukcji jest nastêpuj±ce:
     <function>require</function> bêdzie zawsze próbowaæ odczytaæ plik docelowy,
     nawet je¶li linia w której ona siê znajduje nigdy nie zostanie wykonana.
     Instrukcja warunkowa nie wp³ywa na dzia³anie <function>require</function>.
     Jednak¿e, je¶li linia, w której pojawia siê <function>require</function>
     nie zostaje wykonana, zawarto¶æ pliku wczytywanego te¿ nie zostaje
     wykonana. Podobnie, instrukcje pêtli nie wp³ywaj± na dzia³anie
     <function>require</function>. Chocia¿ kod zawarty w pliku docelowy wci±¿
     jest podmiotem pêtli, <function>require</function> dzia³a tylko raz.
    </simpara>
   </note>
   &warn.no-win32-fopen-wrapper;
   <simpara>
    Patrz tak¿e <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>eval</function>, 
    <function>file</function>, <function>readfile</function>, 
    <function>virtual</function> i
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

 <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
    Instrukcja <function>include</function> s³u¿y do wczytania i wykonania
    kodu z okre¶lonego pliku w trakcie wykonywania skryptu.
   </simpara>
   <simpara>
     Poni¿sza dokumentacja dotyczy tak¿e instrukcji 
     <function>require</function>. Obydwie instrukcje s± identyczne w ka¿dym
     szczególe, z wyj±tkiem obs³ugi b³êdów. <function>include</function>
     generuje b³±d typu <link linkend="internal.e-warning">Warning</link>,
     podczas gdy <function>require</function> generuje b³±d <link
     linkend="internal.e-error">Fatal Error</link>. Innymi s³owy, funkcji
     <function>require</function> u¿ywa siê, by zatrzymaæ przetwarzanie
     skryptu, gdy brakuje jakiego¶ pliku. Je¿eli zostanie u¿yta funkcja
     <function>include</function>, to w powy¿szej sytuacji skrypt bêdzie
     przetwarzany dalej. Proszê pamiêtaæ o w³a¶ciwym ustawieniu dyrektywy
     <link linkend="ini.include-path">include_path</link>.
   </simpara>
   <simpara>
     Kiedy plik zostanie wczytany instrukcj± <function>include</function>,
     zawarty w nim kod dziedziczy <link
     linkend="language.variables.scope">zasiêg zmiennych</link> po linii,
     w której znajdowa³a siê instrukcja wczytania. Ka¿da zmienna dostêpna
     w linii z instrukcj± <function>include</function> bêdzie dostêpna we
     wczytywanym pliku od miejsca wczytania naprzód.
   </simpara>
   <para>
     <example>
      <title>Podstawowe wykorzystanie <function>include</function></title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$kolor = 'zielone';
$owoc = 'jab³ko';

?>

test.php
<?php

echo "Jedno $kolor $owoc"; // Jedno

include 'vars.php';

echo "Jedno $kolor $owoc"; // Jedno zielone jab³ko

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
     Je¶li instrukcja wczytania znajduje siê wewn±trz deklaracji funkcji, to
     ca³y kod zawarty w pliku wczytywanym bêdzie zachowywa³ siê, jakby by³
     zdefiniowany wewn±trz tej funkcji. Znaczy to, ¿e odziedziczy zasiêg
     zmiennych po tej funkcji.
   </simpara>
   <para>
     <example>
     <title>Wczytywanie wewn±trz funkcji</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
global $kolor;

    include 'vars.php';

    echo "Jeden $kolor $owoc";
}

/* vars.php znajduje siê w zasiêgu foo(), wiêc *
 * $owoc NIE jest dostêpny poza zasiêgiem tej  *
 * funkcji. Natomiast $kolor jest dostêpny,    *
 * poniewa¿ zosta³ zadeklarowany w zasiêgu     *
 * globalnym.                                  */
 
foo();                    // Jedno zielone jab³ko
echo "A $kolor $owoc";   // Jedno zielone

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     Na pocz±tku wczytywanego pliku parsowanie wychodzi z trybu PHP do trybu
     HTML i wraca do trybu pocz±tkowego na koñcu. Z tego powodu ka¿dy kod
     wewn±trz wczytywanego pliku bêdzie wykonany jako kod PHP, o ile bêdzie
     zawarty w <link linkend="language.basic-syntax.phpmode">wa¿nych
     znacznikach pocz±tku i koñca kodu PHP</link>.
   </simpara>
   <simpara>
     Je¶li  
     "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"
     s± w³±czone w PHP (takie jest domy¶lne ustawienie) mo¿na podaæ nazwê pliku
     do wczytania u¿ywaj±c adresu URL (przez protokó³ HTTP), zamiast podawaæ
     ¶cie¿kê lokaln±. Je¶li podany w adresie serwer interpretuje plik docelowy
     jako kod PHP, mo¿na do tego skryptu przekazaæ zmienne w taki sam sposób
     jak przy metodzie GET protoko³u HTTP. ¦ci¶le mówi±c, nie jest to to samo,
     co wczytywanie pliku lokalnego; jest to wykonanie pliku na zdalnym serwerze
     i wklejenie rezultatu jego dzia³ania do skryptu wywo³uj±cego. W tym
     przypadku, rzecz jasna, zasiêg globalny zmiennych nie obejmuje pliku
     wczytywanego t± metod±.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title><function>include</function> i protokó³ HTTP</title>
     <programlisting role="php">
<![CDATA[
<?php
/* Przyk³ad ten zak³ada, ¿e serwer www.example.com jest tak skonfigurowany,
 * ¿e wykonuje skrypty w plikach .php natomiast nie wykonuje skryptów w plikach
 * .txt. Pojêcie 'dzia³a', znaczy tutaj, ¿e zmienne $foo i $bar s± dostêpne
 * we wczytywanym pliku                                                       */

// Nie dzia³a: file.txt nie jest traktowany jak skrypt php
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Nie dzia³a: PHP bêdzie szukaæ pliku o nazwie 'file.php?foo=1&bar=2' 
// w lokalnym systemie plików
include 'file.php?foo=1&bar=2';

// Dzia³a.
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Dzia³a.
include 'file.php';  // Dzia³a.

?>
]]>
     </programlisting>
    </example>
     Patrz tak¿e <link linkend="features.remote-files">Korzystanie ze zdalnych
     plików</link>, <function>fopen</function> i <function>file</function>.
   </para>
   <para>
     Poniewa¿ <function>include</function> i <function>require</function> s±
     specialnymi konstrukcjami jêzykowymi, musz± byæ umieszczone w instrukcji
     grupuj±cej, aby mog³y dzia³aæ w instrukcji warunkowej.
   </para>
   <para>
    <example>
     <title>include() i instrukcja warunkowa</title>
     <programlisting role="php">
<![CDATA[
<?php

// Ten kod jest NIEPOPRAWNY i nie zadzia³a zgodnie z oczekiwaniami.
if ($warunek)
    include $plik;
else
    include $inny;


// Natomiast ten kod jest POPRAWNY.
if ($warunek) {
    include $plik;
} else {
    include $inny;
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Obs³uga zwracanych warto¶ci: mo¿na wywo³aæ instrukcjê
    <function>return</function> wewn±trz wczytywanego pliku, aby zakoñczyæ
    jego wykonywanie i powróciæ do pliku wywo³uj±cego. Mo¿na te¿ zwracaæ
    warto¶ci z wczytywanych plików, co upodabnia wczytywanie plików do
    wykorzystywania funkcji.
   </simpara>
   <note>
    <simpara>
     W PHP 3 instrukcja <function>return</function> mo¿e pojawiæ siê w bloku
     instrukcji tylko wówczas, je¶li znajduje siê on wewn±trz funkcji. W takim
     przypadku, oczywi¶cie, <function>return</function> odnosi siê do tej
     funkcji a nie do ca³ego pliku.
    </simpara>
   </note>
   <para>
    <example>
     <title><function>include</function> i wyra¿enie
     <function>return</function></title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // wy¶wietla 'PHP'

$bar = include 'noreturn.php';

echo $bar; // wy¶wietla 1

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    Zmienna <literal>$bar</literal> ma warto¶æ <literal>1</literal>, poniewa¿
    wczytywanie pliku zakoñczy³o siê powodzeniem. Proszê zauwa¿yæ istotn±
    ró¿nicê pomiêdzy powy¿szymi przyk³adami. Pierwszy u¿ywa instrukcji
    <function>return</function> wewn±trz wczytywanego pliku, natomiast drugi
    nie. Inne mo¿liwo¶ci "wczytania" plików do zmiennych to  
    <function>fopen</function>, <function>file</function> lub przez u¿ycie 
    <function>include</function> razem z 
    <link linkend="ref.outcontrol">Funkcjami Kontroli Wyj¶cia</link>.
   </simpara>

   <simpara>
    Patrz tak¿e <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
    <function>virtual</function>, i
    <link linkend="ini.include-path">include_path</link>.
   </simpara>

</sect1>

 <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    Instrukcja <function>require_once</function> s³u¿y do wczytania i wykonania
    kodu z okre¶lonego pliku w trakcie wykonywania skryptu. Zachowanie jej
    jest identyczne z instrukcj± <function>require</function> z jednym
    wyj±tkiem, tzn. je¶li dany plik zosta³ ju¿ raz wczytany do tego skryptu,
    nie bêdzie wczytany ponownie. Wiêcej informacji na temat dzia³ania tej
    instrukcji w dokumentacji odno¶nie <function>require</function>.
   </para>
   <para>
    <function>require_once</function> powinno byæ u¿ywane w przypadku, gdy ten
    sam plik móg³by zostaæ wczytany i wykonany wielokrotnie, ale ty chcesz mieæ
    pewno¶æ, ¿e zostanie wczytany dok³adnie raz, aby unikn±æ problemów z
    redefiniowaniem funkcji, nadpisywaniem zmiennych itp.
   </para>
   <para>
    Przyk³ady u¿ycia <function>require_once</function> i
    <function>include_once</function> znajduj± siê w kodzie
    <ulink url="&url.php.pear;">PEAR</ulink> do³±czonym do najnowszych
    dystrubucji kodu ¼ród³owego PHP.
   </para>
   <note>
    <para>
     <function>require_once</function> dodano w PHP 4.0.1pl2
    </para>
   </note>
   &warn.no-win32-fopen-wrapper;
   <para>
    Patrz tak¿e: <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    i <function>virtual</function>.
   </para>
  </sect1>

 <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    Instrukcja <function>include_once</function> s³u¿y do wczytania i wykonania
    kodu z okre¶lonego pliku w trakcie wykonywania skryptu. Dzia³anie instrukcji
    podobne jest do <function>include</function>, z jednym wyj±tkiem, tzn.
    je¶li dany plik zosta³ ju¿ raz do danego skryptu wczytany, nie bêdzie
    ju¿ wczytany ponownie. Wskazuje na to nazwa instrukcji: include_once znaczy
    wczytaj_raz.
   </para>
   <para>
    <function>include_once</function> powinno byæ stosowane w przypadkach, gdzie
    ten sam plik mo¿e byæ wczytany wiêcej ni¿ raz w czasie wykonywania skryptu,
    ale ty chcesz mieæ pewno¶æ ¿e bêdzie wczytany tylko jeden raz, aby unikn±æ
    problemów z redefiniowaniem funkcji, nadpisaniem warto¶ci zmiennych, itp.
   </para>
   <para>
     Wiêcej przyk³adów wykorzystania <function>require_once</function> i
     <function>include_once</function> znajdziesz w kodzie <ulink
     url="&url.php.pear;">PEAR</ulink> do³±czonym do najnowszych dystrybucji
     kodu ¼ród³owego PHP.
   </para>
   <note>
    <para>
     <function>include_once</function> dodano w PHP 4.0.1pl2
    </para>
   </note>
   &warn.no-win32-fopen-wrapper;
   <para>
    Patrz tak¿e <function>include</function>,
    <function>require</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    i <function>virtual</function>.
   </para>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
