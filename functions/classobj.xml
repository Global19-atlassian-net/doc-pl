<?xml version="1.0" encoding="iso-8859-2"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.38 Maintainer: dombal Status: Ready -->
 <reference id="ref.classobj">
  <title>Klasy/Obiekty</title>
  <titleabbrev>Klasy/Obiekty</titleabbrev>

  <partintro>
   <sect1 id="classobj.partintro">
    <title>Wprowadzenie</title>
    <sect2 id="classobj.intro">
     <title>O funkcjach</title>
     <para>
      Te funkcje pozwalaj± uzyskaæ informacje o klasach i ich egzemplarzach,
      obiektach. Mo¿esz uzyskaæ informacjê o nazwie klasy do jakiej nale¿y
      obiekt, a tak¿e jej w³a¶ciwo¶ci i metody. U¿ywaj±c tych funkcji mo¿esz
      dowiedzieæ siê nie tylko do jakiej klasy nale¿y obiekt, ale tak¿e
      ustaliæ jego przodków (np. jak± klasê rozszerza klasa tego obiektu).
     </para>
    </sect2>
    <sect2 id="classobj.example">
     <title>Przyk³ad u¿ycia</title>
     <para>
      W tym przyk³adzie wpierw zdefiniujemy bazow± klasê i jej rozszerzenie.
      Klasa bazowa opisuje normalne warzywo, czy jest jadalne czy nie
      oraz jego kolor. Podklasa <varname>Szpinak</varname> dodaje metodê
      pozwalaj±c± go zagotowaæ i drug±, która pozwala dowiedzieæ siê, czy
      jest zagotowany.
     </para>
     <para>
      <example>
       <title>classes.inc</title>
       <programlisting role="php">
<![CDATA[
<?php

// klasa bazowa wraz z jej w³a¶ciwo¶ciami i metodami
class Warzywo {

    var $jadalne;
    var $kolor;

    function Warzywo( $jadalne, $kolor="zielony" ) {
        $this->jadalne = $jadalne;
        $this->kolor = $kolor;
    }

    function jest_jadalne() {
        return $this->jadalne;
    }

    function jaki_kolor() {
        return $this->kolor;
    }

} // koniec klasy Warzywo


// rozrzesza klasê bazow±
class Szpinak extends Warzywo {

    var $ugotowane = false;

    function Szpinak() {
        $this->Warzywo( true, "zielone" );
    }

    function ugotuj() {
        $this->ugotowane = true;
    }

    function jest_ugotowane() {
        return $this->ugotowane;
    }

} // koniec klasy Szpinak

?>
]]>
       </programlisting>
      </example>
     </para>
     <para>
     Teraz mo¿emy powo³aæ dwa egzemplarze tych klas i wydrukowaæ informacje
     o nich, w³±czaj±c w to informacje o przodkach.
     Zdefiniujemy tak¿e kilka u¿ytecznych funkcji, g³ównie po to by uzyskaæ
     ³adny wydruk zmiennych.
     </para>
     <para>
      <example>
       <title>test_script.php</title>
       <programlisting role="php">
<![CDATA[
<pre>
<?php

include "classes.inc";

// funkcje u¿ytkowe

function drukuj_wlasciwosci($obj) {
    $tab = get_object_vars($obj);
    while (list($wlasc, $wart) = each($tab))
        echo "\t$wlasc = $wart\n";
}

function drukuj_metody($obj) {
    $tab = get_class_methods(get_class($obj));
    foreach ($tab as $metoda)
        echo "\tfunkcja $metoda()\n";
}

function przodkowie_klasy($obj, $klasa) {
    global $$obj;
    if (is_subclass_of($$obj, $klasa)) {
        echo "Obiekt $obj nale¿y do klasy ".get_class($$obj);
        echo ", podklasy $klass\n";
    } else {
        echo "Obiekt $obj nie nale¿y do podklasy $klass\n";
    }
}

// powo³ujemy 2 egzemplarze obiektów

$warzywko = new Warzywo(true,"niebieski");
$lisciaste = new Szpinak();

// wydrukujemy informacjê o obiektach
echo "warzywko: KLASA ".get_class($warzywko)."\n";
echo "lisciaste: KLASA ".get_class($lisciaste);
echo ", PRZODEK ".get_parent_class($lisciaste)."\n";

// poka¿ym w³a¶ciwo¶ci warzywka
echo "\nwarzywko: W³a¶ciwo¶ci\n";
drukuj_wlasciwosci($warzywko);

// i metody li¶ciastego
echo "\nlisciaste: Metody\n";
drukuj_metody($lisciaste);

echo "\nPrzodkowie:\n";
przodkowie_klasy("lisciaste", "Szpinak");
przodkowie_klasy("lisciaste", "Warzywo");
?>
</pre>
]]>
       </programlisting>
      </example>
     </para>
     <para>
      Wart± odnotowania rzecz± w powy¿szym przyk³adzie jest to,
      ¿e obiekt <varname>$lisciaste</varname> jest egzemplarzem klasy
      <classname>Szpinak</classname> która to jest podklas± klasy
      <classname>Warzywo</classname>, i tak ostatnia czê¶æ powy¿szego
      skryptu poka¿e na wyj¶ciu:
     </para>
     <para>
      <informalexample>
       <programlisting>
<![CDATA[
       [...]
Przodkowie:
Obiekt lisciasty nie nale¿y do podklasy Szpinak
Obiekt lisciasty nale¿y do klasy Szpinak, podklasy Warzywo
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>
   </sect1>
  </partintro>

  <refentry id="function.call-user-method">
   <refnamediv>
    <refname>call_user_method</refname>
    <refpurpose>
     Wywo³uje metodê u¿ytkownika na zadanym obiekcie [przestarza³e]
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
     <methodsynopsis>
      <type>mixed</type><methodname>call_user_method</methodname>
      <methodparam><type>string</type><parameter>nazwa_metody</parameter></methodparam>
      <methodparam><type>object</type><parameter>obiekt</parameter></methodparam>
      <methodparam choice="opt"><type>mixed</type><parameter>parametr</parameter></methodparam>
      <methodparam choice="opt"><type>mixed</type><parameter>...</parameter></methodparam>
     </methodsynopsis>
    <warning>
     <para>
      Funkcja <function>call_user_method</function> jest przestarza³a od
      PHP 4.1.0, zamiast niej u¿yj wariacji funkcji <function>call_user_func</function>
      pos³uguj±c siê sk³adni± <literal>array(&amp;$obiekt, "nazwa_metody")</literal>.
     </para>
    </warning>
    <para>
     Wywo³uje metodê nazwan± <parameter>method_name</parameter> z obiektu
     <parameter>obiekt</parameter> zdefiniowanego przez u¿ytkownika. Przyk³ad
     u¿ycia znajdziesz ni¿ej, gdzie definiujemy klasê, powo³ujemy jej egzemplarz
     i u¿ywamy funkcji <function>call_user_method</function> by po¶rednio wywo³aæ
     jej metodê <varname>drukuj_info</varname>.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class Kraj {
    var $NAZWA;
    var $TLD;

    function Kraj($nazwa, $tld) {
        $this->NAZWA = $nazwa;
        $this->TLD = $tld;
    }

    function drukuj_info($przedc="") {
        echo $przedc."Kraj: ".$this->NAZWA."\n";
        echo $przedc."Domena TLD: ".$this->TLD."\n";
    }
}

$krj = new Kraj("Peru","pe");

echo "* Wywo³ujê metodê na obiekcie bezpo¶rednio\n";
$krj->drukuj_info();

echo "\n* Wywo³ujê tê sam± metodê po¶rednio\n";
call_user_method ("drukuj_info", $krj, "\t");
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Patrz tak¿e: <function>call_user_func_array</function>,
     <function>call_user_func</function>,
     <function>call_user_method_array</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.call-user-method-array">
   <refnamediv>
    <refname>call_user_method_array</refname>
    <refpurpose>
     Wywo³uje metodê u¿ytkownika zadan± z tablic± parametrów [przestarza³e]
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
     <methodsynopsis>
      <type>mixed</type><methodname>call_user_method_array</methodname>
      <methodparam><type>string</type><parameter>nazwa_metody</parameter></methodparam>
      <methodparam><type>object</type><parameter>obiekt</parameter></methodparam>
      <methodparam choice="opt"><type>array</type><parameter>tabparam</parameter></methodparam>
     </methodsynopsis>
    <warning>
     <para>
      Funkcja <function>call_user_method_array</function> jest przestarza³a od
      PHP 4.1.0, zamiast niej u¿yj wariacji funkcji <function>call_user_func_array</function>
      pos³uguj±c siê sk³adni± <literal>array(&amp;$obiekt, "nazwa_metody")</literal>.
     </para>
    </warning>
    <para>
     Wywo³uje metodê nazwan± <parameter>nazwa_metody</parameter> z obiektu
     <parameter>obiekt</parameter> zdefiniowanego przez u¿ytkownika, u¿ywaj±c
     parametrów z <parameter>tabparam</parameter>.
    </para>
    <para>
     Patrz tak¿e:
     <function>call_user_func_array</function>,
     <function>call_user_func</function>,
     <function>call_user_method</function>.
    </para>
    <note>
     <para>
      Funkcja ta zosta³a dodana do kodu w CVSie po wydaniu PHP 4.0.4pl1
     </para>
    </note>
   </refsect1>
  </refentry>

  <refentry id="function.class-exists">
   <refnamediv>
    <refname>class_exists</refname>
    <refpurpose>Sprawdza czy klasa zosta³a zdefiniowana</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
     <methodsynopsis>
      <type>bool</type><methodname>class_exists</methodname>
      <methodparam><type>string</type><parameter>nazwa_klasy</parameter></methodparam>
     </methodsynopsis>
    <para>
     Funkcja ta zwraca &true; je¿eli klasa zadana przez parametr
     <parameter>nazwa_klasy</parameter> zosta³a zdefiniowana,
     &false; w przeciwnym wypadku.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.get-class">
   <refnamediv>
    <refname>get_class</refname>
    <refpurpose>Zwraca nazwê klasy zadanego obiektu</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
     <methodsynopsis>
      <type>string</type><methodname>get_class</methodname>
      <methodparam><type>object</type><parameter>obiekt</parameter></methodparam>
     </methodsynopsis>
    <para>
     Funkcja ta zwraca nazwê klasy, której <parameter>obiekt</parameter>
     jest egzemplarzem. Zwraca &false; je¿eli <parameter>obiekt</parameter>
     nie jest obiektem.
    </para>
    <note>
     <simpara>
      <function>get_class</function> zwraca nazwê klasy zdefiniowanej przez
      u¿ytkownika ma³ymi literami. Klasa zdefiniowana w rozszerzeniu PHP
      jest zwracana w jej oryginalnej notacji.
     </simpara>
    </note>
    <simpara>
     Patrz tak¿e: <function>get_parent_class</function>,
     <function>gettype</function>,
     <function>is_subclass_of</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.get-class-methods">
   <refnamediv>
    <refname>get_class_methods</refname>
    <refpurpose>Zwraca tablicê nazw metod danej klasy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
     <methodsynopsis>
      <type>array</type><methodname>get_class_methods</methodname>
      <methodparam><type>mixed</type><parameter>nazwa_klasy</parameter></methodparam>
     </methodsynopsis>
    <para>
     Funkcja ta zwraca tablicê nazw metod zdefiniowanych dla klasy okre¶lonej 
     przez parametr <parameter>nazwa_klasy</parameter>.
    </para>
    <note>
     <para>
      Od PHP 4.0.6, mo¿esz okre¶liæ obiekt przez jego samego, zamiast przez
      parametr <parameter>nazwa_klasy</parameter>.  Dla przyk³adu:
      <informalexample>
       <programlisting>
<![CDATA[
$metody_klasy = get_class_methods($moja_klasa); // zobacz ni¿ej wiêkszy przyk³ad
]]>
       </programlisting>
      </informalexample>
     </para>
    </note>
    <para>
     <example>
      <title><function>get_class_methods</function> przyk³ad</title>
      <programlisting role="php">
<![CDATA[
<?php

class mojaklasa {
    // konstruktor
    function mojaklasa() {
        return(true);
    }

    // metoda 1
    function mojafunk1() {
        return(true);
    }

    // metoda 2
    function mojafunk2() {
        return(true);
    }
}

$moj_obiekt = new mojaklasa();

$metody_klasy = get_class_methods(get_class($moj_obiekt));

foreach ($metody_klasy as $nazwa_metody) {
    echo "$nazwa_metody\n";
}

?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Wy¶wietli:
     <informalexample>
      <programlisting>
<![CDATA[
mojaklasa
mojafunk1
mojafunk2
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Patrz tak¿e: <function>get_class_vars</function>,
     <function>get_object_vars</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.get-class-vars">
   <refnamediv>
    <refname>get_class_vars</refname>
    <refpurpose>
     Zwraca tablicê domy¶lnych w³a¶ciwo¶ci klasy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
     <methodsynopsis>
      <type>array</type><methodname>get_class_vars</methodname>
      <methodparam><type>string</type><parameter>nazwa_klasy</parameter></methodparam>
     </methodsynopsis>
    <para>
     Funkcja ta zwróci tablicê asocjacyjn± domy¶lnych w³a¶ciwo¶ci klasy.
     Elementy wynikowej tablicy s± w formie <parameter>nazwzmien => warto¶æ</parameter>
    </para>
    <note>
     <para>
      Niezainicjalizowane zmienne klasy nie bêd± raportowane przez funkcjê
      <function>get_class_vars</function>.
     </para>
    </note>
    <para>
     <example>
      <title><function>get_class_vars</function> przyk³ad</title>
      <programlisting role="php">
<![CDATA[
<?php

class mojaklasa {

    var $zm1; // ta nie ma domy¶lenj warto¶ci...
    var $zm2 = "xyz";
    var $zm3 = 100;

    // konstruktor
    function mojaklasa() {
        return(true);
    }

}

$moja_klasa = new mojaklasa();

$wlasciwosci_klasy = get_class_vars(get_class($moja_klasa));

foreach ($wlasciwosci_klasy as $nazwa => $wartosc) {
    echo "$nazwa : $wartosc\n";
}

?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Wy¶wietli:
     <informalexample>
      <programlisting>
<![CDATA[
zm2 : xyz
zm3 : 100
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Patrz tak¿e: <function>get_class_methods</function>,
     <function>get_object_vars</function>
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.get-declared-classes">
   <refnamediv>
    <refname>get_declared_classes</refname>
    <refpurpose>Zwraca tablicê z nazwami zdefiniowanych klas</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
     <methodsynopsis>
      <type>array</type><methodname>get_declared_classes</methodname>
      <void/>
     </methodsynopsis>
    <para>
     Funkcja ta zwraca tablicê nazw klas zdefiniowanych w bie¿±cym skrypcie.
    </para>
    <note>
     <para>
      W PHP 4.0.1pl2, zwracane s± trzy dodatkowe klasy na pocz±tku tablicy: 
      <classname>stdClass</classname> (zdefiniowana w
      <filename>Zend/zend.c</filename>),
      <classname>OverloadedTestClass</classname> (zdefiniowana w 
      <filename>ext/standard/basic_functions.c</filename>)
      oraz <classname>Directory</classname>
      (zdfiniowana w <filename>ext/standard/dir.c</filename>).
     </para>
     <para>
      Warto zauwa¿yæ, ¿e zale¿nie od tego jakie biblioteki zosta³y dodane
      do PHP, mog± pojawiæ siê dodatkowe klasy. To znaczy, ¿e nie bêdzie mo¿na
      zdefiniowaæ w³asnych klas u¿ywaj±c tych nazw. Istnieje lista predefiniowanych
      klas w sekcji <link linkend="reserved.classes">Predefined Classes</link> 
      w dodatkach.
     </para>
    </note>
   </refsect1>
  </refentry>

  <refentry id="function.get-object-vars">
   <refnamediv>
    <refname>get_object_vars</refname>
    <refpurpose>Zwraca tablicê asocjacyjn± w³a¶ciwo¶ci obiektu</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
     <methodsynopsis>
      <type>array</type><methodname>get_object_vars</methodname>
      <methodparam><type>object</type><parameter>obiekt</parameter></methodparam>
     </methodsynopsis>
    <para>
     Funkcja ta zwraca tablicê asocjacyjn± zdfiniowanych w³a¶ciwo¶ci 
     okre¶lonego obiektu <parameter>obiekt</parameter>. Je¿eli zmienne 
     zadeklarowane w klasie której <parameter>obiekt</parameter> jest 
     egzemplarzem, nie maj± przypisanej warto¶ci, to te nie bêd± zwrócone
     w tablicy.
     <example>
      <title>U¿ycie <function>get_object_vars</function></title>
      <programlisting role="php">
<![CDATA[
<?php
class Punkt2D {
    var $x, $y;
    var $opis;

    function Punkt2D($x, $y) {
        $this->x = $x;
        $this->y = $y;
    }

    function ustawOpis($opis) {
        $this->opis = $opis;
    }

    function pobierzPunkt() {
        return array("x" => $this->x,
                     "y" => $this->y,
                     "opis" => $this->opis);
    }
}

// "$opis" jest zadeklarowany lecz niezdefiniowany
$p1 = new Punkt2D(1.233, 3.445);
print_r(get_object_vars($p1));

$p1->ustawOpis("punkt #1");
print_r(get_object_vars($p1));

?>
]]>
      </programlisting>
     </example>
     Wynikiem powy¿szego programu bêdzie:
     <screen>
<![CDATA[
 Array
 (
     [x] => 1.233
     [y] => 3.445
 )

 Array
 (
     [x] => 1.233
     [y] => 3.445
     [opis] => punkt #1
 )
]]>
     </screen>
    </para>
    <simpara>
     Patrz tak¿e: <function>get_class_methods</function>,
     <function>get_class_vars</function>!
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.get-parent-class">
   <refnamediv>
    <refname>get_parent_class</refname>
    <refpurpose>Pobiera nazwê klasy przodka obiektu b±d¼ klasy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
     <methodsynopsis>
      <type>string</type><methodname>get_parent_class</methodname>
      <methodparam><type>mixed</type><parameter>obiekt</parameter></methodparam>
     </methodsynopsis>
    <para>
     Je¿eli <parameter>obiekt</parameter> jest obiektem, zwraca nazwê klasy 
     przodka klasy której <parameter>obiekt</parameter> jest egzemplarzem.
    </para>
    <para>
     Je¿eli <parameter>obiekt</parameter> jest ci±giem znakowym, zwraca 
     nazwê klasy przodka klasy o tej nazwie. Ta funkcjonalno¶æ zosta³a dodana
     w PHP 4.0.5.
    </para>
    <simpara>
     Patrz tak¿e: <function>get_class</function>,
     <function>is_subclass_of</function>
    </simpara>
   </refsect1>
  </refentry>

 <refentry id="function.is-a">
   <refnamediv>
    <refname>is_a</refname>
    <refpurpose>
     Zwraca &true; je¿eli obiekt jest tej klasy, lub ta klasa jest jednym z
     jego przodków
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
     <methodsynopsis>
      <type>bool</type><methodname>is_a</methodname>
      <methodparam><type>object</type><parameter>obiekt</parameter></methodparam>
      <methodparam><type>string</type><parameter>nazwa_klasy</parameter></methodparam>
     </methodsynopsis>
    <para>
     Funkcja ta zwraca &true; je¿eli obiekt jest tej klasy, lub ta klasa jest
     jednym z jego przodków, &false; w przeciwnym przypadku.
    </para>
    <simpara>
     Patrz tak¿e: <function>get_class</function>,
     <function>get_parent_class</function>,
     <function>is_subclass_of</function>.
    </simpara>
   </refsect1>
  </refentry>

 <refentry id="function.is-subclass-of">
   <refnamediv>
    <refname>is_subclass_of</refname>
    <refpurpose>
     Zwraca &true; je¿eli klasa jest jednym z przodków obiektu
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
     <methodsynopsis>
      <type>bool</type><methodname>is_subclass_of</methodname>
      <methodparam><type>object</type><parameter>obiekt</parameter></methodparam>
      <methodparam><type>string</type><parameter>nazwa_klasy</parameter></methodparam>
     </methodsynopsis>
    <para>
     Funkcja ta zwraca &true; je¿eli obiekt <parameter>obiekt</parameter>
     nale¿y do klasy która jest podklas± klasy <parameter>nazwa_klasy</parameter>,
     &false; w przeciwnym przypadku.
    </para>
    <simpara>
     Patrz tak¿e: <function>get_class</function>,
     <function>get_parent_class</function>,
     <function>is_a</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.method-exists">
   <refnamediv>
    <refname>method_exists</refname>
    <refpurpose>Sprawdza czy istnieje metoda dla klasy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
     <methodsynopsis>
      <type>bool</type><methodname>method_exists</methodname>
      <methodparam><type>object</type><parameter>obiekt</parameter></methodparam>
      <methodparam><type>string</type><parameter>nazwa_metody</parameter></methodparam>
     </methodsynopsis>
    <para>
     Funkcja ta zwraca &true; je¿eli metoda okre¶lona przez parametr
     <parameter>nazwa_metody</parameter> zosta³ zdefiniowany na obiektu
     <parameter>object</parameter>, &false; w przeciwnym przypadku.
    </para>
   </refsect1>
  </refentry>

 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

