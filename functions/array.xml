<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: 1.130 Maintainer: leon Status: ready -->
<!-- $Revision: 1.5 $ -->
 <reference id="ref.array">
  <title>Funkcje obs³ugi tablic</title>
  <titleabbrev>Tablice</titleabbrev>
  <partintro>
   <simpara>
    Funkcje te pozwalaj± na operowanie i manipulowanie tablicami na wiele
    ró¿nych sposobów. Tablice s± kluczowym elementem przechowywania,
    zarz±dzania i operowania na zbiorach zmiennych.
   </simpara>
   <simpara>
    Obs³ugiwane s± proste i wielowymiarowane tablica, które mog± byæ stworzone
    przez u¿ytkownika lub przez funkcjê. Istniej± specjalne funkcje obs³ugi
    baz danych odpowiedzialne za wype³nianie tablic danymi z zapytañ do baz
    danych, a tak¿e kilka innych funkcji zwracaj±cych tablice.
   </simpara>
  <para>
   Zobacz rozdzia³ podrêcznika <link linkend="language.types.array">Tablice
   </link> aby uzyskaæ dok³adne wyja¶nienie jak tablice zosta³y
   zaimplementowane i jak siê ich u¿ywa w PHP.
  </para>
   <para>
    Patrz tak¿e <function>is_array</function>, <function>explode</function>, 
    <function>implode</function>, <function>split</function> 
    i <function>join</function>.
   </para>
  </partintro>

  <refentry id="function.array">
   <refnamediv>
    <refname>array</refname>
    <refpurpose>
     Stwórz tablicê
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array</function></funcdef>
      <paramdef>mixed 
       <parameter><optional>...</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Zwraca tablicê stworzon± z podanych parametrów. Parametry mog± byæ
     indeksowane przy pomocy operatora <literal>=&gt;</literal> operator.
    </para>
    <para>
     <note>
      <para>
       <function>array</function> jest sk³adni± jêzyka u¿ywan± do tekstowej
       reprezentacji tablic, a nie zwyk³± funkcj±.
      </para>
     </note>
    </para>
    <para>
     Sk³adnia "index =&gt; warto¶ci", oddzielona przecinkami, definiuje pary
     indeksów i warto¶ci. Indeks mo¿e byæ stringiem lub liczb±. Je¶li indeks
     zostanie pominiêty, automatycznie wygenerowany zostanie indeks bêd±cy
     liczb± ca³kowit±, poczynaj±c od 0. Je¶li indeks jest liczb± ca³kowit±,
     nastêpny wygenerowany indeks bêdzie mia³ warto¶æ "najwiêkszy indeks + 1".
     Zauwa¿, ¿e je¶li pojawi± siê dwie warto¶ci o tym samym indeksie, ostatnia
     nadpisze wcze¶niejsze.
    </para>
    <para>
     Poni¿szy przyk³ad demonstruje jak stworzyæ wielowymiarow± tablicê, jak
     okre¶liæ klucze w tablicy asocjacyjnej i jak pomin±æ-i-kontynuowaæ
     liczbowe indeksy w normalnych tablicach.
     <example>
      <title>Przyk³ad u¿ycia <function>array</function></title>
      <programlisting role="php">
<![CDATA[
$owoce = array (
   "owoce"  => array ("a"=&gt;"pomarañcza", "b"=&gt;"banan", "c"=&gt;"jab³ko"),
   "liczby" => array (1, 2, 3, 4, 5, 6),
   "dziury" => array ("pierwszy", 5 =&gt; "drugi", "trzeci")
);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Automatyczne indeksowanie w funkcji <function>array</function></title>
      <programlisting role="php">
<![CDATA[
$array = array( 1, 1, 1, 1,  1, 8=>1,  4=>1, 19, 3=>13);
print_r($array);
]]>
      </programlisting>
      <para>
       wy¶wietli:
       <screen role="php">
<![CDATA[
Array 
(
    [0] => 1
    [1] => 1
    [2] => 1
    [3] => 13
    [4] => 1
    [8] => 1
    [9] => 19
)
]]>
       </screen>
      </para>
     </example>
     Zauwa¿, ¿e indeks '3' jest zdefiniowany dwa razy i przchowuje on koñcow±
     warto¶æ 13. Indeks 4 jest zdefiniowany po indeksie 8, a nastêpnym
     wygenerowanym indeksem (dla warto¶ci 19) jest 9, poniewa¿ najwiêkszym
     poprzednim indeksem by³o 8.
    </para>
    <para>
     Ten przyk³ad tworzy tablicê o pocz±tku 1.
     <example>
      <title>Indeksowanie od 1 w <function>array</function></title>
      <programlisting role="php">
<![CDATA[
$pierwszy_kwartal  = array(1 => 'Styczeñ', 'Luty', 'Marzec');
print_r($pierwszy_kwartal);
]]>
      </programlisting>
      <para>
       wy¶wietli:
       <screen role="php">
<![CDATA[
Array 
(
    [1] => 'Styczeñ'
    [2] => 'Luty'
    [3] => 'Marzec'
)
]]>
       </screen>
      </para>
     </example>
    </para>
    <para>
     Patrz tak¿e: <function>list</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-change-key-case">
   <refnamediv>
    <refname>array_change_key_case</refname>
    <refpurpose>
     Zwraca tablicê ze wszystkimi kluczami tekstowymi zamienionymi na
     wy³±cznie ma³e lub wy³±cznie du¿e litery
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_change_key_case</function></funcdef>
      <paramdef>array <parameter>wej¶cie</parameter></paramdef>
      <paramdef>int <parameter><optional>wielko¶æ</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_change_key_case</function> zmienia klucze w tablicy
     <parameter>wej¶cie</parameter> aby by³y pisane tylko du¿ymi lub tylko
     ma³ymi literami. Zmiana zale¿y od ostatniego opcjonalnego parametru
     <parameter>case</parameter>. Mo¿na do niego przekazaæ jedn± z dwóch
     sta³ych: <constant>CASE_UPPER</constant> lub
     <constant>CASE_LOWER</constant>. Domy¶ln± warto¶ci± jest
     <constant>CASE_LOWER</constant>. Indeksy liczbowe bêd± pozostawione takie
     jakie s±.
    </para>
    <example>
     <title>Przyk³ad u¿ycia <function>array_change_key_case</function></title>
     <programlisting role="php">
<![CDATA[
$wejscie = array("PierWszy" => 1, "DruGi" => 4);
print_r(array_change_key_case($wejscie, CASE_UPPER);
]]>
     </programlisting>
     <para>
      Powy¿szy przyk³ad wy¶wietli:
      <screen>
<![CDATA[
Array
(
    [PIERWSZY] => 1
    [DRUGI] => 2
)
]]>
      </screen>
     </para>
    </example>
   </refsect1>
  </refentry>

  <refentry id="function.array-chunk">
   <refnamediv>
    <refname>array_chunk</refname>
    <refpurpose>Podziel tablicê na kawa³ki</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_chunk</function></funcdef>
      <paramdef>array <parameter>wej¶cie</parameter></paramdef>
      <paramdef>int <parameter>rozmiar</parameter></paramdef>
      <paramdef>bool <parameter><optional>zachowaj_klucze</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_chunk</function> dzieli tablicê na kilka mniejszych,
     ka¿da po <parameter>rozmiar</parameter> elementów. Istnieje mo¿liwo¶æ, ¿e
     ostatnia tablica bêdzie mniejsza. Otrzymujesz tablice jako elementy
     wielowymiarowej tablicy indeksowanej przez liczby zaczynaj±c od zera.
    </para>
    <para>
     Ustawiaj±c opcjonalny parametr <parameter>zachowaj_klucze</parameter> na
     &true; mo¿esz zmusiæ PHP do zachowywania orginalnych kluczy z tablicy
     wej¶ciowej. Je³i podasz w tym miejscu &false;, to w ka¿dej nowej tablicy
     u¿yte bêd± nowe indeksy liczbowe zaczynaj±ce siê od zera. Domy¶ln±
     warto¶ci± jest &false;.
    </para>
    <example>
     <title>Przyk³ad u¿ycia <function>array_chunk</function></title>
     <programlisting role="php">
<![CDATA[
$tablica_wejsciowa = array('a', 'b', 'c', 'd', 'e');
print_r(array_chunk($tablica_wejsciowa, 2));
print_r(array_chunk($tablica_wejsciowa, 2, TRUE));
]]>
     </programlisting>
     <para>
      Powy¿szy program wy¶wietli:
      <screen>
<![CDATA[
Array
(
    [0] => Array
        (
            [0] => a
            [1] => b
        )

    [1] => Array
        (
            [0] => c
            [1] => d
        )

    [2] => Array
        (
            [0] => e
        )

)
Array
(
    [0] => Array
        (
            [0] => a
            [1] => b
        )

    [1] => Array
        (
            [2] => c
            [3] => d
        )

    [2] => Array
        (
            [4] => e
        )

)
]]>
      </screen>
     </para>
    </example>
   </refsect1>
  </refentry>

  <refentry id="function.array-count-values">
   <refnamediv>
    <refname>array_count_values</refname>
    <refpurpose>Zlicza wszystkie warto¶ci w tablicy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_count_values</function></funcdef>
      <paramdef>array <parameter>wej¶cie</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_count_values</function> zwraca tablicê zawieraj±c±
     warto¶ci tablicy <parameter>wej¶cie</parameter> jako klucze i czêsto¶æ
     ich wystêpowania w tablicy <parameter>wej¶cie</parameter> jako warto¶ci.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_count_values</function></title>
      <programlisting role="php">
<![CDATA[
$tablica = array (1, "witaj", 1, "¶wiecie", "witaj");
array_count_values ($tablica); // zwraca tablicê (1=>2, "witaj"=>2, "¶wiecie"=>1)
]]>
      </programlisting>
     </example>     
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-diff">
   <refnamediv>
    <refname>array_diff</refname>
    <refpurpose>Zwraca ró¿nice pomiêdzy tablicami</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_diff</function></funcdef>
      <paramdef>array <parameter>tabela1</parameter></paramdef>
      <paramdef>array <parameter>tabela2</parameter></paramdef>
      <paramdef>array
       <parameter><optional> ...</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_diff</function> zwraca tablicê zawieraj±c± wszystkie
     warto¶ci tablicy <parameter>tabela1</parameter> które nie s± obecne w
     innych tablicach-argumentach. Zauwa¿, ¿e zachowywane s± klucze.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_diff</function></title>
      <programlisting role="php">
<![CDATA[
$tablica1 = array ("a" =&gt; "zielony", "czerwony", "niebieski", "czerwony");
$tablica2 = array ("b" =&gt; "zielony", "¿ó³ty", "czerwony");
$wynik = array_diff ($tablica1, $tablica2);
]]>
      </programlisting>
     </example>
    </para>     
    <para>
     W powy¿szym przyk³adzie zmienna <varname>$wynik</varname> zawiera 
     <literal>array ("niebieski");</literal>. Wielokrotne wyst±pienia w
     $tablica1 s± traktowane w taki sam sposób.
    </para>
    <note>
     <simpara>
      Dwa elementy tablicy uwa¿ane s± za identyczne wtedy i tylko wtedy je¶li
      <literal>(string) $element1 === (string) $element2</literal>. S³ownie:
      kiedy reprezentacje elementów w postaci stringów s± identyczne.
      <!-- TODO: przyk³ad... -->
     </simpara>
    </note>
    <warning>
     <simpara>
      Ta funkcja by³a zepsuta w PHP 4.0.4!
      <!-- TODO: kiedy dok³adnie by³o to zepsute?... -->
     </simpara>
    </warning>
    <para>
     Patrz tak¿e <function>array_intersect</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-filter">
   <refnamediv>
    <refname>array_filter</refname>
    <refpurpose>
     Filtruje elementy przy u¿yciu funkcji zwrotnej
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_filter</function></funcdef>
      <paramdef>array <parameter>wej¶cie</parameter></paramdef>
      <paramdef>mixed 
       <parameter><optional>funkcja_zwrotna</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_filter</function> zwraca tablicê zawieraj±c± wszystkie
     elementy tablicy <parameter>wej¶cie</parameter> przefitrowane przez
     podan± funkcjê zwrotn±. Je¶li <parameter>wej¶cie</parameter> jest tablic±
     asocjacyjn±, przypisania klucz pozostaj± zachowane.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_filter</function></title>
      <programlisting role="php">
<![CDATA[
function nieparzysta($var) {
    return ($var % 2 == 1);
}

function parzysta($var) {
    return ($var % 2 == 0); 
}

$tablica1 = array ("a"=>1, "b"=>2, "c"=>3, "d"=>4, "e"=>5);
$tablica2 = array (6, 7, 8, 9, 10, 11, 12);

$nieparzyste = array_filter($tablica1, "nieparzyste");
$parzyste    = array_filter($tablica2, "parzyste");
]]>
      </programlisting>
     </example>
    </para>     
    <para>
     W tym przyk³adzie tablica <varname>$nieparzyste</varname> zawiera
     <literal>array ("a"=&gt;1, "c"=&gt;3, "e"=&gt;5);</literal>,
     a tablica <varname>$parzyste</varname> zawiera
     <literal>array (6, 8, 10, 12);</literal>,
    </para>
    <para>
     Patrz tak¿e <function>array_map</function>,
     <function>array_reduce</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-flip">
   <refnamediv>
    <refname>array_flip</refname>
    <refpurpose>Odwraca wszystkie warto¶ci w tablicy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_flip</function></funcdef>
      <paramdef>array <parameter>trans</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_flip</function> zwraca tablicê w odwróconym porz±dku,
     tzn. klucze z tabeli <parameter>trans</parameter> staj± siê warto¶ciami a
     warto¶ci <parameter>trans</parameter> staj± siê kluczami.
    </para>
    <para>
     Zauwa¿, ¿e wszystkie warto¶ci tablicy <parameter>trans</parameter> musz±
     mieæ poprawne klucze, tzn. musz± byæ albo typu <type>integer</type> lub
     <type>string</type>. Je¶li warto¶æ nie ma prawid³ego typu, wy¶wietlone
     zostanie ostrze¿enie, a para klucz/warto¶æ <emphasis>nie bêdzie
     odwrócona</emphasis>.
    </para>
    <para>
     Je¶li warto¶æ wystêpuje wielokrotnie, ostatni klucz bêdzie u¿yty jako jej
     warto¶æ po odwróceniu, a wszystkie inne zostan± stracone.
    </para>
    <para>
     <function>array_flip</function> zwraca &false; je¶li nie powiedzie siê
     odwracanie tablicy.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_flip</function></title>
      <programlisting role="php">
<![CDATA[
$trans = array_flip ($trans);
$original = strtr ($str, $trans);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_flip</function> : kolizja</title>
      <programlisting role="php">
<![CDATA[
$trans = array ("a" => 1, "b" => 1, "c" => 2);
$trans = array_flip ($trans);
// teraz $trans zawiera : array(1 => "b", 2 => "c");
]]>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-fill">
   <refnamediv>
    <refname>array_fill</refname>
    <refpurpose>Wype³nij tablicê podanymi warto¶ciami</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_fill</function></funcdef>
      <paramdef>int <parameter>indeks_pocz±tkowy</parameter></paramdef>
      <paramdef>int <parameter>num</parameter></paramdef>
      <paramdef>mixed <parameter>warto¶æ</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_fill</function> wype³ni tablicê warto¶ci±
     <parameter>value</parameter>, pocz±wszy od indeksu
     <parameter>indeks_pocz±tkowy</parameter> przez <parameter>num</parameter>
     kolejnych elementów tablicy.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_fill</function></title>
      <programlisting role="php">
<![CDATA[
$a = array_fill(5, 6, 'banan');

/*
$a zawiera teraz takie elementy:

$a[5]  = "banan";
$a[6]  = "banan";
$a[7]  = "banan";
$a[8]  = "banan";
$a[9]  = "banan";
$a[10] = "banan";
*/
]]>
      </programlisting>
     </example>     
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-intersect">
   <refnamediv>
    <refname>array_intersect</refname>
    <refpurpose>Zwraca przeciêcie tablic</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_intersect</function></funcdef>
      <paramdef>array <parameter>tablica1</parameter></paramdef>
      <paramdef>array <parameter>tablica2</parameter></paramdef>
      <paramdef>array
       <parameter><optional> ...</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_intersect</function> zwraca tablicê zawieraj±c± wszystkie
     warto¶ci tablicy <parameter>tablica1</parameter> które istniej± we
     wszystkich argumentach. Zauwa¿, ¿a zachowywane s± przypisania kluczy.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_intersect</function></title>
      <programlisting role="php">
<![CDATA[
$tablica1 = array ("a" => "zielony", "czerwony", "niebieski");
$tablica2 = array ("b" => "zielony", "¿ó³ty", "czerwony");
$wynik = array_intersect ($tablica1, $tablica2);
]]>
      </programlisting>
     </example>
    </para>     
    <para>
     W powy¿szym przyk³adzie tablica <varname>$wynik</varname> zawiera
     <literal>array ("a" =&gt; "zielony", "czerwony");</literal>
    </para>
    <note>
     <simpara>
      Dwa elementy tablicy uwa¿ane s± za identyczne wtedy i tylko wtedy je¶li
      <literal>(string) $element1 === (string) $element2</literal>. S³ownie:
      kiedy reprezentacje elementów w postaci stringów s± identyczne.
      <!-- TODO: przyk³ad... -->
     </simpara>
    </note>
    <warning>
     <simpara>
      Ta funkcja by³a zepsuta w PHP 4.0.4!
      This was broken in PHP 4.0.4!
      <!-- TODO: kiedy dok³adnie by³a zepsuta?... -->
     </simpara>
    </warning>
    <para>
     Patrz tak¿e <function>array_diff</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-key-exists">
   <refnamediv>
    <refname>array_key_exists</refname>
    <refpurpose>
     Sprawdza czy podany klucz lub indeks istnieje w tablicy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Description</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>array_key_exists</function></funcdef>
      <paramdef>mixed <parameter>ig³a</parameter></paramdef>
      <paramdef>array <parameter>stóg_siana</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_key_exists</function> zwraca &true; je¶li
     <parameter>ig³a</parameter> jest ustawiona w tablicy
     <parameter>stóg_siana</parameter>. <parameter>ig³a</parameter> mo¿e byæ
     dowoln± warto¶ci± mo¿liw± dla indksu tablicy.
    </para>
    <para>
     <example>
      <title><function>array_key_exists</function> example</title>
      <programlisting role="php">
<![CDATA[
$stog_siana = array("pierwszy" => 1, "drugi" => 4);
if (array_key_exists("pierwszy", $stog_siana)) {
    echo "'Pierwszy' element istnieje w tablicy";
}
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <simpara>
      W PHP 4.0.6 ta funkcja nazywa siê <function>key_exists</function>.
     </simpara>
    </note>
    <para>
     Patrz tak¿e <function>isset</function>.
    </para>
   </refsect1>
  </refentry>


  <refentry id="function.array-keys">
   <refnamediv>
    <refname>array_keys</refname>
    <refpurpose>Zwraca wszystkie klucze z tablicy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_keys</function></funcdef>
      <paramdef>array <parameter>wej¶cie</parameter></paramdef>
      <paramdef>mixed
       <parameter>
        <optional>szukana_warto¶æ</optional>
       </parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_keys</function> zwraca klucze, liczbowe i tekstowe, z
     tablicy <parameter>wej¶cie</parameter>.
    </para>
    <para>
     Je¶li podany zosta³ opcjonalny parameter <parameter>szukana_warto¶æ
     </parameter>, zwracane s± tylko klucze dla danej do których przypisana
     jest podana warto¶æ. W przeciwnym przypadku zwracane s± wszystkie klucze
     z tablicy <parameter>wej¶cie</parameter>.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_keys</function></title>
      <programlisting role="php">
<![CDATA[
$tablica = array (0 => 100, "kolor" => "czerwony");
array_keys ($tablica);       // zwraca array (0, "kolor")

$tablica = array ("niebieski", "czerwony", "zielony", "niebieski", "niebieski");
array_keys ($tablica, "niebieski");  //  zwraca array (0, 3, 4) 

$tablica = array ("kolor" => array("niebieski", "czerwony", "zielony"), "rozmiar" => array("ma³y", "¶redni", "du¿y"));
array_keys ($tablica);  //  zwraca array ("kolor", "rozmiar") 
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      Ta funkcja zosta³a dodana w PHP 4. Poni¿ej znajduje siê implementacja
      tej funkcji dla tych, którzy jeszcz u¿ywaj± PHP 3.
      <example>
       <title>
        Implementacja <function>array_keys</function> dla u¿ytkowników
       </title>
       <programlisting role="php">
<![CDATA[
function array_keys ($arr, $term="") {
    $t = array();
    while (list($k,$v) = each($arr)) {
        if ($term &amp;&amp; $v != $term) {
            continue;
            $t[] = $k;
        }
        return $t;
    }
}
]]>
       </programlisting>
      </example>
     </para>
    </note>
    <para>
     Patrz tak¿e <function>array_values</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-map">
   <refnamediv>
    <refname>array_map</refname>
    <refpurpose>
     Wykonuje funkcjê zwrotn± na elementach podanej tablicy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_map</function></funcdef>
      <paramdef>mixed <parameter>funkcja_zwrotna</parameter></paramdef>
      <paramdef>array <parameter>tbl1</parameter></paramdef>
      <paramdef>array
       <parameter><optional>tbl2...</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_map</function> zwraca tablicê zawieraj±c± wszystkie
     elementy tablicy <parameter>tbl1</parameter> po u¿yciu na ka¿dej z nich
     funkcji zwrotnej. Liczba parametrów funkcji zwrotnej powinna byæ równa
     liczbie tablic przekazanych do funkcji <function>array_map</function>.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_map</function></title>
      <programlisting role="php">
<![CDATA[
function szescian($n) {
    return $n*$n*$n;
}

$a = array(1, 2, 3, 4, 5);
$b = array_map("szescian", $a);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     W powy¿szej funkcji tablica <varname>$b</varname> zawiera
     <literal>array (1, 8, 27, 64, 125);</literal>
    </para>
    <para>
     <example>
      <title>
       <function>array_map</function> - u¿ywanie wiêkszej ilo¶ci tablic
      </title>
      <programlisting role="php">
<![CDATA[
function pokaz_po_Hiszpansku($n, $m) {
    return "Po Hiszpañsku liczba $n to $m";
}

function mapuj_na_Hiszpanski($n, $m) {
    return array ($n => $m);
}

$a = array(1, 2, 3, 4, 5);
$b = array("uno", "dos", "tres", "cuatro", "cinco");

$c = array_map("pokaz_po_Hiszpansku", $a, $b);

print_r($c);

// will output:
// Array 
// (
//     [0] => Po Hiszpañsku liczba 1 to uno
//     [1] => Po Hiszpañsku liczba 2 to dos
//     [2] => Po Hiszpañsku liczba 3 to tres
//     [3] => Po Hiszpañsku liczba 4 to cuatro
//     [4] => Po Hiszpañsku liczba 5 to cinco
// )

$d = array_map("mapuj_po_Hiszpansku", $a , $b);

print_r($d);

// wy¶wietli:
// Array 
// (
//     [0] => Array
//         (
//             [1] => uno
//         )
// 
//     [1] => Array
//         (
//             [2] => dos
//         )
// 
//     [2] => Array
//         (
//             [3] => tres
//         )
// 
//     [3] => Array
//         (
//             [4] => cuatro
//         )
// 
//     [4] => Array
//         (
//             [5] => cinco
//         )
// 
// )
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Zazwyczaj u¿ywaj±c dwóch lub wiêcej tablic, powinny one byæ równej
     d³ugo¶ci, poniewa¿ funkcja zwrotna jest wykonywana na odpowiadaj±cych
     sobie elementach tablic.
     Je¶li tablice s± ró¿nych d³ugo¶ci, krótsze bêd± rozszerzane u¿ywaj±c
     pustych elementów.
    </para>
    <para>
     Interesuj±cym sposobem u¿ycia tej funkcji jest kontruowanie tablicy
     tablic, co mo¿e byæ ³atwo przeprowadzone przez podanie &null; jako nazwy
     funkcji zwrotnej.
    </para>
    <para>
     <example>
      <title>Tworzenie tablicy tablic</title>
      <programlisting role="php">
<![CDATA[
$a = array(1, 2, 3, 4, 5);
$b = array("one", "two", "three", "four", "five");
$c = array("uno", "dos", "tres", "cuatro", "cinco");
$d = array("jeden", "dwa", "trzy", "cztery", "piêæ");

$e = array_map(null, $a, $b, $c, $d);
print_r($e);

// wy¶wietli:
// Array
// (
//     [0] => Array
//         (
//             [0] => 1
//             [1] => one
//             [2] => uno
//             [3] => jeden
//         )
// 
//     [1] => Array
//         (
//             [0] => 2
//             [1] => two
//             [2] => dos
//             [3] => dwa
//         )
// 
//     [2] => Array
//         (
//             [0] => 3
//             [1] => three
//             [2] => tres
//             [3] => trzy
//         )
// 
//     [3] => Array
//         (
//             [0] => 4
//             [1] => four
//             [2] => cuatro
//             [3] => cztery
//         )
// 
//     [4] => Array
//         (
//             [0] => 5
//             [1] => five
//             [2] => cinco
//             [3] => piêæ
//         )
// 
// )
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Patrz tak¿e <function>array_filter</function>,
     <function>array_reduce</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-merge">
   <refnamediv>
    <refname>array_merge</refname>
    <refpurpose>£±czy dwie lub wiêcej tablic</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_merge</function></funcdef>
      <paramdef>array <parameter>tablica1</parameter></paramdef>
      <paramdef>array <parameter>tablica2</parameter></paramdef>
      <paramdef>array
       <parameter><optional>...</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_merge</function> ³±czy elementy dwóch lub wiêcej tablic
     razem, tak ¿e warto¶ci jednej tablicy s± wstawiane na koniec poprzedniej
     tablicy. Funkcja ta zwraca tabelê wynikow±.
    </para>
    <para>
     Je¶li tablice wej¶ciowe maj± takie same klucze tekstowe, najnowsza
     warto¶æ nadpisze starsz±. Jednak¿e je¶³i tablice bêd± mia³y takie same
     klucze liczbowe, pó¼niejsza warto¶æ nie nadpisze starszej, lecz zostanie
     dopisana na koniec tablicy.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_merge</function></title>
      <programlisting role="php">
<![CDATA[
$tablica1 = array ("kolor" => "czerwony", 2, 4);
$tablica2 = array ("a", "b", "kolor" => "zielony", "kszta³t" => "trapezoid", 4);
$wynik = array_merge ($tablica1, $tablica2);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     W powy¿szym przyk³adze tablica <varname>$wynik</varname> zawiera
     <literal>array("kolor" =&gt; "zielony", 2, 4,
     "a", "b", "kszta³t" =&gt; "trapezoid", 4)</literal>.
    </para>
    <para>
     Patrz tak¿e <function>array_merge_recursive</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-merge-recursive">
   <refnamediv>
    <refname>array_merge_recursive</refname>
    <refpurpose>£±czy dwie lub wiêcej tablic rekurencyjnie</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_merge_recursive</function></funcdef>
      <paramdef>array <parameter>tablica1</parameter></paramdef>
      <paramdef>array <parameter>tablica2</parameter></paramdef>
      <paramdef>array
       <parameter><optional>...</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_merge_recursive</function> ³±czy elementy dwóch lub
     wiêcej tablic tak, ¿e warto¶ci jednej tablicy s± dopisywane na koniec
     poprzedniej. Zwracana jest tablica wynikowa.
    </para>
    <para>
     Je¶li wej¶ciowe tablice maj± jakie¶ klucze tekstowe, to warto¶ci dla tych
     kluczy s± ³±czone w tablicê, co jest robione rekurencyjnie, a wiêc je¶li
     jedn± z warto¶ci jest tablica, funkcja po³±czy j± z odpowiadaj±c± jej
     warto¶ci± z innej tablicy. Jednak¿e je¶li tablice maj± takie same klucze
     liczbowe, pó¼niejsza warto¶æ nie nadpisze pocz±tkowej warto¶ci, lecz
     zostanie dopisana na koniec.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_merge_recursive</function></title>
      <programlisting role="php">
<![CDATA[
$tbl1 = array ("kolor" => array ("ulubiony" => "czerwony"), 5);
$tbl2 = array (10, "kolor" => array ("ulubiony" => "zielony", "niebieski"));
$wynik = array_merge_recursive ($tbl1, $tbl2);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     W powy¿szym przyk³adzie tablica <varname>$wynik</varname> zawiera
     <literal>array ("kolor" =&gt; array ("ulubiony" =&gt; array ("czerwony",
     "zielony"), "niebieski"), 5, 10)</literal>.
    </para>
    <para>
     Patrz tak¿e <function>array_merge</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-multisort">
   <refnamediv>
    <refname>array_multisort</refname>
    <refpurpose>Sortuje wiele tablic lub wielowymiarowe tablice</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>array_multisort</function></funcdef>
      <paramdef>array <parameter>tbl1</parameter></paramdef>
      <paramdef>mixed
       <parameter><optional>arg</optional></parameter>
      </paramdef>
      <paramdef>mixed
       <parameter><optional>...</optional></parameter>
      </paramdef>
      <paramdef>array
       <parameter><optional>...</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_multisort</function> mo¿e byæ u¿yta do sortowania kilku
     tablic na raz lub wielowymiarowej tablicy na podstawie jednego z wiêkszej
     liczby wymiarów. Zachowywane s± przypisania kluczy.
    </para>
    <para>
     Tablice wej¶ciowe s± traktowane jak kolumy tabeli, które maj± byæ
     posortowane wierszami - odpowiada to funkcjonalno¶ci warunku SQL ORDER
     BY. Pierwsza tablica jest tablic± priorytetow± do sortowania. Wiersze
     (warto¶ci) w tej tablic± które s± takie sane sortowane s± wed³ug
     nastêpnej tablicy wej¶ciowej i tak dalej.
    </para>
    <para>
     Struktura argumentów tej funkcji nie jest zwyczajna, ale jest ona
     elastyczna. Pierwszy argument musi byæ tablic±. Ka¿dy nastêpny argument
     musi byæ tablic± lub flag± oznaczaj±c± porz±dek sortowania - jeden z
     poni¿szych.
    </para>
    <para>
     Flagi porz±dku sortowania:
     <itemizedlist>
      <listitem>
       <simpara>SORT_ASC - sortuj w porz±dku rosn±cym</simpara>
      </listitem>
      <listitem>
       <simpara>SORT_DESC - sortuj w porz±dku malej±cym</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Flagi typu sortowania:
     <itemizedlist>
      <listitem>
       <simpara>SORT_REGULAR - porównuj elementy normalnie</simpara>
      </listitem>
      <listitem>
       <simpara>SORT_NUMERIC - porównuj elementy numerycznie</simpara>
      </listitem>
      <listitem>
       <simpara>SORT_STRING - porówuj elementy jak stringi</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Nie mo¿na podaæ ¿adnych dwóch flag tego samego typu dla jednej tablicy.
     Flagi sortowania podane pod argumencie-tablicy dotycz± tylko tej tablicy
     - s± one zerowane do domy¶lnych warto¶æi SORT_ASC i SORT_REGULAR po
     ka¿dym argumencie tablicowym.
    </para>
    <para>
     Zwraca &true; w przypadku sukcesu, &false; w przypadku pora¿ki.
    </para>
    <para>
     <example>
      <title>Sortowanie wielu tablic</title>
      <programlisting role="php">
<![CDATA[
$tbl1 = array ("10", 100, 100, "a");
$tbl2 = array (1, 3, "2", 1);
array_multisort ($tbl1, $tbl2);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     W tym przypadku, po sortowaniu, pierwsza tablica bêdzie zawieraæ 10,
     "a", 100, 100, a druga 1, 1, "2", 3. Elementy drugiej tablicy
     odpowiadaj±ce identycznym elementom pierwszej tablicy (100 i 100) tak¿e
     zosta³y posortowane.
    </para>
    <para>
     <example>
      <title>Sortowanie wielowymiarowych tablic</title>
      <programlisting role="php">
<![CDATA[
$tbl = array (array ("10", 100, 100, "a"), array (1, 3, "2", 1));
array_multisort ($tbl[0], SORT_ASC, SORT_STRING, 
                 $tbl[1], SORT_NUMERIC, SORT_DESC);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     W tym przyk³adzie, po sortowaniu, pierwsza tablica zawiera 10,
     100, 100, "a" (zosta³a posortowana wed³ug warto¶ci tekstowych w porz±dku
     rosn±cym), a druga 1, 3, "2", 1 (sortowana jak liczby w porz±dku
     malej±cym).
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-pad">
   <refnamediv>
    <refname>array_pad</refname>
    <refpurpose>
     Dope³nij tablicê do podanej d³ugo¶ci podanymi warto¶ciami
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_pad</function></funcdef>
      <paramdef>array <parameter>wej¶cie</parameter></paramdef>
      <paramdef>int <parameter>rozmiar</parameter></paramdef>
      <paramdef>mixed <parameter>warto¶æ</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_pad</function> zwraca kopiê tablicy
     <parameter>input</parameter> dope³nion± do rozmiaru okre¶lonego przez
     <parameter>rozmiar</parameter> warto¶ci±
     <parameter>warto¶æ</parameter>. Je¶li <parameter>rozmiar</parameter>
     jest warto¶ci± dodatni±, to tablica jest dope³niana z prawej strony,
     je¶li ujemna to z lewej. Je¶li warto¶æ bezwzglêdna parametru
     <parameter>rozmiar</parameter> jest mniejsza lub równa d³ugo¶ci tablicy
     <parameter>wej¶cie</parameter>, to tablica nie jest dope³niana.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_pad</function></title>
      <programlisting role="php">
<![CDATA[
$wejscie = array (12, 10, 9);

$wynik = array_pad ($wejscie, 5, 0);
// wynik to array (12, 10, 9, 0, 0)

$wynik = array_pad ($wejscie, -7, -1);
// wynik to array (-1, -1, -1, -1, 12, 10, 9)

$wynik = array_pad ($wejscie, 2, "noop");
// nie ma dope³niania
]]>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-pop">
   <refnamediv>
    <refname>array_pop</refname>
    <refpurpose>Zdejmij element z koñca tablicy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>array_pop</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_pop</function> zdejmuje i zwraca ostatni± warto¶æ tablicy
     <parameter>tablica</parameter>, skracaj±c t± tablicê o jeden element.
     Je¶li <parameter>tablica</parameter> jest pusta (lub nie jest tablic±),
     zwracana jest warto¶æ &null;.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_pop</function></title>
      <programlisting role="php">
<![CDATA[
$stos = array ("pomarañcza", "jab³ko", "malina");
$owoc = array_pop ($stos);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Po wykonaniu powy¿szego kodu <varname>$stos</varname> bêdzie mia³ tylko
     dwa elementy: "pomarañcza" i "jab³ko", a zmienna <varname>$owoc</varname>
     bêdzie zawiera³a string "malina".
    </para>
    <para>
     Patrz tak¿e <function>array_push</function>,
     <function>array_shift</function> i
     <function>array_unshift</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-push">
   <refnamediv>
    <refname>array_push</refname>
    <refpurpose>
     Wstaw jeden lub wiêcej elementów na koniec tablicy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>array_push</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
      <paramdef>mixed <parameter>wartosc</parameter></paramdef>
      <paramdef>mixed
       <parameter><optional>...</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_push</function> traktuje zmienn± <parameter>tablica
     </parameter> jako stos i wstawia przekazane parametry na koniec podanej
     tablicy. D³ugo¶æ parametru <parameter>tablica</parameter> zwiêksza siê o
     liczbê przekazanych warto¶ci. Ma to taki sam efekt jak kod:
     <programlisting role="php">
<![CDATA[
$tablica[] = $wartosc;
]]>
     </programlisting>
     powtórzony dla ka¿dego parametru <parameter>wartosc</parameter>.
    </para>
    <para>
     Funkcja zwraca now± liczbê elementów tablicy.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_push</function></title>
      <programlisting role="php">
<![CDATA[
$stos = array (1, 2);
array_push ($stos, "+", 3);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Po wykonaniu powy¿szego kodu zmienna <varname>$stos</varname> bêdzie
     zawiera³a 4 elementy: 1, 2, "+" i 3.
    </para>
    <para>
     Patrz tak¿e <function>array_pop</function>,
     <function>array_shift</function> i
     <function>array_unshift</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-rand">
   <refnamediv>
    <refname>array_rand</refname>
    <refpurpose>
     Wybiesz jeden lub wiêcej losowych elementów z tablicy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>array_rand</function></funcdef>
      <paramdef>array <parameter>wej¶cie</parameter></paramdef>
      <paramdef>int
       <parameter><optional>ilo¶æ</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Funkcja <function>array_rand</function> jest przydatna je¶li chcesz
     wyci±gn±æ jeden lub wiêcej losowych elementów z tablicy. Jako parametry
     pobiera tablicê <parameter>wej¶cie</parameter> i opcjonalny parameter
     <parameter>ilo¶æ</parameter> który okre¶la ile elementów tablicy chcesz
     wyci±gn±æ - je¶li nie podano, przymowana jest domy¶lna warto¶æ 1.
    </para>
    <para>
     Je¶li wyci±gasz tylko jeden element, <function>array_rand</function>
     zwraca klucz losowego wpisu. W przeciwnym przypadku zwracana jest tablica
     zawieraj±ca klucze losowych wpisów. Dzieje siê tak, ¿eby mo¿na by³o
     wyci±gn±æ jednocze¶nie klucze i warto¶ci losowych elementów tablicy.
    </para>
    <para>
     Nie zapomnij wywo³aæ <function>srand</function> aby zainicjowaæ ziarno
     generatora liczb pseudolosowych.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_rand</function></title>
      <programlisting role="php">
<![CDATA[
srand ((float) microtime() * 10000000);
$wejscie = array ("Neo", "Morpheus", "Trinity", "Cypher", "Tank");
$losowe_klucze = array_rand ($wejscie, 2);
print $wejscie[$losowe_klucze[0]]."\n";
print $wejscie[$losowe_klucze[1]]."\n";
]]>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>
  
  <refentry id="function.array-reverse">
   <refnamediv>
    <refname>array_reverse</refname>
    <refpurpose>
     Zwraca tablicê z elementami ustawionymi w porz±dku odwrotnym
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_reverse</function></funcdef>
      <paramdef>array <parameter>wej¶cie</parameter></paramdef>
      <paramdef>bool 
       <parameter><optional>zachowaj_klucze</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_reverse</function> pobiera tablicê
     <parameter>wej¶cie</parameter> i zwraca now± tablicê z odwróconym
     porz±dkiem wystêpowania elementów, zachowuj±c klucze tylko je¶li warto¶æ
     parametru <parameter>zachowaj_klucze</parameter> to &true;.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_reverse</function></title>
      <programlisting role="php">
<![CDATA[
$wejscie = array ("php", 4.0, array ("zielony", "czerwony"));
$wynik = array_reverse ($wejscie);
$wynik_kluczowany = array_reverse ($input, TRUE);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     I <varname>$wynik</varname> i <varname>$wynik_kluczowany</varname> 
     bêd± zawiera³y <literal>array(array
     ("zielony", "czerwony"), 4.0, "php")</literal>. Ale
     <varname>$wynik_kluczowany[0]</varname> ci±gle bêdzie zawiera³
     <literal>"php"</literal>.
    </para>
    <note>
     <para>
      Drugi parametr zosta³ dodany w PHP 4.0.3.
     </para>
    </note>
   </refsect1>
  </refentry>

  <refentry id="function.array-reduce">
   <refnamediv>
    <refname>array_reduce</refname>
    <refpurpose>
     Iteracyjnie zredukuj tablicê do pojedyñczej warto¶ci u¿ywaj±c funkcji
     zwrotnej
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>array_reduce</function></funcdef>
      <paramdef>array <parameter>wej¶cie</parameter></paramdef>
      <paramdef>mixed <parameter>funkcja_zwrotna</parameter></paramdef>
      <paramdef>int
       <parameter><optional>pocz±tek</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_reduce</function> iteracyjnie stosuje funkcjê
     <parameter>funkcja_zwrotna</parameter> na ka¿dym elemencie tablicy
     <parameter>wej¶cie</parameter> aby zredukowaæ tablicê to pojedyñczej
     warto¶ci. Je¶li podany zosta³ opcjonalny parametr <parameter>pocz±tek
     </parameter>, bêdzie on u¿yty na pocz±tku procesu, lub jako zwracana
     warto¶æ je¶li tablica jest pusta.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_reduce</function></title>
      <programlisting role="php">
<![CDATA[
function rsum($v, $w) {
    $v += $w;
    return $v;
}

function rmul($v, $w) {
    $v *= $w;
    return $v;
}

$a = array(1, 2, 3, 4, 5);
$x = array();
$b = array_reduce($a, "rsum");
$c = array_reduce($a, "rmul", 10);
$d = array_reduce($x, "rsum", 1);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Po wykonaniu powy¿szego kodu zmienna <varname>$b</varname> bêdzie
     zawiera³a <literal>15</literal>, <varname>$c</varname>
     <literal>1200</literal> (= 1*2*3*4*5*10) a
     <varname>$d</varname> containing <literal>1</literal>.
    </para>
    <para>
     Patrz tak¿e <function>array_filter</function>,
     <function>array_map</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-shift">
   <refnamediv>
    <refname>array_shift</refname>
    <refpurpose>
     Usuñ element z pocz±tku tablicy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>array_shift</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_shift</function> usuwa pierwsz± warto¶æ parametru
     <parameter>tablica</parameter> i zwraca go skracaj±c t± tablicê o jeden
     element przesuwaj±c wszystkie pozosta³e elementy w dó³. Je¶li
     <parameter>tablica</parameter> jest pusta (lub nie jest tablic±),
     zwracana jest warto¶æ &null;.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_shift</function></title>
      <programlisting role="php">
<![CDATA[
$argumenty = array ("-v", "-f");
$opcja = array_shift ($argument);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Po wykonaniu powy¿szego kodu zmienna <varname>$args</varname> bêdzie
     zawiera³a jeden element "-f" a <varname>$opcja</varname> bêdzie zawiera³a
     string "-v".
    </para>
    <para>
     Patrz tak¿e <function>array_unshift</function>,
     <function>array_push</function> i
     <function>array_pop</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-slice">
   <refnamediv>
    <refname>array_slice</refname>
    <refpurpose>Wytnij kawa³ek tablicy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_slice</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
      <paramdef>int <parameter>przesuniêcie</parameter></paramdef>
      <paramdef>int
       <parameter>
        <optional>d³ugo¶æ</optional>
       </parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_slice</function> zwraca sekwencjê elementów z tablicy
     <parameter>tablica</parameter> okre¶lony przez parametry
     <parameter>przesuniêcie</parameter> i <parameter>d³ugo¶æ</parameter>.
    </para>
    <para>
     Je¶li <parameter>przesuniêcie</parameter> jest dodatnie, sekwencja
     zacznie siê od miejsca wskazanego w tym parametrze. Je¶li
     <parameter>przesuniêcie</parameter> jest ujemne, sekwencja zacznie siê o
     tyle elementów od koñca tablicy <parameter>tablica</parameter>.
    </para>
    <para>
     Je¶li podany jest parametr <parameter>d³ugo¶æ</parameter> i jest on
     dodatni, to sekwencja bêdzie mia³a tyle elementów ile podano w tym
     parameterz. Je¶li <parameter>d³ugo¶æ</parameter> jest ujemna, to
     sekwencja skoñczy siê o tyle elementów od koñca tablicy. Je¶li zosta³
     pominiêty, to sekwencja bêdzie zawieraæ wszystko od
     <parameter>przesuniêcie</parameter> do koñca parametru
     <parameter>tablica</parameter>.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_slice</function></title>
      <programlisting role="php">
<![CDATA[
$wejscie = array ("a", "b", "c", "d", "e");

$wyjscie = array_slice ($wejscie, 2);      // zwraca "c", "d" i "e"
$wyjscie = array_slice ($wejscie, 2, -1);  // zwraca "c", "d"
$wyjscie = array_slice ($wejscie, -2, 1);  // zwraca "d"
$wyjscie = array_slice ($wejscie, 0, 3);   // zwraca "a", "b" i "c"
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Patrz tak¿e <function>array_splice</function>.
    </para>     
   </refsect1>
  </refentry>

  <refentry id="function.array-splice">
   <refnamediv>
    <refname>array_splice</refname>
    <refpurpose>
     Usuñ czê¶æ tablicy i zamieñ j± na co¶ innego
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_splice</function></funcdef>
      <paramdef>array <parameter>wej¶cie</parameter></paramdef>
      <paramdef>int <parameter>przesuniêcie</parameter></paramdef>
      <paramdef>int
       <parameter><optional>d³ugo¶æ</optional></parameter>
      </paramdef>
      <paramdef>array
       <parameter>
        <optional>zamiennik</optional>
       </parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_splice</function> usuwa z tablicy <parameter>wej¶cie
     </parameter> elementy okre¶lone przez parametry
     <parameter>przesuniêcie</parameter> i
     <parameter>d³ugo¶æ</parameter>, i zamienia je przez elementy tablicy
     <parameter>zamiennik</parameter>, je¶li zosta³a ona podana.
    </para>
    <para>
     Je¶li <parameter>przesuniêcie</parameter> jest dodatnie, to pocz±tek
     usuwanej czê¶ci tablicy <parameter>wej¶cie</parameter> znajduje siê
     w miejscu okre¶lonym przez ten parametr. Je¶li
     <parameter>przesuniêcie</parameter> jest ujemne, to wycinanie zaczyna siê
     o tyle elementów od koñca tablicy <parameter>wej¶cie</parameter>.
    </para>
    <para>
     Je¶li <parameter>d³ugo¶æ</parameter> zosta³a pominiêta, to usuniête jest
     wszystko od <parameter>przesuniêcie</parameter> do koñca tablicy. Je¶li
     <parameter>d³ugo¶æ</parameter> jest podana i dodatnia, to tyle elementów
     zostanie usuniêtych. Je¶li <parameter>d³ugo¶æ</parameter> jest podana i
     jest ujemna, to koniec usuwanego kawa³ka tablicy bêdzie siê znajdowa³ o
     tyle elementów od koñca tablicy. Wskazówka: aby usun±æ wszystko od
     <parameter>przesuniêcie</parameter> do koñca tablicy podaj±c tak¿e
     parametr <parameter>zamiennik</parameter>, u¿yj
     <literal>count($wej¶cie)</literal> jako <parameter>d³ugo¶æ</parameter>.
    </para>
    <para>
     Je¶li podana zosta³a tablica <parameter>zamiennik</parameter>, to
     wszystkie usuniête elementy s± zamieniane na elementy z tej tablicy.
     Je¶li <parameter>przesuniêcie</parameter> i <parameter>d³ugo¶æ</parameter>
     zosta³y podane tak, ¿e ¿adne elementy nie zostan± usuniête, to elementy z
     tablicy <parameter>zamiennik</parameter> s± wstawiane w miejsce okre¶lone
     przez <parameter>przesuniêcie</parameter>. Wskazówka: je¶li zamiennik to
     tylko jeden element, to nie trzeba go wstawiaæ do
     <literal>array()</literal>, chyba ¿e element jest w³a¶nie tablic±.
    </para>
    <para>
     Równoznaczno¶ci kodu:
     <programlisting role="php">
<![CDATA[
array_push ($wejscie, $x, $y)     array_splice ($wejscie, count ($wejscie), 0, 
                                               array ($x, $y))
array_pop ($wejscie)              array_splice ($wejscie, -1)
array_shift ($wejscie)            array_splice ($wejscie, 0, 1)
array_unshift ($wejscie, $x, $y)  array_splice ($wejscie, 0, 0, array ($x, $y))
$a[$x] = $y                       array_splice ($wejscie, $x, 1, $y)
]]>
     </programlisting>
    </para>
    <para>
     Funkcja zwraca tablicê zawieraj±c± usuniête elementy.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_splice</function></title>
      <programlisting role="php">
<![CDATA[
$wejscie = array ("czerwony", "zielony", "niebieski", "¿ó³ty");
array_splice ($wejscie, 2);      
// $wejscie to teraz array ("czerwony", "zielony")

$wejscie = array ("czerwony", "zielony", "niebieski", "¿ó³ty");
array_splice ($wejscie, 1, -1);  
// $wejscie to teraz array ("czerwony", "¿ó³ty")

$wejscie = array ("czerwony", "zielony", "niebieski", "¿ó³ty");
array_splice ($wejscie, 1, count($wejscie), "pomarañczowy");  
// $wejscie to teraz array ("czerwony", "pomarañczowy")

$wejscie = array ("czerwony", "zielony", "niebieski", "¿ó³ty");
array_splice ($wejscie, -1, 1, array("czarny", "kasztanowy")); 
// $wejscie to teraz array ("czerwony", "zielony", 
//          "niebieski", "czarny", "kasztanowy")
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Patrz tak¿e <function>array_slice</function>.
    </para>
   </refsect1>
  </refentry>
 
  <refentry id="function.array-sum">
   <refnamediv>
    <refname>array_sum</refname>
    <refpurpose>
     Oblicza sumê warto¶ci w tablicy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>array_sum</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_sum</function> zwraca sumê wszystkich warto¶ci w tablicy
     jako liczbê ca³kowit± lub rzeczywist±.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_sum</function></title>
      <programlisting role="php">
<![CDATA[
$a = array(2, 4, 6, 8);
echo "sum(a) = ".array_sum($a)."\n";
// wy¶wietla: sum(a) = 20

$b = array("a"=>1.2,"b"=>2.3,"c"=>3.4);
echo "sum(b) = ".array_sum($b)."\n";
// wy¶wietla: sum(b) = 6.9
]]>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-unique">
   <refnamediv>
    <refname>array_unique</refname>
    <refpurpose>Usuwa duplikaty warto¶ci z tablicy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_unique</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_unique</function> pobiera parametr
     <parameter>tablica</parameter> i zwraca now± tablicê bez duplikatów
     warto¶ci.
    </para>
    <para>
     Zauwa¿, ¿e klucze s± zachowywane. <function>array_unique</function>
     zachowa pierwszy napotkany klucz dla ka¿dej warto¶ci ignoruj±c wszystkie
     pozosta³e.
    </para>
    <note>
     <simpara>
      Dwa elementy tablicy s± uwa¿ane za równe wtedy i tylko wtedy je¶li
      <literal>(string) $elem1 === (string) $elem2</literal>, czyli je¶li
      reprezentacje warto¶ci w postaci stringów s± takie same.
      <!-- TODO: example of it... -->
     </simpara>
     <simpara>
      U¿ywany bêdzie pierwszy element.
     </simpara>
    </note>
    <warning>
     <simpara>
      Ta funkcja by³a zepsuta w PHP 4.0.4!
      <!-- TODO: when exactly was this broken?... -->
     </simpara>
    </warning>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_unique</function></title>
      <programlisting role="php">
<![CDATA[
$wejscie = array ("a" => "zielony", "czerwony", "b" => "zielony", "niebieski", "czerwony");
$wynik = array_unique ($wejscie);
print_r($wynik);
// wy¶wietli siê :
//Array
//(
//    [a] => zielony
//    [0] => czerwony
//    [1] => niebieski
//)
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title><function>array_unique</function> i typy</title>
      <programlisting role="php">
<![CDATA[
$wejscie = array (4,"4","3",4,3,"3");
$wynik = array_unique ($wejscie);
var_dump($wynik);

/* wyj¶cie:
array(2) {
   [0]=>
   int(4)
   [1]=>
   string(1) "3"
}
*/
]]>
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-unshift">
   <refnamediv>
    <refname>array_unshift</refname>
    <refpurpose>
     Wstaw jeden lub wiêcej elementów na pocz±tek tablicy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>array_unshift</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
      <paramdef>mixed <parameter>warto¶æ</parameter></paramdef>
      <paramdef>mixed
       <parameter>
        <optional>...</optional>
       </parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_unshift</function> wstawia jeden lub wiêcej przekazanych
     jako parametry elementów na pocz±tek tablicy
     <parameter>tablica</parameter>. Zauwa¿, ¿e lista elementów wstawiana jako
     ca³o¶æ, wiêc elementy zostaj± w takim samym porz±dku.
    </para>
    <para>
     Funkcja zwraca now± liczbê elementów w tablicy
     <parameter>tablica</parameter>.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_unshift</function></title>
      <programlisting role="php">
<![CDATA[
$kolejka = array ("p1", "p3");
array_unshift ($kolejka, "p4", "p5", "p6");
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Po wykonaniu powy¿szego kodu zmienna <varname>$kolejka</varname> bêdzie
     zawiera³a 5 elementów: "p4", "p5", "p6", "p1", and "p3".
    </para>
    <para>
     Patrz tak¿e <function>array_shift</function>,
     <function>array_push</function> i
     <function>array_pop</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-values">
   <refnamediv>
    <refname>array_values</refname>
    <refpurpose>Zwraca wszystkie warto¶ci z tablicy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>array_values</function></funcdef>
      <paramdef>array <parameter>wej¶cie</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>array_values</function> zwraca wszystkie warto¶ci z tablicy
     <parameter>wej¶cie</parameter>.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_values</function></title>
      <programlisting role="php">
<![CDATA[
$tablica = array ("rozmiar" => "XL", "kolor" => "z³oty");
array_values ($tablica);    // zwraca array ("XL", "z³oty")
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      Ta funkcja zosta³a dodana w PHP 4. Poni¿ej znajduje siê implementacja
      tej funkcji dla osób u¿ywaj±cych PHP 3.
      <example>
       <title>
        Implementacja funkcji <function>array_values</function> dla
        u¿ytkowników PHP 3
       </title>
       <programlisting role="php">
<![CDATA[
function array_values ($arr) {
    $t = array();
    while (list($k, $v) = each ($arr)) {
        $t[] = $v;
    }
    return $t;
}
]]>
       </programlisting>
      </example>
     </para>
    </note>
    <para>
     Patrz tak¿e <function>array_keys</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-walk">
   <refnamediv>
    <refname>array_walk</refname>
    <refpurpose>
     Zastosuj funkcjê u¿ytkownika do ka¿dego elementu tablicy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>array_walk</function></funcdef>
      <paramdef>array <parameter>tbl</parameter></paramdef>
      <paramdef>string <parameter>funk</parameter></paramdef>
      <paramdef>mixed 
       <parameter><optional>dane</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     Wykonuje zdefuniowan± przez u¿ytkownika funkcjê o nazwie 
     <parameter>funk</parameter> na ka¿dym elemencie tablicy 
     <parameter>tbl</parameter>.
     Warto¶æ elementu bêdzie przekazana do <parameter>funk</parameter> jako
     pierwszy parametr, a klucz jako drugi. Je¶li podany zostanie parametr
     <parameter>dane</parameter>, to bêdzie on przekazany do funkcji jako
     trzeci parametr. <parameter>funk</parameter> musi byæ funkcj±
     zdefiniowan± przez u¿ytkownika, a nie natywn± funkcj± PHP. W zwi±zku z
     tym nie mo¿esz bezpo¶rednio u¿yæ <function>array_walk</function> z
     <function>str2lower</function>. Musisz najpierw napisaæ funkcjê
     zawieraj±c± <function>str2lower</function> i przekazaæ t± funkcjê jako
     parametr.
    </simpara>
    <simpara>
     Je¶li <parameter>funk</parameter> wymaga wiêcej ni¿ dwóch lub trzech
     parametrów, zale¿nie od parametru <parameter>dane</parameter>,
     wygenerowane bêdzie ostrze¿enie za ka¿dym razem, kiedy
     <function>array_walk</function> bêdzie wywo³ywa³a
     <parameter>funk</parameter>. Ostrze¿enia te mog± byæ ukryte przez dodanie
     znaku '@' przed wywo³aniem <function>array_walk</function> lub u¿ywaj±c
     <function>error_reporting</function>.
    </simpara>
    <note>
     <para>
      Je¶li <parameter>funk</parameter> ma zmieniaæ warto¶ci tablicy, okre¶l
      pierwszy parametr <parameter>funk</parameter> jako referencjê. W tym
      przypadku wszystkie zmiany dokonane przez t± funkcjê bêd± dokonywane
      bezpo¶rednio na tablicy.
     </para>
    </note>
    <note>
     <para>
      Przekazywanie klucza i danych u¿ytkownika do <parameter>funk</parameter>
      zosta³o dodane w PHP 4.0
     </para>
     <para>
      W PHP 4 konieczne jest wywo³anie <function>reset</function> poniewa¿
      <function>array_walk</function> nie resetuje tablicy domy¶lnie.
     </para>
    </note>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>array_walk</function></title>
      <programlisting role="php">
<![CDATA[
$owoce = array ("d"=>"cytryna", "a"=>"pomarañcza", "b"=>"banan", "c"=>"jab³ko");

function test_zmiana (&amp;$element1, $klucz, $prefiks) {
    $element1 = "$prefiks: $element1";
}

function test_wyswietlanie ($element2, $klucz) {
    echo "$klucz. $element2<br>\n";
}

array_walk ($owoce, 'test_wyswietlanie');
reset ($owoce);
array_walk ($owoce, 'test_zmiana', 'owoc');
reset ($owoce);
array_walk ($owoce, 'test_wyswietlanie');
]]>
      </programlisting>
     </example>
    </para>
    <simpara>
     Patrz tak¿e <function>each</function> i <function>list</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.arsort">
   <refnamediv>
    <refname>arsort</refname>
    <refpurpose>
     Sortuj tablicê w porz±dku odwrotnym i zachowaj skojarzenia kluczy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>arsort</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
      <paramdef>int 
       <parameter><optional>flagi</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Ta funkcja sortuje tablicê w taki sposób, ¿e klucze zachowuj± przypisanie
     do odpowiednich warto¶ci. Ten sposób sortowania jest u¿ywany g³ównie przy
     sortowaniu tablic asocjacyjnych, gdzie znacz±ca jest kolejno¶æ
     wystêpowania elementów w tablicy.
    </para>
    <example>
     <title>Przyk³ad u¿ycia <function>arsort</function></title>
     <programlisting role="php">
<![CDATA[
$owoce = array ("d"=>"cytryna, "a"=>"pomarañcza", "b"=>"banan", "c"=>"jab³ko");
arsort ($owoce);
reset ($owoce);
while (list ($key, $val) = each ($owoce)) {
    echo "$key = $val\n";
}
]]>
     </programlisting>
     <para>
      Ten przyk³ad wy¶wietli:
      <screen>
<![CDATA[
a = pomarañcza
c = jab³ko
d = cytryna
b = banan
]]>
      </screen>
     </para>
    </example>
    <para>
     Owoce zosta³y posortowane w odwrotnym porz±dku alfabetycznym a
     skojarzenia kluczy dla ka¿dego elementu zosta³y zachowane.
    </para>
    <para>
     Mo¿esz zmodyfikowaæ zachowanie sortowania przez u¿ycie opcjonalnego
     parametru <parameter>flagi</parameter>. Aby uzyskaæ szczegó³y zobacz
     <function>sort</function>.
    </para>
    <para>
     Patrz tak¿e <function>asort</function>, <function>rsort</function>,
     <function>ksort</function> i <function>sort</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.asort">
   <refnamediv>
    <refname>asort</refname>
    <refpurpose>Posortuj tablicê zachowuj±c skojarzenia kluczy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>asort</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
      <paramdef>int 
       <parameter><optional>flagi</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Funkcja ta sortuje tablicê w taki sposób, ¿e klucze zachowuj± przypisanie
     do odpowiednich warto¶ci. Ten sposób sortowania jest u¿ywany g³ównie przy
     sortowaniu tablic asocjacyjnych, gdzie znacz±ca jest kolejno¶æ
     wystêpowania elementów w tablicy.
    </para>
    <example>
     <title>Przyk³ad u¿ycia <function>asort</function></title>
     <programlisting role="php">
<![CDATA[
$owoce = array ("d"=>"cytryna, "a"=>"pomarañcza", "b"=>"banan", "c"=>"jab³ko");
arsort ($owoce);
reset ($owoce);
while (list ($key, $val) = each ($owoce)) {
    echo "$key = $val\n";
}
]]>
     </programlisting>
     <para>
      Ten przyk³ad wy¶wietli:
      <screen>
<![CDATA[
b = banan
d = cytryna
c = jab³ko
a = pomarañcza
]]>
      </screen>
     </para>
    </example>
    <para>
     Owoce zosta³y posortowane w porz±dku alfabetycznym a
     skojarzenia kluczy dla ka¿dego elementu zosta³y zachowane.
    </para>
    <para>
     Mo¿esz zmodyfikowaæ zachowanie sortowania przez u¿ycie opcjonalnego
     parametru <parameter>flagi</parameter>. Aby uzyskaæ szczegó³y zobacz
     <function>sort</function>.
    </para>
    <para>
     Patrz tak¿e <function>arsort</function>, <function>rsort</function>,
     <function>ksort</function> i <function>sort</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.compact">
   <refnamediv>
    <refname>compact</refname>
    <refpurpose>
     Stwórz tablicê zawieraj±c± zmienne i ich warto¶ci
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>compact</function></funcdef>
      <paramdef>mixed <parameter>nazwa_zmiennej</parameter></paramdef>
      <paramdef>mixed
       <parameter><optional>...</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>compact</function> pobiera zmienn± liczbê parametrów. Ka¿dy
     parametr mo¿e byæ albo stringiem zawieraj±cym nazwê zmiennej lub
     tablicê nazw zmiennych. Tablica mo¿e zaieraæ w sobie inne tablice nazw
     zmiennych; <function>compact</function> obs³u¿y je rekurencyjnie.
    </para>
    <para>
     Dla ka¿dej z nich <function>compact</function> sprawdza zmienn± o
     nazwie okre¶lnej przez bie¿±cy symbol w tablicy i dodaje j± do tablicy
     wyj¶ciowej tak, ¿e nazwa zmiennej staje siê kluczem z zawarto¶æ
     zmiennej warto¶ci± dla tego klucza. W skrócie, funkcja ta jest
     przeciwno¶ci± <function>extract</function>. Zwraca ona tablicê
     zawieraj±c± zmienne do niej dodane.
    </para>
    <para>
     Dowolne stringi, które nie s± ustawione, poprostu bêd± pominiête.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>compact</function></title>
      <programlisting role="php">
<![CDATA[
$miasto = "San Francisco";
$stan = "CA";
$wydarzenie = "SIGGRAPH";

$zmienne_lokalizacyjne = array ("miasto", "stan");

$wynik = compact ("wydarzenie", "nic", $zmienne_lokalizacyjne);
]]>
      </programlisting>
      <para>
       Po tym <varname>$wynik</varname> bêdzie zawiera³ <literal>array
       ("wydarzenie" =&gt; "SIGGRAPH", "miasto" =&gt; "San Francisco",
       "stan" =&gt; "CA")</literal>.
      </para>
     </example>
    </para>
    <para>
     Patrz tak¿e <function>extract</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.count">
   <refnamediv>
    <refname>count</refname>
    <refpurpose>Zlicza ilo¶æ elementów w tablicy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>count</function></funcdef>
      <paramdef>mixed <parameter>zmienna</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Zwraca ilo¶æ elementów w parametrze <parameter>zmienna</parameter>,
     która zazwyczaj bêdzie tablic± (poniewa¿ wszstko inne bêdzie mia³o
     jeden element).
    </para>
    <para>
     Je¶li <parameter>zmienna</parameter> nie jest tablic±, to zwracana
     bêdzie warto¶æ <literal>1</literal> (wyj±tek: 
     <literal>count(&null;)</literal> jest równe <literal>0</literal>).
    </para>
    <warning>
     <para>
      <function>count</function> mo¿e zwróciæ 0 dla zmiennej, która nie
      zosta³a zainicjalizowana, ale mo¿ê zwróciæ tak¿e 0 dla zmiennej która
      zosta³a zainicjalizowana pust± tablic±. U¿yj
      <function>isset</function> aby sprawdziæ czy zmienna zosta³a
      ustawiona.
     </para>
    </warning>
    <para>
     Zobacz rozdzia³ podrêcznika 
     <link linkend="language.types.array">Tablice</link> aby dowiedzieæ siê
     jak tablice zosta³y zaimplementowane w PHP.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>count</function></title>
      <programlisting role="php">
      <!-- TODO: examples about count(null), count(false), count(object).. -->
<![CDATA[
$a[0] = 1; 
$a[1] = 3; 
$a[2] = 5; 
$wynik = count ($a);
// $wynik == 3

$b[0] = 7;
$b[5] = 9;
$b[10] = 11;
$wynik = count ($b);
// $wynik == 3;
]]>
      </programlisting>
     </example>
    </para>
   <note>
    <para>
     Funkcja <function>sizeof</function> jest aliasem dla
     <function>count</function>.
    </para>
   </note>
    <para>
     Patrz tak¿e <function>sizeof</function>,
     <function>isset</function> i
     <function>is_array</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.current">
   <refnamediv>
    <refname>current</refname>
    <refpurpose>Zwraca bie¿±cy element tablicy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>current</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Ka¿da tablica ma wewnêtrzny wska¼nik bo swojego "bie¿±cego" elementu,
     który jest inicjalizowany do pierwszego elementu wstawionego do
     tablicy.
    </para>
    <para>
     Funkcja <function>current</function> po prostu zwraca element tablicy,
     na który aktualnie wskazuje wewnêtrzny wska¼nik. Nie przesuwa ona
     wska¼nika. Je¶li wewnêtrzny wska¼nik jest poza koñcem listy elementów, 
     <function>current</function> zwraca &false;.
     <warning>
      <para> 
       Je¶li tablica zawiera puste elementy (0 lub "", czyli pusty string),
       to funkcja zwróci &false; tak¿e dla tych elementów. Przez to nie jest
       mo¿liwe stwierdzenie, czy jeste¶ ju¿ poza tablic±, u¿ywaj±c funkcji
       <function>current</function>. Aby prawid³owo przej¶æ przez tablicê
       która zwiera puste elementy, skorzystaj z funkcji
       <function>each</function>.
      </para>
     </warning>
    </para>
    <para>
     Patrz tak¿e <function>end</function>, <function>next</function>,
     <function>prev</function> i <function>reset</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.each">
   <refnamediv>
    <refname>each</refname> 
    <refpurpose>
     Zwraca bie¿±c± parê klucza i warto¶ci z tablicy i przesuwa kursor tablicy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>each</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Zwraca bie¿±c± parê klucza i warto¶ci z tablicy
     <parameter>tablica</parameter> i przesuwa wewnêtrzny wska¼nik tablicy do
     przodu o jeden element. Para ta jest zwracana jako czteroelementowa
     tablica, z kluczami
     <emphasis>0</emphasis>, <emphasis>1</emphasis>,
     <emphasis>key</emphasis> i
     <emphasis>value</emphasis>. Elementy <emphasis>0</emphasis> i
     <emphasis>key</emphasis> zawieraj± nazwê klucza elementu tablicy, a
     <emphasis>1</emphasis> i <emphasis>value</emphasis> zawieraj± warto¶æ
     elementu tablicy.
    </para>
    <para>
     Je¶li wewnêtrzny wska¼nik tablicy wskazuje na miejsce poza koñcem
     zawarto¶ci tablicy, <function>each</function> zwraca &false;.
    </para>
    <para>
     <example>
      <title>Przyk³ady u¿ycia <function>each</function></title>
      <programlisting role="php">
<![CDATA[
$foo = array ("bob", "fred", "jussi", "jouni", "egon", "marliese");
$bar = each ($foo);
]]>
      </programlisting>
      <para>
       <varname>$bar</varname> zawiera teraz nastêpuj±ce pary klucz/warto¶æ
       <itemizedlist spacing="compact">
        <listitem><simpara>0 =&gt; 0</simpara></listitem>
        <listitem><simpara>1 =&gt; 'bob'</simpara></listitem>
        <listitem><simpara>key =&gt; 0</simpara></listitem>
        <listitem><simpara>value =&gt; 'bob'</simpara></listitem>
       </itemizedlist>
       <programlisting role="php">
<![CDATA[
$foo = array ("Robert" => "Bob", "Seppo" => "Sepi");
$bar = each ($foo);
]]>
       </programlisting>
      </para>
      <para>
       <varname>$bar</varname> zawiera teraz nastêpuj±ce pary klucz/warto¶æ:
       <itemizedlist spacing="compact">
        <listitem><simpara>0 =&gt; 'Robert'</simpara></listitem>
        <listitem><simpara>1 =&gt; 'Bob'</simpara></listitem>
        <listitem><simpara>key =&gt; 'Robert'</simpara></listitem>
        <listitem><simpara>value =&gt; 'Bob'</simpara></listitem>
       </itemizedlist>
      </para>
     </example>
    </para>
    <para>
     <function>each</function> jest zazwyczaj u¿ywana w po³±czeniu z 
     <function>list</function> aby przej¶æ przez tablicê; na przyk³ad
     <varname>$HTTP_POST_VARS</varname>: 
     <example>
      <title>
       Przechodzenie przez <varname>$HTTP_POST_VARS</varname> u¿ywaj±c
       <function>each</function>
      </title>
      <programlisting role="php">
<![CDATA[
echo "Warto¶ci wys³ane metod± POST:<br>";
reset ($HTTP_POST_VARS);
while (list ($key, $val) = each ($HTTP_POST_VARS)) {
    echo "$key => $val<br>";
}
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Po wykonaniu <function>each</function>, wewnêtrzny wska¼nik tablicy
     bêdzie pozostawiony na nastêpnym elementcie tablicy, lub ostatnim
     elemencie je¶li dojdzie ona do koñca tablicy. Musisz u¿yæ
     <function>reset</function> je¶li chcesz przej¶æ przez tablicê jeszcze raz
     korzystaj±c z funkcji each.
    </para>
    <para>
     Patrz tak¿e <function>key</function>, <function>list</function>,
     <function>current</function>, <function>reset</function>,
     <function>next</function> i <function>prev</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.end">
   <refnamediv>
    <refname>end</refname>
    <refpurpose>
     Ustaw wewnêtrzny wska¼nik tablicy na ostatnim elemencie
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>end</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>end</function> przesuwa wewnêtrzny wska¼nik tablicy
     <parameter>tablica</parameter> na ostatnim elemencie i zwraca ten
     element.
    </para>
    <para>
     Patrz tak¿e <function>current</function>,
     <function>each</function>, <function>end</function>,
     <function>next</function> i <function>reset</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.extract">
   <refnamediv>
    <refname>extract</refname>
    <refpurpose>
     Importuj zmienne do tabeli symboli z tablicy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>extract</function></funcdef>
      <paramdef>array <parameter>tablica_zmiennych</parameter></paramdef>
      <paramdef>int 
       <parameter><optional>typ_ekstrakcji</optional></parameter>
      </paramdef>
      <paramdef>string 
       <parameter><optional>prefiks</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Ta funkcja s³u¿y do importowania zmiennych z tablicy do bie¿±cej tabeli
     symboli. Pobiera jako parametr tablicê asocjacyjn±
     <parameter>tablica_zmiennych</parameter> i traktuje klucze jako nazwy
     zmiennych a warto¶ci jako warto¶ci tych zmiennych. Dla ka¿dej pary
     klucz/warto¶æ w bie¿±cej tabeli symboli bêdzie stworzona zmienna, zale¿na
     od parametrów <parameter>typ_ekstrakcji</parameter> i
     <parameter>prefiks</parameter>.
    </para>
    <note>
     <para>
      Od wersji 4.0.5 ta funkcja zwraca liczbê wyekstraktowanych zmiennych.
     </para>
    </note>
    <para>
     <function>extract</function> sprawdza ka¿dy klucz aby sprawdziæ, czy
     zawiera prawid³ow± nazwê zmiennej a tak¿e czy istniej± kolizje z
     zmiennymi istniej±cymi w tablicy symboli. Sposób traktowania z³ych nazw
     zmiennych i kolizji jest okre¶lony przez parametr
     <parameter>typ_ekstrakcji</parameter>. Mo¿e byæ jedn± z poni¿szych
     warto¶ci:
     <variablelist>
      <varlistentry>
       <term>EXTR_OVERWRITE</term>
       <listitem>
        <simpara>
         Je¶li istnieje kolizja, nadpisz istniej±c± zmienn±.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>EXTR_SKIP</term>
       <listitem>
        <simpara>
         Je¶li istnieje kolizja, nie nadpisuj istniej±cej zmiennej.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>EXTR_PREFIX_SAME</term>
       <listitem>
        <simpara>
         Je¶li istnieje kolizja, na pocz±tek nazwy zmiennej wstaw
         <parameter>prefiks</parameter>.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>EXTR_PREFIX_ALL</term>
       <listitem>
        <simpara>
         Na pocz±tek ka¿dej nazwy zmiennej wstaw <parameter>prefiks</parameter>.
         Od PHP 4.0.5 dotyczy to tak¿e nazw numerycznych.
        </simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>EXTR_PREFIX_INVALID</term>
       <listitem>
        <simpara>
         Wstaw <parameter>prefiks</parameter> na pocz±tek z³ych/numerycznych
         nazw. Ta flaga zosta³a dodana w PHP 4.0.5.
        </simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Je¶li <parameter>typ_ekstrakcji</parameter> nie zosta³ podany, to
     zak³adana jest opcja EXTR_OVERWRITE.
    </para>
    <para>
     Zauwa¿, ¿e parametr <parameter>prefiks</parameter> jest wymagany tylko
     je¶li <parameter>typ_ekstrakcji</parameter> to EXTR_PREFIX_SAME,
     EXTR_PREFIX_ALL i EXTR_PREFIX_INVALID. Je¶li nazwa zmiennej po dodaniu
     prefiksa nie jest prawid³ow± nazw± zmiennej, nie jest portowana do
     tablicy symboli.
    </para>
    <para>
     <function>extract</function> zwraca liczbê zmiennych szczê¶liwie
     zaimportowanych do tablicy symboli.
    </para>
    <para>
     Mo¿liwy jest import zmiennych zawartych w tablicy asocjacyjnej zwróconej
     przez <function>wddx_deserialize</function>.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>extract</function></title>
      <programlisting role="php">
<![CDATA[
<?php

/* Za³ó¿my, ¿e $tablica_zmiennych jest tablic± zwrócon± przez 
   wddx_deserialize */

$rozmiar = "du¿y";
$tablica_zmiennych = array ("kolor"    => "niebieski",
                            "rozmiar"  => "¶redni",
                            "ksztalt"  => "kulisty");
extract ($tablica_zmiennych, EXTR_PREFIX_SAME, "wddx");

print "$kolor, $rozmiar, $ksztalt, $wddx_rozmiar\n";

?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Powy¿szy przyk³ad wy¶wietli:
     <programlisting>
<![CDATA[
niebieski, du¿y, kulisty, ¶redni
]]>
     </programlisting>
    </para>
    <para>
     <varname>$rozmiar</varname> nie zosta³ nadpisany, poniewa¿ podany zosta³
     parametr EXTR_PREFIX_SAME, przez co stworzona zosta³ zmienna
     <varname>$wddx_rozmiar</varname>.  Je¶li podana by by³a flaga EXTR_SKIP,
     to zmienna <varname>$wddx_rozmiar</varname> nie zosta³aby stworzona.
     Flaga EXTR_OVERWRITE spowodowa³aby, ¿e zmienna <varname>$rozmiar</varname>
     mia³aby warto¶æ "¶redni", a EXTR_PREFIX_ALL spowodowa³aby ¿e wszystkie
     nowe zmienne zosta³yby nazwane <varname>$wddx_kolor</varname>,
     <varname>$wddx_rozmiar</varname>, and
     <varname>$wddx_ksztalt</varname>.
    </para>
    <para>
     Musisz u¿yæ tablic asocjacyjnych. Tablica indeksowana liczbowo nie da
     ¿adnych efektów.
    </para>
    <para>
     Patrz tak¿e <function>compact</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.in-array">
   <refnamediv>
    <refname>in_array</refname>
    <refpurpose>Zwraca &true; je¶li warto¶æ istnieje w tablicy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>in_array</function></funcdef>
      <paramdef>mixed <parameter>ig³a</parameter></paramdef>
      <paramdef>array <parameter>stóg_siana</parameter></paramdef>
      <paramdef>bool 
       <parameter><optional>¶cis³e</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Przeszukuje <parameter>stóg_siana</parameter> w poszukiwaniu parametru
     <parameter>ig³a</parameter> i zwraca &true; je¶li warto¶æ zosta³a
     znaleziona lub &false; w przeciwnym przypadku.
    </para>
    <para>
     Je¶li trzeci parametr <parameter>¶cis³y</parameter> jest ustawiony na
     &true; to <function>in_array</function> porówna tak¿e 
     <link linkend="language.types">typy</link>
     parametru <parameter>ig³a</parameter> z tymi z parametru
     <parameter>stóg_siana</parameter>.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>in_array</function></title>
      <programlisting role="php">
<![CDATA[
$os = array ("Mac", "NT", "Irix", "Linux");
if (in_array ("Irix", $os)) {
    print "Znaleziono Irix";
}
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>
       Przyk³ad u¿ycia <function>in_array</function> z parametrem strict
      </title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array('1.10', 12.4, 1.13);

if (in_array('12.4', $a, TRUE))
    echo "'12.4' znalezione ze ¶cis³ym sprawdzaniem\n";
if (in_array(1.13, $a, TRUE))
    echo "1.13 znalezione ze ¶cis³ym sprawdzaniem\n";
?>
// Wy¶wietli to:

1.13 znalezione ze ¶cis³ym sprawdzaniem
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Patrz tak¿e <function>array_search</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.array-search">
   <refnamediv>
    <refname>array_search</refname>
    <refpurpose>
     Przeszukuje tablicê pod k±tem podane warto¶ci i w przypadku sukcesu
     zwraca odpowiedni klucz
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title> 
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>array_search</function></funcdef>
      <paramdef>mixed <parameter>ig³a</parameter></paramdef>
      <paramdef>array <parameter>stóg_siana</parameter></paramdef>
      <paramdef>bool <parameter><optional>¶cis³y</optional></parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Przeszukuje <parameter>stóg_siana</parameter> w poszukiwaniu parametru
     <parameter>ig³a</parameter> i zwraca odpowiedni klucz je¶li zosta³ on
     znaleziony lub &false; w przeciwnym przypadku.
    </para>
    <para>
     Je¶li trzeci parametr <parameter>¶cis³y</parameter> jest ustawiony na
     &true; to <function>array_search</function> porówna tak¿e typy
     parametru <parameter>ig³a</parameter> z tymi z parametru
     <parameter>stóg_siana</parameter>.
    </para>
    <para>
     Patrz tak¿e <function>in_array</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.key">
   <refnamediv>
    <refname>key</refname>
    <refpurpose>Pobiera klucz z tablicy asocjacyjnej</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>key</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>key</function> zwraza klucz bie¿±cego elementu z tablicy
     asocjacyjnej.
    </para>
    <para>
     Patrz tak¿e <function>current</function> i <function>next</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.krsort">
   <refnamediv>
    <refname>krsort</refname>
    <refpurpose>Sortuj tablicê wed³ug kluczy w porz±dku odwrotnym</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>krsort</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
      <paramdef>int 
       <parameter><optional>flagi</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Sortuje trablicê wed³ug klucza w porz±dku odwrotnym utrzymuj±c
     skojarzenia kluczy z danymi. Jest to przydatne g³ównie w przypadku
     tablic asocjacyjnych.
     <example>
      <title>Przyk³ad u¿ycia <function>krsort</function></title>
      <programlisting role="php">
<![CDATA[
$owoce = array ("d"=>"cytryna", "a"=>"pomarañcza", "b"=>"banan", "c"=>"jab³ko");
krsort ($owoce);
reset ($owoce);
while (list ($key, $val) = each ($owoce)) {
    echo "$key = $val\n";
}
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Ten przyk³ad wy¶wietli:
    </para>
    <para>
     <informalexample>
      <programlisting>
<![CDATA[
d = cytryna
c = jab³ko
b = banan
a = pomarañcza
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Mo¿esz zmodyfikowaæ zachowanie sortowania przez u¿ycie opcjonalnego
     parametru <parameter>flagi</parameter>. Aby uzyskaæ szczegó³y zobacz
     <function>sort</function>.
    </para>
    <simpara>
     Patrz tak¿e <function>asort</function>, <function>arsort</function>,
     <function>ksort</function> <function>sort</function>, 
     <function>natsort</function> i <function>rsort</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.ksort">
   <refnamediv>
    <refname>ksort</refname>
    <refpurpose>Sortuj tablicê wed³ug klucza</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>ksort</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
      <paramdef>int 
       <parameter><optional>flagi</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Sortuje tablicê wed³ug klucza zachowuj±c skojarzenia kluczy z danymi.
     Jest to przydatne g³ównie w przypadku tablic asocjacyjnych.
     <example>
      <title>Przyk³ad u¿ycia <function>ksort</function></title>
      <programlisting role="php">
<![CDATA[
$owoce = array ("d"=>"cytryna", "a"=>"pomarañcza", "b"=>"banan", "c"=>"jab³ko");
ksort ($owoce);
reset ($owoce);
while (list ($key, $val) = each ($owoce)) {
    echo "$key = $val\n";
}
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Ten przyk³ad wy¶wietli:
    </para>
    <para>
     <informalexample>
      <programlisting>
<![CDATA[
a = pomarañcza
b = banan
c = jab³ko
d = cytryna
]]>
      </programlisting>
     </informalexample>     
    </para>
    <para>
     Mo¿esz zmodyfikowaæ zachowanie sortowania przez u¿ycie opcjonalnego
     parametru <parameter>flagi</parameter>. Aby uzyskaæ szczegó³y zobacz
     <function>sort</function>.
    </para>
    <simpara>
     Patrz tak¿e <function>asort</function>, <function>arsort</function>, 
     <function>sort</function>, <function>natsort</function> i
     <function>rsort</function>.
    </simpara>
    <note>
     <para>
      Drugi parametr zosta³ dodany w PHP 4.
     </para>
    </note>
   </refsect1>
  </refentry>

  <refentry id="function.list">
   <refnamediv>
    <refname>list</refname>
    <refpurpose>
     Przypisz zmienne tak jakby by³y tablic±
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>list</function></funcdef>
      <varargs/>
     </funcprototype>
    </funcsynopsis>
    <para>
     Podobna do <function>array</function>, ale to nie jest na prawdê funkcja,
     ale sk³adnia jêzyka. Instrukcja <function>list</function> jest u¿ywana do
     przypisywania listy zmiennych w jednej operacji.
     <example>
      <title>Przyk³ad u¿ycia <function>list</function></title>
      <programlisting role="php">
<![CDATA[
<table>
 <tr>
  <th>Nazwisko pracownika</th>
  <th>Pensja</th>
 </tr>

<?php

$wynik = mysql_query ($conn, "SELECT id, nazwisko, pensja FROM pracownicy");
while (list ($id, $nazwisko, $pensja) = mysql_fetch_row ($wynik)) {
   print (" <tr>\n".
          "  <td><a href=\"info.php3?id=$id\">$nazwisko</a></td>\n".
          "  <td>$pensja</td>\n".
          " </tr>\n");
}

?>

</table>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Patrz tak¿e <function>each</function> i <function>array</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.natsort">
   <refnamediv>
    <refname>natsort</refname>
    <refpurpose>
     Sortuj tablicê u¿ywaj±c algortmu "porz±dek naturalny"
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>natsort</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Funkcja ta implementuje algorytm sortowania, który sortuje stringi
     alfanumeryczne tak, jak posortowa³by je cz³owiek. Jest on okre¶lany jako
     "porz±dkowanie naturalne". Przyk³ad ró¿nicy miêdzy tym algorytmem a
     zwyk³ymi komputerowymi algorytmami sortowania stringów (u¿ywanymi w
     funkcji <function>sort</function>) mo¿na zobaczyæ poni¿ej:
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>natsort</function></title>
      <programlisting role="php">
<![CDATA[
$tablica1 = $tablica2 = array ("img12.png", "img10.png", "img2.png", "img1.png");
 
sort($tablica1);
echo "Standardowe sortowanie\n";
print_r($tablica1);

natsort($tablica2);
echo "\nSortowanie w porz±dku naturalnym\n";
print_r($tablica2);
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Powy¿szy kod wy¶wietlni nastêpuj±ce dane:
    </para>
    <para>
     <informalexample>
      <programlisting>
<![CDATA[
Standardowe sortowanie
Array
(
    [0] => img1.png
    [1] => img10.png
    [2] => img12.png
    [3] => img2.png
)

Sortowanie w porz±dku naturalnym
Array
(
    [3] => img1.png
    [2] => img2.png
    [1] => img10.png
    [0] => img12.png
)
]]>
      </programlisting>
     </informalexample>
     Aby uzyskaæ wiêcej informacji zobacz stronê Martina Poola <ulink
     url="&url.strnatcmp;">Natural Order String Comparison</ulink>.
    </para>
    <para>
     Patrz tak¿e <function>natcasesort</function>,
     <function>strnatcmp</function> i
     <function>strnatcasecmp</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.natcasesort">
   <refnamediv>
    <refname>natcasesort</refname>
    <refpurpose>
     Sortuj tablicê u¿ywaj±c algorytmu "porz±dek naturalny" ignoruj±cego
     wielko¶æ znaków
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>natcasesort</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Ta funkcja implementuje algorytm sortowania który porz±dkuje stringi
     alfanumeryczne tak, jak zrobi³by to cz³owiek. Jest on okre¶lany jako
     "porz±dkowanie naturalne".
    </para>
    <para>
     <function>natcasesort</function> jest wersj± funkcji
     <function>natsort</function> ignoruj±c± wielko¶æ znaków. Zobacz
     <function>natsort</function> aby zobaczyæ ró¿nicê miêdzy tym algorytmem a
     zwyk³ymi komputerowymi algorytmami sortowania stringów.
    </para>
    <para>
     Aby uzyskaæ wiêcej informacji zobacz stronê Martina Poola <ulink
     url="&url.strnatcmp;">Natural Order String Comparison</ulink>.
    </para>
    <para>
     Patrz tak¿e <function>sort</function>,
     <function>natsort</function>,
     <function>strnatcmp</function> i
     <function>strnatcasecmp</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.next">
   <refnamediv>
    <refname>next</refname>
    <refpurpose>
     Przesuñ do przodu wewnêtrzny wska¼nik tablicy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>next</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Przesuwa wewnêtrzny wska¼nik tablicy i jedn± pozycjê do przodu i zwraca
     element tablicy aktualnie wskazywany przez wska¼nik, lub &false; je¶li
     nie ma ju¿ wiêcej elementów.
    </para>
    <para>
     <function>next</function> zachowuje siê jak
     <function>current</function>, ale z jedn± ró¿nic±. Przesuwa wewnêtrzny
     wska¼nik tablicy o jeden element do przodu przed zwróceniem elementu.
     Oznacza to, ¿e zwraca nastêpny element tablicy i przesuwa wewnêtrzny
     wska¼nik tablicy o jeden element do przodu. Je¶li przesuniêcie
     wewnêtrznego wska¼nika tablicy powoduje przesuniêcie poza koniec listy
     elementów, <function>next</function> zwraca &false;.
     <warning>
      <para>
       Je¶li tablica zawiera puste elementy lub elementy które maj± klucze o
       warto¶ci 0, to funkcja zwróci &false; tak¿e dla tych elementów. Aby
       prawid³owo przej¶æ przez tablice które mog± zawieraæ puste elementy lub
       elementy o warto¶ciach kluczy 0, musisz u¿yæ funkcji
       <function>each</function>.
      </para>
     </warning>
    </para>
    <para>
     Patrz tak¿e <function>current</function>, <function>end</function>,
     <function>prev</function> i <function>reset</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.pos">
   <refnamediv>
    <refname>pos</refname>
    <refpurpose>Pobierz bie¿±cy element z tablicy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>pos</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <simpara>
     Jest to alias dla funkcji <function>current</function>.
    </simpara>
    <para>
     Patrz tak¿e <function>end</function>, <function>next</function>,
     <function>prev</function> and <function>reset</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.prev">
   <refnamediv>
    <refname>prev</refname>
    <refpurpose>Cofnij wewnêtrzny wska¼nik tablicy</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>prev</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Zwraca element tablicy z miejsca poprzedniego od tego na które wskazywa³
     wewnêtrzny wska¼nik pliku, lub &false; je¶li nie ma ju¿ wiêcej elementów.
     <warning>
      <para>
       Je¶li tablica zawiera puste elementy, to bêdzie zwracaæ &false; tak¿e
       dla tych elementów. Aby prawid³owo przej¶æ przez tablicê, która mo¿e
       zawieraæ puste elementy, u¿yj funkcji <function>each</function>.
      </para>
     </warning>
    </para>
    <para>  
     <function>prev</function> zachowuje siê tak jak
     <function>next</function>, z tym ¿e cofa wewnêtrzny wska¼nik tablicy o
     jeden element do ty³u, zamiast przesuwaæ go do przodu.
    </para>
    <para>
     Patrz tak¿e <function>current</function>, <function>end</function>,
     <function>next</function> i <function>reset</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.range">
   <refnamediv>
    <refname>range</refname>
    <refpurpose>
     Stwórz tablicê zawieraj±c± przedzia³ elementów
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>range</function></funcdef>
      <paramdef>mixed <parameter>dolny</parameter></paramdef>
      <paramdef>mixed <parameter>górny</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>range</function> zwraca tablicê elementów od
     <parameter>dolny</parameter> do <parameter>górny</parameter>, w³±cznie.
     Je¶li dolny > górny, to sekwencja bêdzie od górnego do dolnego.
     <example>
      <title>Przyk³ady u¿ycia <function>range</function></title>
      <programlisting role="php">
<![CDATA[
foreach(range(0, 9) as $liczba) {
    echo $liczba;
}
foreach(range('a', 'z') as $litera) {
    echo $litera;
}
foreach(range('z', 'a') as $litera) {
    echo $litera;
}
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      Do wersji 4.1.0, funkcja <function>range</function> generowa³a tylko
      rosn±ce tablice liczbowe. Obs³uga dla sekwencji znakowych i tablic
      malej±cych zosta³a dodana w 4.1.0.
     </para>
    </note>
    <para>
     Patrz tak¿e <function>shuffle</function> aby zobaczyæ inny przyk³ad
     wykorzystania tej funkcji.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.reset">
   <refnamediv>
    <refname>reset</refname>
    <refpurpose>
     Ustaw wewnêtrzny wska¼nik tablicy na jej pierwszy element
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>reset</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>reset</function> przewija wewnêtrzny wska¼nik tablicy parametru
     <parameter>tablica</parameter> na jego pierwszy element.
    </para>
    <para>
     <function>reset</function> zwraca warto¶æ pierwszego elementu tablicy.
    </para>
    <para>
     Patrz tak¿e <function>current</function>,
     <function>each</function>, <function>next</function> i
     <function>prev</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.rsort">
   <refnamediv>
    <refname>rsort</refname>
    <refpurpose>Sortuj tablicê w porz±dku odwrotnym</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>rsort</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
      <paramdef>int 
       <parameter><optional>flagi</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Ta funkcja sortuje tablicê w porz±dku odwrotnym (od najwiêkszego do
     najmniejszego).
     <example>
      <title>Przyk³ad u¿ycia <function>rsort</function></title>
      <programlisting role="php">
<![CDATA[
$owoce = array ("cytryna", "pomarañcza", "banan", "jab³ko");
rsort ($owoce);
reset ($owoce);
while (list ($key, $val) = each ($owoce)) {
    echo "$key = $val\n";
}
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Ten przyk³ad wy¶wietli:
    </para>
    <para>
     <informalexample>
      <programlisting>
<![CDATA[
0 = pomarañcza
1 = cytryna
2 = banan
3 = jab³ko
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Owoce zosta³y posortowane w odwrotnym porz±dku alfabetycznym.
    </para>
    <para>
     Mo¿esz zmodyfikowaæ zachowanie sortowania przez u¿ycie opcjonalnego
     parametru <parameter>flagi</parameter>. Aby uzyskaæ szczegó³y zobacz
     <function>sort</function>.
    </para>
    <para>
     Patrz tak¿e <function>arsort</function>,
     <function>asort</function>, <function>ksort</function>,
     <function>sort</function> i <function>usort</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.shuffle">
   <refnamediv>
    <refname>shuffle</refname>
    <refpurpose>Przetasuj tablicê</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>shuffle</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Ta funkcja tasuje tablicê (losuje kolejno¶æ elementów w niej). Musisz
     u¿yæ <function>srand</function> aby przygotowaæ ziarno dla tej funkcji.
     <example>
      <title>Przyk³ad u¿ycia <function>shuffle</function></title>
      <programlisting role="php">
<![CDATA[
$liczby = range (1,20);
srand ((float)microtime()*1000000);
shuffle ($liczby);
while (list (, $liczba) = each ($liczby)) {
    echo "$liczba ";
}
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Patrz tak¿e <function>arsort</function>, <function>asort</function>,
     <function>ksort</function>, <function>rsort</function>,
     <function>sort</function> i <function>usort</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.sizeof">
   <refnamediv>
    <refname>sizeof</refname>
    <refpurpose>Policz ilo¶æ elementów w zmiennej</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>sizeof</function></funcdef>
      <paramdef>mixed <parameter>zmienna</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Funkcja <function>sizeof</function> jest aliasem funkcji
     <function>count</function>.
    </para>
    <para>
     Patrz tak¿e <function>count</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.sort">
   <refnamediv>
    <refname>sort</refname>
    <refpurpose>Sortuj tablicê</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>sort</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
      <paramdef>int 
       <parameter><optional>flagi</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Funkcja ta sortuje tablicê. Po zakoñczeniu dzia³ania funkcji
     elementy bêd± u³o¿one od najmniejszego do najwiekszego.
     <example>
      <title>Przyk³ad u¿ycia <function>sort</function></title>
      <programlisting role="php">
<![CDATA[
<?php

$owoce = array ("cytryna", "pomarañca", "banan", "jab³ko");
sort ($owoce);
reset ($owoce);
while (list ($key, $val) = each ($owoce)) {
    echo "owoce[".$key."] = ".$val."\n";
}
]]>
?>
      </programlisting>
     </example>
    </para>
    <para>
     Ten przyk³ad wy¶wietli:
    </para>
    <para>
     <informalexample>
      <programlisting>
<![CDATA[
owoce[0] = banan
owoce[1] = cytryna
owoce[2] = jab³ko
owoce[3] = pomarañcza
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Owoce zosta³y posortowane w porz±dku alfabetycznym.
    </para>
    <para>
     Opcjonalny drugi parametr <parameter>flagi</parameter> mo¿e byæ u¿yty do
     zmiany zachowania sortowania przy pomocy tych warto¶ci:
    </para>
    <para>
     Flagi typu sortowania:
     <itemizedlist>
      <listitem>
       <simpara>SORT_REGULAR - porównuj elementy normalnie</simpara>
      </listitem>
      <listitem>
       <simpara>SORT_NUMERIC - porównuj elementy jako liczby</simpara>
      </listitem>
      <listitem>
       <simpara>SORT_STRING - porównuj elementy jako stringi</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Patrz tak¿e <function>arsort</function>,
     <function>asort</function>, <function>ksort</function>,
     <function>natsort</function>, <function>natcasesort</function>,
     <function>rsort</function>, <function>usort</function>,
     <function>array_multisort</function> i
     <function>uksort</function>.
    </para>
    <note>
     <para>
      Drugi parametr zosta³ dodany w PHP 4.
     </para>
    </note>
   </refsect1>
  </refentry>

  <refentry id="function.uasort">
   <refnamediv>
    <refname>uasort</refname>
    <refpurpose>
     Sortuj tablicê korzystaj±c ze zdefiniowanej przez u¿ytkownika funkcji
     porównuj±cej i zachowuj±c skojarzenia kluczy
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>uasort</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
      <paramdef>function <parameter>funkcja_por</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Funkcja ta sortuje tablicê w taki sposób, ¿e klucze zachowuj± przypisanie
     do odpowiednich warto¶ci. Jest to u¿ywane g³ównie przy sortowaniu tablic
     asocjacyjnych, gdzie znacz±ca jest kolejno¶æ elementów. Funkcja
     porównuj±ca jest zdefiniowana przez u¿ytkowanika.
    </para>
    <note>
     <para>
      Zobacz <function>usort</function> i <function>uksort</function> aby
      zobaczyæ przyk³ady zdefiniowanych przez u¿ytkownika funkcji
      porównuj±cych.
     </para>
    </note>
    <para>
     Patrz tak¿e <function>usort</function>, <function>uksort</function>, 
     <function>sort</function>, <function>asort</function>, 
     <function>arsort</function>, <function>ksort</function> i
     <function>rsort</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.uksort">
   <refnamediv>
    <refname>uksort</refname>
    <refpurpose>
     Sortuj tablicê wed³ug kluczy korzystaj±c ze zdefiniowanej przez
     u¿ytkownika funcji porównuj±cej
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>uksort</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
      <paramdef>function <parameter>funkcja_por</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Funkcja ta posortuje tablicê wed³u kluczy korzystaj±c z podanej przez
     u¿ytkownika funkcji porównuj±cej. Je¶li chcesz posortowaæ tablicê wed³ug
     skomplikowanych kryteriów, to powiniene¶ u¿yæ tej funkcji.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>uksort</function></title>
      <programlisting role="php">
<![CDATA[
function cmp ($a, $b) {   
    if ($a == $b) return 0;
    return ($a > $b) ? -1 : 1;
}

$a = array (4 => "cztery", 3 => "trzy", 20 => "dwadzie¶cia", 10 => "dziesiêæ");

uksort ($a, "cmp");

while (list ($key, $value) = each ($a)) {
    echo "$key: $value\n";
}
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Ten przyk³ad wy¶wietli:
    </para>
    <para>
     <informalexample>
      <programlisting>
<![CDATA[
20: dwadzie¶cia
10: dziesiêæ
4: cztery
3: trzy
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Patrz tak¿e <function>usort</function>, <function>uasort</function>, 
     <function>sort</function>, <function>asort</function>, 
     <function>arsort</function>, <function>ksort</function>,
     <function>natsort</function> i <function>rsort</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.usort">
   <refnamediv>
    <refname>usort</refname>
    <refpurpose>
     Sortuj tablicê wed³ug warto¶ci korzystaj±c ze zdefiniowanej przez
     u¿ytkownika funkcji porównuj±cej
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Opis</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>usort</function></funcdef>
      <paramdef>array <parameter>tablica</parameter></paramdef>
      <paramdef>string <parameter>funkcja_por</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     Funkcja ta posortuje tablicê wed³ug jej warto¶ci korzystaj±c z podanej
     przez u¿ytkownika funkcji porównuj±cej. Je¶li chcesz posortowaæ tablicê
     wed³ug skomplikowanych kryteriów, to powiniene¶ u¿yæ tej funkcji.
    </para>
    <para>
     Funkcja porównuj±ca musi zwracaæ liczbê ca³kowit± mniejsz±, równ± lub
     wiêksz± od zera je¶li pierwszy argument jest odpowiednio mniejszy, równy
     lub wiêkszy ni¿ drugi. Je¶li dwa elementy tablicy s± równe, to ich
     kolejno¶æ wystêpowania w posortowanej tablicy pozostaje niezdefiniowany.
    </para>
    <para>
     Istenieje tak¿e mo¿liwo¶æ u¿ycia funkcji sk³adowej obiektu jako funkcji
     porównuj±cej. Zobacz przyk³ad nr 3 poni¿ej.
    </para>
    <para>
     <example>
      <title>Przyk³ad u¿ycia <function>usort</function></title>
      <programlisting role="php">
<![CDATA[
function cmp ($a, $b) {   
    if ($a == $b) return 0;
    return ($a > $b) ? -1 : 1;
}

$a = array (3, 2, 5, 6, 1);

usort ($a, "cmp");

while (list ($key, $value) = each ($a)) {
    echo "$key: $value\n";
}
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Powy¿szy przyk³ad wy¶wietli:
    </para>
    <para>
     <informalexample>
      <programlisting>
<![CDATA[
0: 6
1: 5
2: 3
3: 2
4: 1
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      Oczywi¶cie w prostszych przypadkach lepiej jest skorzystaæ z funkcji
      <function>rsort</function>.
     </para>
    </note>
    <para>
     <example>
      <title>
       Przyk³ad u¿ycia <function>usort</function> do sortowania
       wielowymiarowych tablic
      </title>
      <programlisting role="php">
<![CDATA[
function cmp ($a, $b) {
    return strcmp($a["owoc"], $b["owoc"]);
} 

$owocs[0]["owoc"] = "cytryny";
$owocs[1]["owoc"] = "jab³ka";
$owocs[2]["owoc"] = "winogrona";

usort($owocs, "cmp"); 

while (list ($key, $value) = each ($owocs)) {
    echo "\$owocs[$key]: " . $value["owoc"] . "\n";
}
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Sortuj±c tablicê wielowymiarow±, $a i $b zawieraj± referencjê do
     pierwszego indeksu tablicy.
    </para>
    <para>
     Ten przyk³ad wy¶wietli:
    </para>
    <para>
     <informalexample>
      <programlisting>
<![CDATA[
$fruits[0]: cytryny
$fruits[1]: jab³ka
$fruits[2]: winogrona
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     <example>
      <title>
       Przyk³ad u¿ycia <function>usort</function> u¿ywaj±c funkcji sk³adowej
       obiektu
      </title>
      <programlisting role="php">
<![CDATA[
class TestObj {
    var $name;
     
    function TestObj($name)
    {
        $this->name = $name;
    }
    
    /* Statyczna funkcja porównuj±ca */
    function cmp_obj($a, $b) 
    {
        $al = strtolower($a->name);
        $bl = strtolower($b->name);
        if ($al == $bl) return 0;
        return ($al > $bl) ? +1 : -1;
    }
}

$a[] = new TestObj("c");
$a[] = new TestObj("b");
$a[] = new TestObj("d");

uasort($a, array ("TestObj", "cmp_obj"));

foreach ($a as $item) {
    print $item->name."\n";
}
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Ten przyk³ad wy¶wietli:
    </para>
    <para>
     <informalexample>
      <programlisting>
<![CDATA[
b
c
d
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     <warning>
      <para>
       U¿ywana do sortowania funkcja quicksort w niektórych bibliotekach C
       (jak na przyk³ad na systemach Solaris) mo¿e spowodowaæ zawieszanie siê
       PHP je¶li funkcja porównuj±ca zwraca niespójne warto¶ci.
      </para>
     </warning>
    </para>
    <para>
     Patrz tak¿e <function>uasort</function>,
     <function>uksort</function>, <function>sort</function>,
     <function>asort</function>,
     <function>arsort</function>,<function>ksort</function>,
     <function>natsort</function> i <function>rsort</function>.
    </para>
   </refsect1>
  </refentry>

 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
