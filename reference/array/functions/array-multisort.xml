<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: 1.18 Maintainer: leszek Status: ready -->
<!-- $Revision: 1.6 $ -->
<refentry id="function.array-multisort">
 <refnamediv>
  <refname>array_multisort</refname>
  <refpurpose>Sortuje wiele tablic lub wielowymiarowe tablice</refpurpose>
 </refnamediv>
 <refsect1>
  <title>Opis</title>
  <methodsynopsis>
   <type>bool</type><methodname>array_multisort</methodname>
   <methodparam><type>array</type><parameter>tbl1</parameter></methodparam>
   <methodparam choice="opt"><type>mixed</type><parameter>arg</parameter></methodparam>
   <methodparam choice="opt"><type>mixed</type><parameter>...</parameter></methodparam>
   <methodparam choice="opt"><type>array</type><parameter>...</parameter></methodparam>
   <!-- Parameters don't need to be passed by reference -->
  </methodsynopsis>
  <para>
   &return.success;
  </para>
  <para>
   <function>array_multisort</function> mo¿e byæ u¿yta do sortowania kilku
   tablic na raz lub wielowymiarowej tablicy na podstawie jednego z wiêkszej
   liczby wymiarów.
  </para>
  <para>
   Klucze asocjacyjne s± zachowywane, a indeksy numeryczne s±
   przenumerowywane.
  </para>
  <para>
   Tablice wej¶ciowe s± traktowane jak kolumy tablicy, które maj± byæ
   posortowane wierszami - odpowiada to funkcjonalno¶ci warunku SQL ORDER
   BY. Pierwsza tablica jest tablic± priorytetow± do sortowania. Wiersze
   (warto¶ci) w tej tablic± które s± takie sane sortowane s± wed³ug
   nastêpnej tablicy wej¶ciowej i tak dalej.
  </para>
  <para>
   Struktura argumentów tej funkcji nie jest zwyczajna, ale jest ona
   elastyczna. Pierwszy argument musi byæ tablic±. Ka¿dy nastêpny argument
   musi byæ tablic± lub flag± oznaczaj±c± porz±dek sortowania - jeden z
   poni¿szych.
  </para>
  <para>
   Flagi porz±dku sortowania:
   <itemizedlist>
    <listitem>
     <simpara><constant>SORT_ASC</constant> - sortuj w porz±dku rosn±cym</simpara>
    </listitem>
    <listitem>
     <simpara><constant>SORT_DESC</constant> - sortuj w porz±dku malej±cym</simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Flagi typu sortowania:
   <itemizedlist>
    <listitem>
     <simpara><constant>SORT_REGULAR</constant> - porównuj elementy normalnie</simpara>
    </listitem>
    <listitem>
     <simpara><constant>SORT_NUMERIC</constant> - porównuj elementy numerycznie</simpara>
    </listitem>
    <listitem>
     <simpara><constant>SORT_STRING</constant> - porówuj elementy jak stringi</simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Nie mo¿na podaæ ¿adnych dwóch flag tego samego typu dla jednej tablicy.
   Flagi sortowania podane po argumencie-tablicy dotycz± tylko tej tablicy
   - s± one zerowane do domy¶lnych warto¶æi <constant>SORT_ASC</constant> i
   <constant>SORT_REGULAR</constant> po ka¿dym argumencie tablicowym.
  </para>
  <para>
   &return.success;
  </para>
  <para>
   <example>
    <title>Sortowanie wielu tablic</title>
    <programlisting role="php">
<![CDATA[
<?php
$tbl1 = array ("10", 100, 100, "a");
$tbl2 = array (1, 3, "2", 1);
array_multisort ($tbl1, $tbl2);

var_dump($tbl1);
var_dump($tbl2);
?>
]]>
    </programlisting>
    <para>
     W tym przypadku, po sortowaniu, pierwsza tablica bêdzie zawieraæ 10,
     "a", 100, 100, a druga 1, 1, "2", 3. Elementy drugiej tablicy
     odpowiadaj±ce identycznym elementom pierwszej tablicy (100 i 100) tak¿e
     zosta³y posortowane.
    </para>
    <screen>
<![CDATA[
array(4) {
  [0]=> string(2) "10"
  [1]=> string(1) "a"
  [2]=> int(100)
  [3]=> int(100)
}
array(4) {
  [0]=> int(1)
  [1]=> int(1)
  [2]=> string(1) "2"
  [3]=> int(3)
}
]]>
    </screen>
   </example>
  </para>
  <para>
   <example>
    <title>Sortowanie wielowymiarowych tablic</title>
    <programlisting role="php">
<![CDATA[
$tbl = array (
      array ("10", 100, 100, "a"),
      array (1, 3, "2", 1)
   );
array_multisort ($tbl[0], SORT_ASC, SORT_STRING,
         $tbl[1], SORT_NUMERIC, SORT_DESC);
var_dump($tbl);
?>
]]>
    </programlisting>
    <para>
     W tym przyk³adzie, po posortowaniu, pierwsza tablica przekszta³ci siê
     do postaci "10", 100, 100, 11, "a" (zosta³a posortowana jako ci±gi
     znakowe w porz±dku rosn±cym). Druga tablica bêdzie zawiera³a elementy
     1, 3, "2", 2, 1 (sortowanie liczbowe w porz±dku malej±cym).
    </para>
    <screen>
<![CDATA[
array(2) {
  [0]=> array(5) {
    [0]=> string(2) "10"
    [1]=> int(100)
    [2]=> int(100)
    [3]=> int(11)
    [4]=> string(1) "a"
  }
  [1]=> array(5) {
    [0]=> int(1)
    [1]=> int(3)
    [2]=> string(1) "2"
    [3]=> int(2)
    [4]=> int(1)
  }
}
]]>
    </screen>
   </example>
  </para>

  <para>
   <example>
    <title>Sortowanie wyników zapytañ do baz danych</title>
    <para>
     Dla tego przyk³adu, ka¿dy element tablicy <varname>dane</varname>
     reprezentuje pojedynczy wiersz z tabeli. Ten typ danych jest typowy dla
     rekordów baz danych.
    </para>
    <para>
     Przyk³adowe dane:
    </para>
    <screen>
<![CDATA[
Numer | edycja
-------+--------
   67 |      2
   86 |      1
   85 |      6
   98 |      2
   86 |      6
   67 |      7
]]>
    </screen>
    <para>
     Dane zawarte s± w tablicy o nazwie <varname>dane</varname>. Efekt ten
     mo¿na uzyskaæ, na przyk³ad, poprzez wywo³uj±c w pêtli funkcjê
     <function>mysql_fetch_assoc</function>.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$dane[] = array('numer' => 67, 'edycja' => 2);
$dane[] = array('numer' => 86, 'edycja' => 1);
$dane[] = array('numer' => 85, 'edycja' => 6);
$dane[] = array('numer' => 98, 'edycja' => 2);
$dane[] = array('numer' => 86, 'edycja' => 6);
$dane[] = array('numer' => 67, 'edycja' => 7);
?>
]]>
    </programlisting>
    <para>
     W tym przyk³adzie, dane zostan± posortowane wed³ug pola
     <varname>numer</varname> malej±co, oraz wzglêdem pola
     <varname>edycja</varname> rosn±co.
    </para>
    <para>
     W zmiennej znajduje siê tablica wierszy, lecz
     <function>array_multisort</function> wymaga tablicy kolumn, tak wiêc
     nale¿y zastosowaæ poni¿szy kod aby uzyskaæ kolumny, a nastêpnie
     przeprowadziæ sortowanie.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
// Pobierz listê kolumn
foreach ($dane as $klucz => $wiersz) {
    $numer[$klucz]  = $wiersz['numer'];
    $edycja[$klucz] = $wiersz['edycja'];
}

// Posortuj dane wed³ug numeru malej±co i edycji rosn±co
// Nale¿y podaæ $dane jako ostatni parametr aby posortowaæ wed³ug wspólnego
// klucza
array_multisort($numer, SORT_DESC, $edycja, SORT_ASC, $dane);
?>
]]>
    </programlisting>
    <para>
     Zbiór danych jest teraz posortowany. Wygl±da on tak:
    </para>
    <screen>
<![CDATA[
numer | edycja
------+--------
   98 |      2
   86 |      1
   86 |      6
   85 |      6
   67 |      2
   67 |      7
]]>
    </screen>
   </example>
  </para>
  <para>
   <example>
    <title>Sortowanie z ignorowaniem wielko¶ci znaków</title>
    <para>
     Obie opcje, <constant>SORT_STRING</constant> i
     <constant>SORT_REGULAR</constant>, powoduj± sortowanie z rozró¿nianiem
     wielko¶ci znaków. Ci±gi zaczynaj±ce siê od du¿ej litery stan± siê
     ci±gami zaczynaj±cymi siê od litery ma³ej.
    </para>
    <para>
     Aby przeprowadziæ sortowanie ignoruj±ce wielko¶æ znaków, nale¿y
     wymusiæ, aby porz±dek sortowania by³ okre¶lany przez kopiê oryginalnej
     tablicy, w której wszystkie znaki zostan± zmienione na ma³e.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$tablica = array('Alfa', 'atomowy', 'Beta', 'bank');
$tablica_male = array_map('strtolower', $tablica);

array_multisort($tablica_male, SORT_ASC, SORT_STRING, $tablica);

print_r($tablica);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Array
(
    [0] => Alfa
    [1] => atomowy
    [2] => bank
    [3] => Beta
)
]]>
    </screen>
   </example>
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
