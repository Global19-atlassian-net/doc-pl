<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: 1.57 Maintainer: leszek Status: ready -->
<!-- $Revision: 1.9 $ -->
 <reference xml:id="ref.session" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Sesje</title>
  <titleabbrev>Sesje</titleabbrev>

  <partintro>
   <section xml:id="session.intro">
    &reftitle.intro;
    <para>
     Obs³uga sesji w PHP ma na celu zapewnienie sposobu na zachowanie pewnych
     danych w trakcie nastêpuj±cych po sobie wywo³añ strony. Pozwala to na
     budowanie bardziej spersonalizowanych aplikacji i zwiêkszenie
     atrakcyjno¶ci twojej strony internetowej.
    </para>
    <para>
     Go¶æ wchodz±cy na twoj± stronê WWW otrzymuje unikalny identyfikator, tzw.
     id sesji. Jest ono przechowywane albo jako ciasteczko po stronie
     u¿ytkownika lub propagowane w URL'u.
    </para>
    <para>
     Obs³uga sesji pozwala ci na rejestrowanie dowolnej ilo¶ci zmiennych, które
     maj± byæ przekazywane pomiêdzy stronami. Kiedy go¶æ wchodzi na twoj±
     strone, PHP automatycznie sprawdzi (je¶li <link
      linkend="ini.session.auto-start">session.auto_start</link> jest ustawione
     na 1) lub na twoje ¿yczenie (jawnie przez wywo³anie
     <function>session_start</function> lub niejawnie przez wywo³anie
     <function>session_register</function>) czy specyficzne id sesji zosta³o
     przypisane. Je¶li tak, poprzednio zachowane ¶rodowisko jest odtwarzane.
    </para>
    <caution>
     <para>
      Po w³±czeniu dyrektywy
      <link linkend="ini.session.auto-start">session.auto_start</link> nie
      jest mo¿liwe dodawanie obiektów do sesji. Dzieje siê tak, poniewa¿
      definicje klas musz± byæ za³adowane przed rozpoczêciem sesji aby
      mo¿liwe by³o odtworzenie obiektów zawartych w sesji.
     </para>
    </caution>
    <para>
     Wszystkie zarejestrowane zmienne s± serializowane po wykonaniu ca³ego kodu
     strony. Zarejestrowane zmienne, które s± niezdefiniowane, s± zaznaczane
     jako niezdefiniowane. Nie s± one definiowane przez modu³ sesji w
     nastêpuj±cych po sobie wywo³aniach, chyba ¿e u¿ytkownik zdefiniuje je
     pó¼niej.
    </para>
    <warning>
     <para>
      Niektóre typy danych nie mog± byæ serializowane, a w zwi±zku z tym
      przechowywane w sesjach. Do typów takich nale¿± zasoby
      (<type>resource</type>) lub obiekty z zapêtlonymi referencjami (np.
      obiekty, które przekazuj± referencje do siebie do innego obiektu).
     </para>
    </warning>
    <note>
     <para>
      Obs³uga sesji zosta³a dodana w PHP 4.0.
     </para>
    </note>
    <note>
     <para>
      Nale¿y zauwa¿yæ, ¿e zapis sesji nie jest tworzony dopóki nie zostanie w
      niej zarejestrowana zmienna poprzez funkcjê
      <function>session_register</function> lub przez dodanie klucza do tablicy
      superglobalnej <varname>$_SESSION</varname>. Dzieje siê tak nawet pomimo
      faktu rozpoczêcia sesji poprzez wywo³anie funkcji
      <function>session_start</function>.
     </para>
    </note>
   </section>
   <section xml:id="session.security">
    <title>Bezpieczeñstwo sesji</title>
    <para>
     Odno¶nik zewnêtrzny: <link xlink:href="&url.session-fixation;">Session
      fixation</link>
    </para>
    <para>
     Modu³ sesji nie mo¿e zagwarantowaæ, ¿e informacje, które s± przechowywane
     w sesji, mog± byæ przegl±dane tylko przez u¿ytkownika, który stworzy³ t±
     sesjê. Niezbêdne jest przedsiêwziêcie dodatkowych dzia³añ aby ochroniæ
     spójno¶æ sesji, zale¿nie od warto¶ci do niej przypisanych.
    </para>
    <para>
     Nale¿y oceniæ warto¶æ danych przechowywanych w sesjach i zastosowaæ
     dodatkowe zabezpieczenia - dzia³ania takie s± zazwyczaj powi±zane ze
     zmniejszeniem wygody u¿ytkowników. Na przyk³ad, aby ochroniæ u¿ytkowników
     przed prostymi sposobami social engineering, nale¿y w³±czyæ dyrektywê
     <literal>session.use_only_cookies</literal>. W takim przypadku u¿ytkownik
     musi mieæ w swojej przegl±darce w³±czone ciasteczka - inaczej sesje nie
     bêd± dzia³aæ.
    </para>
    <para>
     Istnieje kilka dróg, przez które istniej±cy identyfikator sesji mo¿e
     zostaæ przejêty przez osoby trzecie. Przejêty identyfikator sesji pozwala
     osobom trzecim uzyskaæ dostêp do wszystkich zasobów powi±zanych z dan±
     sesj±. Po pierwsze, identyfikator mo¿e byæ przejêty poprzez URLe
     zawieraj±ce identyfikatory sesji. Je¶li serwis zawiera linki do stron
     zewnêtrznych, URL zawieraj±cy identyfikator sesji mo¿e byæ zapisany w
     logach odno¶ników (referrer) tego zewnêtrznego serwisu. Po drugie,
     bardziej aktywny napastnik mo¿e pods³uchaæ ruch sieciowy. Je¶li nie jest
     on zaszyfrowany, identyfikatory bêd± przesy³ane przez sieæ czystym
     tekstem. Rozwi±zaniem tego problemu jest zaimplementowanie szyfrowania
     SSL i uczynienie go obowi±zkowym dla wszystkich u¿ytkowników.
    </para>
   </section>
   <section xml:id="session.requirements">
    &reftitle.required;
    &no.requirement;
    <note>
     <para>
      Opcjonalnie mo¿liwe jest u¿ywanie do przechowywania sesji pamiêci
      wspó³dzielonej (mm), co zosta³o zaimplementowane przez Ralfa S.
      Engelschalla. Nale¿y pobraæ rozszerzenie
      <link xlink:href="&url.mm;">mm</link> i zainstalowaæ je. Opcja ta nie jest
      dostêpna na platformy Windows. Modu³ przechowywania sesji mm nie
      gwarantuje jednak, ¿e równoczesny dostêp do tej samej sesji jest
      w³a¶ciwie blokowany. Bardziej poprawne mo¿e byæ zastosowanie systemów
      plików opartych o pamiêæ wspó³dzielon± (takich jak tmpfs w systemach
      Solaris/Linux lub /dev/md na BSD) do przechowywania plików sesji,
      poniwa¿ s± one prawid³owo blokowane. Dane sesji s± przechowywane w
      pamiêci, a wiêc restart serwera HTTP powoduje ich usuniêcie.
     </para>
    </note>
   </section>

   &reference.session.configure;

   &reference.session.ini;

   <section xml:id="session.resources">
    &reftitle.resources;
    &no.resource;
   </section>

   &reference.session.constants;

   <section xml:id="session.examples">
    &reftitle.examples;
    <note>
     <para>
      Od wersji PHP 4.1.0 dostêpna jest globalna zmienna
      <varname>$_SESSION</varname>, podobnie jak <varname>$_POST</varname>,
      <varname>$_GET</varname>, <varname>$_REQUEST</varname> i tak dalej.  W
      odró¿nieniu od <varname>$HTTP_SESSION_VARS</varname>,
      <varname>$_SESSION</varname> jest zawsze globalna. W zwi±zku z tym, nie
      ma konieczno¶ci stosowania s³owa kluczowego <link
       linkend="language.variables.scope"><command>global</command></link> dla
      zmiennej <varname>$_SESSION</varname>. Nale¿y pamiêtaæ, ¿e dokumentacja
      zosta³a zmieniona tak, aby zalecaæ stosowanie wszêdzie
      <varname>$_SESSION</varname>. Mo¿liwa jest jednak zamiana
      <varname>$_SESSION</varname> na <varname>$HTTP_SESSION_VARS</varname>,
      zale¿nie od preferencji. Nale¿y tak¿e zauwa¿yæ, ¿e aby zmienna
      <varname>$_SESSION</varname> by³a dostêpna, niezbêdne jest rozpoczêcie
      sesji poprzez u¿ycie funkcji <function>session_start</function>.
     </para>
     <para>
      Klucze tablicy asocjacyjnej <varname>$_SESSION</varname> podlegaj± tym
      samym ograniczeniom co nazwy zwyk³ych zmiennych w PHP, tzn. nie mog±
      rozpoczynaæ siê od liczby i musz± rozpoczynaæ siê od litery lub znaku
      podkre¶lenia. Wiêcej szczegó³ów mo¿na znale¼æ w rozdziale
      <link linkend='language.variables'>zmienne</link>.
     </para>
    </note>
    <para>
     Je¶li opcja <link
      linkend="ini.register-globals"><literal>register_globals</literal></link>
     jest wy³±czona, tylko pozycje nale¿±ce do zmiennej asocjacyjnej
     <varname>$_SESSION</varname> mog± byæ zarejestrowane jako
     zmienne sesyjne. Odtworzone zmienne sesyjne bêd± dostêpne tylko w zmiennej
     <varname>$_SESSION</varname>.
    </para>
    <para>
     U¿ycie <varname>$_SESSION</varname> (lub
     <varname>$HTTP_SESSION_VARS</varname> dla wersji PHP 4.0.6 i starszych)
     jest wskazane ze wzglêdów poprawionego bezpieczeñstwa i czytelno¶ci kodu. U¿ywaj±c
     <varname>$_SESSION</varname> nie ma potrzeby u¿ywaæ funkcji
     <function>session_register()</function>,
     <function>session_unregister()</function> czy
     <function>session_is_registered()</function>. Zmienne sesyjne s± dostêpne
     tak jak wszystkie inne zmienne. 
     <example>
      <title>
       Rejestrowanie zmiennych przez <varname>$_SESSION</varname>
      </title>
      <programlisting role="php">
<![CDATA[
<?php
session_start();
// U¿yj $HTTP_SESSION_VARS dla PHP 4.0.6 i starszych
if (!isset($_SESSION['count'])) {
    $_SESSION['count'] = 0;
} else {
    $_SESSION['count']++;
}
?>
]]>
      </programlisting>
     </example>
     <example>
      <title>
       Wyrejestrowywanie zmiennej korzystaj±c z <varname>$_SESSION</varname>
       przy wy³±czonej dyrektywie <link
        linkend="ini.register-globals">register_globals</link>
      </title>
      <programlisting role="php">
<![CDATA[
<?php
session_start()
// U¿yj $HTTP_SESSION_VARS dla PHP 4.0.6 i starszych
unset($_SESSION['count']);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <caution>
      <para>
       Nie nale¿y usuwaæ ca³ej tablicy <varname>$_SESSION</varname> wyra¿eniem
       <literal>unset($_SESSION)</literal>, jako ¿e uniemo¿liwi to
       rejestrowanie zmiennych sesyjnych poprzez tablicê superglobaln±
      </para>
     </caution>
    </para>
    <warning>
     <para>
      W sesjach nie jest mo¿liwe zapisywanie referencji, jako ¿e nie ma
      sensownej metody przywracania referencji do innych zmiennych.
     </para>
    </warning>
    <para>
     Je¶li w³±czona jest dyrektywa <link
      linkend="ini.register-globals">register_globals</link>, ka¿da globalna
     zmienna mo¿e zostaæ zarejestrowana jako zmienna sesyjna. Po restarcie
     sesji, zmienne te s± przywracane jako odpowiednie zmienne globalne.
     Poniewa¿ PHP musi wiedzieæ które zmienne s± zarejestrowane jako zmienne
     sesji, nalezy je zarejestrowaæ poprzez funkcjê
     <function>session_register</function>. Etap ten mo¿na pomin±æ poprzez
     dodawanie wpisów do tablicy <varname>$_SESSION</varname>.
     <caution>
      <para> W wersjach wcze¶niejszych od PHP 4.3, u¿ywaj±c tablicy
       <varname>$_SESSION</varname> przy wy³±czonej dyrektywie <link
        linkend="ini.register-globals">register_globals</link>, nie nale¿y
       u¿ywaæ funkcji <function>session_register</function>,
       <function>session_is_registered</function> i
       <function>session_unregister</function>.  Wy³±czenie <link
        linkend="ini.register-globals">register_globals</link> jest zalecane
       ze wzglêdów bezpieczeñstwa i wydajno¶ci.
      </para>
     </caution>
    </para>
    <para>
     Je¶li dyrektywa <link
      linkend="ini.register-globals">register_globals</link> jest w³±czona, to
     zmienne globalne i wpisy w tablicy <varname>$_SESSION</varname>
     automatycznie wskazuj± na t± sam± warto¶æ, która zosta³a zarejestrowana w
     poprzedniej instancji sesji. Jednak¿e je¶li zmienna zosta³a
     zarejestrowana poprzez tablicê <varname>$_SESSION</varname>, to zmienna
     globalna dostêpna jest dopiero w nastêpnym wywo³aniu.
    </para>
    <para>
     PHP w wersji 4.2.3 i wcze¶niejszych posiada pewien b³±d. Przy rejestracji
     w sesji nowej zmiennej poprzez funkcjê
     <function>session_register</function>, wpis w zasiêgu globalnym i wpis w
     <varname>$_SESSION</varname> nie bêd± referencjami do tej samej warto¶ci
     do czasu nastêpnego wywo³ania <function>session_start</function>. Na
     przyk³ad, modyfikacja nowo zarejestrowanej zmiennej globalej nie znajdzie
     odbicia we wpisie w tablicy <varname>$_SESSION</varname>. B³±d ten zosta³
     poprawiony w PHP 4.3.
    </para>
   </section>

   <section xml:id="session.idpassing">
    <title>Przekazywanie identyfikatora sesji</title>
    <para>
     Istniej± dwie metody propagacji identyfikatora sesji:
     <itemizedlist>
      <listitem>
       <simpara>
        Ciasteczka
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Parametry URL'a
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Modu³ sesji obs³uguje obie metody. Ciasteczka s± metod± optymaln±, ale
     jako ¿e nie s± one zawsze dostêpne, zapewniona jest tak¿e metoda
     alternatywna. Metoda ta polega na dopisywaniu identyfikatora bezpo¶rednio
     do adresu URL.
    </para>
    <para>
     PHP jest zdolne do przezroczystego przetwarzania odno¶ników. U¿ywaj±c PHP
     w wersji wcze¶niejszej ni¿ 4.2, niezbêdne jest rêczne w³±czenie tej opcji
     przy kompilacji. W systemach Unix, nale¿y dodaæ parametr
     <link linkend="install.configure.enable-trans-sid">
      <literal>--enable-trans-sid</literal></link> przy konfiguracji
     kompilacji. Je¶li PHP zostanie skompilowane z t± opcj±, a tak¿e w³±czona
     zostanie dyrektywa konfiguracji <literal>session.use_trans_sid</literal>,
     wszystkie wzglêdne adresy URI zostan± automatycznie poprawione tak, aby
     zawiera³y identyfikator sesji. 
    </para>
    <note>
     <para>
      Dyrektywa <link linkend="ini.arg-separator.output">arg_separator.output
      </link>, któr± mo¿na umie¶ciæ w pliku konfiguracyjnym &php.ini;, pozwala
      ustawiæ w³asny separator argumentów. Dla zachowania pe³nej zgodno¶ci ze
      standardem XHTML, nale¿y w tym miejscu podaæ warto¶æ &amp;amp;.
     </para>
    </note>
    <para>
     Mo¿liwe jest tak¿e zastosowanie sta³ej <literal>SID</literal>, która jest
     definiowana w momencie rozpoczêcia sesji. Je¶li klient nie przes³a³
     poprawnego ciasteczka sesyjnego, sta³a ta ma postaæ
     <literal>nazwa_sesji=id_sesji</literal>. W przeciwnym przypadku jest to
     pusty ci±g. W zwi±zku z tym, sta³a ta mo¿e byæ wstawiona do adresów bez
     konieczno¶ci stosowania instrukcji warunkowych.
    </para>
    <para>
     Poni¿szy przyk³ad demonstruje jak zarejestrowaæ zmienn± i jak prawid³owo
     wstawiæ link do kolejnej strony korzystaj±c ze sta³ej SID.
     <example>
      <title>Zliczanie ilo¶ci odwiedzin pojedyñczego u¿ytkownika</title>
      <programlisting role="php">
<![CDATA[
<?php
if (!session_is_registered('count')) {
    session_register('count');
    $count = 1;
} else {
    $count++;
}
?>

<p>
 Witaj go¶ciu. Ogl±dasz t± stronê <?php echo $count; ?> raz.
</p>

<p>
 Aby kontynuowaæ, <a href="nextpage.php?<?php echo strip_tags(SID); ?>">kliknij tutaj</A>
</p>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Funkcja <function>strip_tags</function> zosta³a zastosowana w celu
     zapobie¿enia atakom typu XSS. 
    </para>
    <para>
     Dodawanie sta³ej SID do adresów, jak to zosta³o zrobione w powy¿szym
     przyk³adzie, nie jest konieczne, je¶li PHP zosta³o skompilowane z opcj±
     <link linkend="ini.session.use-trans-sid">--enable-trans-sid</link>.
    </para>
    <note>
     <para>
      PHP zak³ada, ¿e bezwzglêdne URLe odnosz± siê do zewnêtrznych serwisów,
      wiêc nie trzeba przekazywaæ SID, poniewa¿ istnia³oby niebezpieczeñstwo
      podkradania SIDów przez inny serwer.
     </para>
    </note>
   </section>
   <section xml:id="session.customhandler">
    <title>Custom Session Handlers</title>
    <para>
     Aby zaimplementowaæ przechowywanie danych sesyjnych w bazie danych lub w
     dowolnej innej postaci, nale¿y u¿yæ
     <function>session_set_save_handler</function> do stworzenia zestawu
     funkcji przechowuj±cych dane.
    </para>
   </section>
  </partintro>

  &reference.session.entities.functions;

 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil 
sgml-parent-document:nil
sgml-default-dtd-file:"../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

