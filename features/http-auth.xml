<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: af4410a7e15898c3dbe83d6ea38246745ed9c6fb Maintainer: joeaccord Status: ready -->
<!-- $Revision$ -->
<!-- CREDITS: slawek -->
 <chapter xml:id="features.http-auth" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Uwierzytelnianie HTTP w PHP</title>

  <simpara>
   Uwierzytelnianie <acronym>HTTP</acronym> jest obs³ugiwana przez PHP tylko wtedy, gdy PHP pracuje
   jako modu³ Apache'a, nie jest dostêpna w trybie CGI. W skrypcie mo¿na u¿yæ
   funkcji <function>header</function> by wys³aæ do przegl±darki komunikat
   <literal>"Wymagana autoryzacja"</literal>, co spowoduje wy¶wietlenie okienka z polami
   U¿ytkownik i Has³o. Po wype³nieniu przez u¿ytkownika tych pól, URL
   zawieraj±cy skrypt PHP zostanie ponownie wywo³any z ustawionymi
   <link linkend="reserved.variables">predefiniowanymi zmiennymi</link>
   <varname>PHP_AUTH_USER</varname>, <varname>PHP_AUTH_PW</varname> i
   <varname>AUTH_TYPE</varname> zawieraj±cymi odpowiednio
   nazwê u¿ytkownika, has³o i typ autoryzacji. Zmienne te bêd± dostêpne w
   tablicach <varname>$_SERVER</varname> oraz
   <varname>$HTTP_SERVER_VARS</varname>. Obecnie obs³ugiwane s± autoryzacje
   typu "Basic" i "Digest" (od PHP 5.1.0). Wiêcej informacji mo¿na znaleŸæ w opisie funkcji
   <function>header</function>.
  </simpara>

  <note>
   <title>Notatka dotycz±ca wersji PHP</title>
   <para>
    <link linkend="language.variables.superglobals">Zmienne superglobalne</link>,
    takie jak <varname>$_SERVER</varname>, udostêpniono
    w PHP <link xlink:href="&url.php.release4.1.0;">4.1.0</link>.
   </para>
  </note>

  <para>
   Przyk³adowy skrypt wymuszaj±cy autoryzacjê klienta:
  </para>
  <para>
   <example>
    <title>Uwierzytelnianie Basic HTTP</title>
    <programlisting role="php">
<![CDATA[
<?php
if (!isset($_SERVER['PHP_AUTH_USER'])) {
    header('WWW-Authenticate: Basic realm="My Realm"');
    header('HTTP/1.0 401 Unauthorized');
    echo 'Tekst do wys³ania, je¶li u¿ytkownik wci¶nie przycisk Anuluj';
    exit;
} else {
    echo "<p>Hej {$_SERVER['PHP_AUTH_USER']}.</p>";
    echo "<p>Twoje has³o to {$_SERVER['PHP_AUTH_PW']}.</p>";
}
?>
]]>
    </programlisting>
   </example>
  </para>

  <para>
   <example>
    <title>Przyk³ad uwierzytelnianie Digest HTTP</title>
    <para>
     Ten przyk³ad pokazuje jak zaimplementowaæ proste umierzytelnianie
     Digest HTTP. Wiêcej informacji znajduje siê w dokumencie <link
      xlink:href="&url.rfc;2617">RFC 2617</link>.
    </para>
    <programlisting role="php">
<![CDATA[
<?php
$realm = 'Zastrze¿ona strefa';

//user => password
$users = array('admin' => 'mypass', 'guest' => 'guest');


if (empty($_SERVER['PHP_AUTH_DIGEST'])) {
    header('HTTP/1.1 401 Unauthorized');
    header('WWW-Authenticate: Digest realm="'.$realm.
           '",qop="auth",nonce="'.uniqid().'",opaque="'.md5($realm).'"');

    die('Tekst do wys³ania kiedy u¿ytkownik kliknie klawisz anuluj');
}


// analiza zmiennej PHP_AUTH_DIGEST
if (!($data = http_digest_parse($_SERVER['PHP_AUTH_DIGEST'])) ||
    !isset($users[$data['username']]))
    die('Nieprawid³owe listy uwierzytelniaj±ce!');


// tworzenie prawid³owej odpowiedzi
$A1 = md5($data['username'] . ':' . $realm . ':' . $users[$data['username']]);
$A2 = md5($_SERVER['REQUEST_METHOD'].':'.$data['uri']);
$valid_response = md5($A1.':'.$data['nonce'].':'.$data['nc'].':'.$data['cnonce'].':'.$data['qop'].':'.$A2);

if ($data['response'] != $valid_response)
    die('Nieprawid³owe listy uwierzytelniaj±ce!');

// ok, prawid³owa nazwa u¿ytkownika i has³o
echo 'Jeste¶ zalogowany jako: ' . $data['username'];


// function to parse the http auth header
function http_digest_parse($txt)
{
    // zabezpieczenie przeciwko brakuj±cym informacjom
    $needed_parts = array('nonce'=>1, 'nc'=>1, 'cnonce'=>1, 'qop'=>1, 'username'=>1, 'uri'=>1, 'response'=>1);
    $data = array();
    $keys = implode('|', array_keys($needed_parts));

    preg_match_all('@(\w+)=(?:([\'"])([^\2]+)\2|([^\s,]+))@', $txt, $matches, PREG_SET_ORDER);

    foreach ($matches as $m) {
        $data[$m[1]] = $m[3] ? $m[3] : $m[4];
        unset($needed_parts[$m[1]]);
    }

    return $needed_parts ? false : $data;
}
?>
]]>
    </programlisting>
   </example>
  </para>

  <note>
   <title>Kompatybilno¶æ</title>
   <para>
    Nale¿y uwa¿aæ z linijkami dodawanymi do nag³ówka HTTP. W celu zachowania maksymalnej
    zgodno¶ci ze wszystkimi klientami, s³owo Basic powinno zaczynaæ siê du¿±
    liter± "B", warto¶æ realm powinna byæ otoczona  cudzys³owami (nie apostrofami),
    i dok³adnie jeden znak odstêpu powinien poprzedzaæ kod <emphasis>401</emphasis> w linii
    <emphasis>HTTP/1.0 401</emphasis>. Parametry autoryzacyjne musz± byæ
    oddzielone przecinkami jak pokazano to w przyk³adzie digest powy¿ej.
   </para>
  </note>

  <para>
   Zamiast wy¶wietlaæ warto¶æ <varname>PHP_AUTH_USER</varname> i
   <varname>PHP_AUTH_PW</varname>, jak to zrobiono w powy¿szym przyk³adzie,
   zechcesz zapewne sprawdziæ poprawno¶æ nazwy u¿ytkownika i has³a. Na przyk³ad
   poprzez zapytanie do bazy danych lub odnalezienie u¿ytkownika w pliku dbm.
  </para>

  <para>
   Nale¿y uwa¿aæ na kapry¶ne przegl±darki Internet Explorer. S± wra¿liwe na
   kolejno¶æ wysy³anych nag³ówków HTTP. Wys³anie nag³owka
   <emphasis>WWW-Authenticate</emphasis> przed
   <literal>HTTP/1.0 401</literal> powinno rozwi±zaæ problem.
  </para>

  <simpara>
   Od PHP 4.3.0, aby zapobiec sytuacji w której kto¶ napisze skrypt
   wykradaj±cy has³o wys³ane tradycyjnym zewnêtrznym mechanizmem,
   zmienne PHP_AUTH nie bêd± ustawiane, je¶li dla danej strony
   aktywna jest autoryzacja zewnêtrzna
   i &safemode; jest w³±czony.  Bez wzglêdu na to,
   <varname>REMOTE_USER</varname> mo¿e zostaæ u¿yte do zidentyfikowania
   u¿ytkownika autoryzowanego zewnêtrznie  Zatem, mo¿esz u¿yæ
   <varname>$_SERVER['REMOTE_USER']</varname>.
  </simpara>

  <note>
   <title>Konfiguracja</title>
   <para>
    Aby wykryæ czy mia³a miejsce zewnêtrzna autoryzacja, PHP sprwadza
    obecno¶æ dyrektywy <literal>AuthType</literal>.
   </para>
  </note>

  <simpara>
   Powy¿sza metoda nie zapobiega jednak wykradaniu hase³ do stron wymagaj±cych
   autoryzacji przez kogo¶, kto na tym samym serwerze kontroluje strony nie
   wymagaj±ce autoryzacji.
  </simpara>
  <simpara>
   Zarówno Netscape Navigator jak i Internet Explorer opró¿ni± bufor
   autoryzacji po otrzymaniu od serwera kodu 401. Mo¿na w ten sposób
   wylogowaniæ u¿ytkownika i zmusiæ go do ponownego wys³ania nazwy u¿ytkownika
   i has³a. Tej metody mo¿na u¿yæ do wylogowania u¿ytkownika po okre¶lonym
   czasie lub stworzenia przycisku "Wyloguj".
  </simpara>
  <para>
   <example>
    <title>Uwierzytelnianie HTTP z wymuszeniem przelogowania</title>
    <programlisting role="php">
<![CDATA[
<?php
function authenticate() {
    header('WWW-Authenticate: Basic realm="Testowy system autoryzacji"');
    header('HTTP/1.0 401 Unauthorized');
    echo "Musisz podaæ poprawny login i has³o by wej¶æ na tê stronê\n";
    exit;
}

if (!isset($_SERVER['PHP_AUTH_USER']) ||
    ($_POST['SeenBefore'] == 1 && $_POST['OldAuth'] == $_SERVER['PHP_AUTH_USER'])) {
    authenticate();
} else {
    echo "<p>Witaj: {$_SERVER['PHP_AUTH_USER']}<br />";
    echo "Poprzednio: {$_REQUEST['OldAuth']}";
    echo "<form action='{$_SERVER['PHP_SELF']}' METHOD='post'>\n";
    echo "<input type='hidden' name='SeenBefore' value='1' />\n";
    echo "<input type='hidden' name='OldAuth' value='{$_SERVER['PHP_AUTH_USER']}' />\n";
    echo "<input type='submit' value='Re Authenticate' />\n";
    echo "</form></p>\n";
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <simpara>
   Powy¿sza metoda nie jest wymagana przez autoryzacjê <literal>HTTP Basic</literal>,
   wiêc nie mo¿na na niej polegaæ. Testy z przegl±dark±
   <literal>Lynx</literal> pokaza³y, ¿e <literal>Lynx</literal> nie usuwa danych
   o autoryzacji po odebraniu od serwera kodu 401, zatem przej¶cie wstecz a nastêpnie
   do przodu otworzy stronê, chyba, ¿e
   wymagania co do danych autoryzacji zmieni³y siê. U¿ytkownik mo¿e jednak
   u¿yæ klawisza <literal>'_'</literal> by usun±c dane o autoryzacji.
  </simpara>
  <simpara>
   Zwóæ uwagê, ¿e do wersji PHP 4.3.3, Autoryzacja HTTP nie dzia³a³a
   na serwerze Microsoft IIS z PHP w wersji CGI z powodu
   ograniczeñ IIS. Aby zmusiæ go do dzia³ania w PHP 4.3.3+
   musisz wyedytowaæ "<literal>Bezpieczeñstwo katalogów</literal>" w konfiguracji IIS. Kliknij
   na "<literal>Edytuj</literal>" i zaznacz wy³±cznie
   "<literal>Anonimowy Dostêp</literal>", wszystkie inne pola
   powinny pozostaæ nie zaznaczone.
  </simpara>
  <simpara>
   Inne ogranicznie jest je¶li u¿ywasz modu³u IIS (ISAPI) i PHP 4, nie mo¿esz
   wtedy u¿yæ zmiennych <literal>PHP_AUTH_*</literal> ale zamiast nich,
   dostêpna jest zmienna <literal>HTTP_AUTHORIZATION</literal>. Na przyk³ad
   rozwa¿ nastêpuj±cy kod: <literal>list($user, $pw) = explode(':',
   base64_decode(substr($_SERVER['HTTP_AUTHORIZATION'], 6)));</literal>
  </simpara>
  <note>
   <title>Notatka IIS:</title>
   <simpara>
    Aby Autoryzacja HTTP dzia³a³a z IIS, dyrektywa PHP
    <link linkend="ini.cgi.rfc2616-headers">cgi.rfc2616_headers</link> musi
    byæ ustawiona na <literal>0</literal> (domy¶lna warto¶æ).
   </simpara>
  </note>
  <note>
   <para>
    Je¶li w³±czony jest <link linkend="ini.safe-mode">tryb bezpieczny</link>,
    uid skryptu jest doklejany do pola <literal>realm</literal> nag³ówka
    <literal>WWW-Authenticate</literal>.
   </para>
  </note>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
